var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/obsidian-smart-env/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/obsidian-smart-env/node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// src/index.js
var src_exports = {};
__export(src_exports, {
  default: () => SmartConnectionsPlugin
});
module.exports = __toCommonJS(src_exports);
var import_obsidian56 = __toESM(require("obsidian"), 1);

// node_modules/obsidian-smart-env/smart_env.js
var import_obsidian20 = require("obsidian");

// node_modules/obsidian-smart-env/node_modules/smart-environment/components/settings.js
async function build_html(env, opts = {}) {
  const env_settings_html = Object.entries(env.settings_config).map(([setting_key, setting_config]) => {
    if (!setting_config.setting) setting_config.setting = setting_key;
    return this.render_setting_html(setting_config);
  }).join("\n");
  const env_collections_containers_html = Object.entries(env.collections).map(([collection_key, collection]) => {
    return `<div data-smart-settings="${collection_key}"></div>`;
  }).join("\n");
  const html = `
    <div class="">
      ${env_settings_html}
      ${env_collections_containers_html}
    </div>
  `;
  return html;
}
async function render(env, opts = {}) {
  const html = await build_html.call(this, env, opts);
  const frag = this.create_doc_fragment(html);
  return await post_process.call(this, env, frag, opts);
}
async function post_process(env, frag, opts = {}) {
  await this.render_setting_components(frag, { scope: env });
  const env_collections_containers = frag.querySelectorAll("[data-smart-settings]");
  for (const env_collections_container of env_collections_containers) {
    const collection_key = env_collections_container.dataset.smartSettings;
    const collection = env[collection_key];
    await collection.render_settings(env_collections_container);
  }
  return frag;
}

// node_modules/obsidian-smart-env/node_modules/smart-settings/smart_settings.js
var SmartSettings = class {
  /**
   * Creates an instance of SmartEnvSettings.
   * @param {Object} main - The main object to contain the instance (smart_settings) and getter (settings)
   * @param {Object} [opts={}] - Configuration options.
   */
  constructor(main, opts = {}) {
    this.main = main;
    this.opts = opts;
    this._fs = null;
    this._settings = {};
    this._saved = false;
    this.save_timeout = null;
  }
  static async create(main, opts = {}) {
    const smart_settings = new this(main, opts);
    await smart_settings.load();
    main.smart_settings = smart_settings;
    Object.defineProperty(main, "settings", {
      get() {
        return smart_settings.settings;
      },
      set(settings) {
        smart_settings.settings = settings;
      }
    });
    return smart_settings;
  }
  static create_sync(main, opts = {}) {
    const smart_settings = new this(main, opts);
    smart_settings.load_sync();
    main.smart_settings = smart_settings;
    Object.defineProperty(main, "settings", {
      get() {
        return smart_settings.settings;
      },
      set(settings) {
        smart_settings.settings = settings;
      }
    });
    return smart_settings;
  }
  /**
   * Gets the current settings, wrapped with an observer to handle changes.
   * @returns {Proxy} A proxy object that observes changes to the settings.
   */
  get settings() {
    return observe_object(this._settings, (property, value, target) => {
      if (this.save_timeout) clearTimeout(this.save_timeout);
      this.save_timeout = setTimeout(() => {
        this.save(this._settings);
        this.save_timeout = null;
      }, 1e3);
    });
  }
  /**
   * Sets the current settings.
   * @param {Object} settings - The new settings to apply.
   */
  set settings(settings) {
    this._settings = settings;
  }
  async save(settings = this._settings) {
    if (typeof this.opts.save === "function") await this.opts.save(settings);
    else await this.main.save_settings(settings);
  }
  async load() {
    if (typeof this.opts.load === "function") this._settings = await this.opts.load();
    else this._settings = await this.main.load_settings();
  }
  load_sync() {
    if (typeof this.opts.load === "function") this._settings = this.opts.load();
    else this._settings = this.main.load_settings();
  }
};
function observe_object(obj, on_change) {
  function create_proxy(target) {
    return new Proxy(target, {
      set(target2, property, value) {
        if (target2[property] !== value) {
          target2[property] = value;
          on_change(property, value, target2);
        }
        if (typeof value === "object" && value !== null) {
          target2[property] = create_proxy(value);
        }
        return true;
      },
      get(target2, property) {
        const result = target2[property];
        if (typeof result === "object" && result !== null) {
          return create_proxy(result);
        }
        return result;
      },
      deleteProperty(target2, property) {
        if (property in target2) {
          delete target2[property];
          on_change(property, void 0, target2);
        }
        return true;
      }
    });
  }
  return create_proxy(obj);
}

// node_modules/obsidian-smart-env/node_modules/smart-environment/utils/is_plain_object.js
function is_plain_object(o) {
  if (o === null) return false;
  if (typeof o !== "object") return false;
  if (Array.isArray(o)) return false;
  if (o instanceof Function) return false;
  if (o instanceof Date) return false;
  return Object.getPrototypeOf(o) === Object.prototype;
}

// node_modules/obsidian-smart-env/node_modules/smart-environment/utils/deep_merge.js
function deep_merge(target, source2) {
  for (const key in source2) {
    if (!Object.prototype.hasOwnProperty.call(source2, key)) continue;
    if (is_plain_object(source2[key]) && is_plain_object(target[key])) {
      deep_merge(target[key], source2[key]);
    } else {
      target[key] = source2[key];
    }
  }
  return target;
}

// node_modules/obsidian-smart-env/node_modules/smart-environment/utils/camel_case_to_snake_case.js
function camel_case_to_snake_case(str) {
  const result = str.replace(/([A-Z])/g, (match) => `_${match.toLowerCase()}`).replace(/^_/, "").replace(/2$/, "");
  return result;
}

// node_modules/obsidian-smart-env/node_modules/smart-environment/utils/normalize_opts.js
function normalize_opts(opts) {
  if (!opts.collections) opts.collections = {};
  if (!opts.modules) opts.modules = {};
  if (!opts.items) opts.items = {};
  Object.entries(opts.collections).forEach(([key, val]) => {
    if (typeof val === "function") {
      opts.collections[key] = { class: val };
    }
    const new_key = camel_case_to_snake_case(key);
    if (new_key !== key) {
      opts.collections[new_key] = opts.collections[key];
      delete opts.collections[key];
    }
    if (!opts.collections[new_key].collection_key) opts.collections[new_key].collection_key = new_key;
    if (val.item_type) {
      opts.items[camel_case_to_snake_case(val.item_type.name)] = {
        class: val.item_type
      };
    }
  });
  Object.entries(opts.modules).forEach(([key, val]) => {
    if (typeof val === "function") {
      opts.modules[key] = { class: val };
    }
    const new_key = camel_case_to_snake_case(key);
    if (new_key !== key) {
      opts.modules[new_key] = opts.modules[key];
      delete opts.modules[key];
    }
  });
  if (!opts.item_types) opts.item_types = {};
  if (!opts.items) opts.items = {};
  Object.entries(opts.item_types).forEach(([key, val]) => {
    if (typeof val === "function") {
      const new_key = camel_case_to_snake_case(key);
      opts.items[new_key] = {
        class: val,
        actions: {},
        ...opts.items[new_key] || {}
      };
    }
  });
  return opts;
}

// node_modules/obsidian-smart-env/node_modules/smart-environment/utils/deep_clone_config.js
function is_plain_object2(value) {
  if (!value || typeof value !== "object") return false;
  const proto = Object.getPrototypeOf(value);
  return proto === Object.prototype || proto === null;
}
function deep_clone_config(input) {
  if (Array.isArray(input)) {
    return input.map((item) => deep_clone_config(item));
  }
  if (is_plain_object2(input)) {
    const output = {};
    for (const [k, v] of Object.entries(input)) {
      output[k] = deep_clone_config(v);
    }
    return output;
  }
  return input;
}

// node_modules/obsidian-smart-env/node_modules/smart-environment/utils/deep_merge_no_overwrite.js
function deep_merge_no_overwrite(target, source2, path = []) {
  if (!is_plain_object(target) || !is_plain_object(source2)) {
    return target;
  }
  if (path.includes(source2)) {
    return target;
  }
  path.push(source2);
  for (const key of Object.keys(source2)) {
    if (!Object.prototype.hasOwnProperty.call(source2, key)) {
      continue;
    }
    const val = source2[key];
    if (Array.isArray(target[key]) && Array.isArray(val)) {
      for (const item of val) {
        if (typeof item === "function") {
          const item_name = item.name;
          const has_same_fn = target[key].some(
            (el) => typeof el === "function" && el.name === item_name
          );
          if (!has_same_fn) {
            target[key].push(item);
          }
        } else if (item === null || ["string", "number", "boolean", "undefined"].includes(typeof item)) {
          if (!target[key].includes(item)) {
            target[key].push(item);
          }
        } else {
          target[key].push(item);
        }
      }
    } else if (is_plain_object(val)) {
      if (!is_plain_object(target[key])) {
        target[key] = {};
      }
      deep_merge_no_overwrite(target[key], val, [...path]);
    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
      target[key] = val;
    }
  }
  return target;
}

// node_modules/obsidian-smart-env/node_modules/smart-environment/utils/merge_env_config.js
function merge_env_config(target, incoming) {
  for (const [key, value] of Object.entries(incoming)) {
    if (key === "collections" && value && typeof value === "object") {
      if (!target.collections) target.collections = {};
      for (const [col_key, col_def] of Object.entries(value)) {
        const existing_def = target.collections[col_key];
        if (!existing_def) {
          target.collections[col_key] = { ...col_def };
          continue;
        }
        const new_ver = +(col_def?.class?.version ?? 0);
        const cur_ver = +(existing_def?.class?.version ?? 0);
        if (new_ver > cur_ver) {
          const replaced = { ...col_def };
          deep_merge_no_overwrite(replaced, existing_def);
          target.collections[col_key] = replaced;
        } else {
          deep_merge_no_overwrite(existing_def, col_def);
        }
      }
      continue;
    }
    if (key === "components" && value && typeof value === "object") {
      if (!target.components) target.components = {};
      for (const [comp_key, comp_def] of Object.entries(value)) {
        if (!target.components[comp_key]) target.components[comp_key] = comp_def;
        else {
          const new_ver = +(comp_def?.version ?? 0);
          const cur_ver = +(target.components[comp_key]?.version ?? 0);
          if (new_ver > cur_ver) {
            target.components[comp_key] = comp_def;
          } else {
            deep_merge_no_overwrite(target.components[comp_key], comp_def);
          }
        }
      }
      continue;
    }
    if (Array.isArray(value)) {
      if (Array.isArray(target[key])) {
        if (value.length > 0 && (typeof value[0] === "string" || typeof value[0] === "number" || typeof value[0] === "boolean")) {
          target[key] = Array.from(/* @__PURE__ */ new Set([...target[key], ...value]));
        } else {
          target[key] = [...target[key], ...value];
        }
      } else {
        if (value.length > 0 && (typeof value[0] === "string" || typeof value[0] === "number" || typeof value[0] === "boolean")) {
          target[key] = Array.from(new Set(value));
        } else {
          target[key] = [...value];
        }
      }
    } else if (value && typeof value === "object") {
      if (!target[key]) target[key] = {};
      deep_merge_no_overwrite(target[key], value);
    } else {
      target[key] = value;
    }
  }
  return target;
}

// node_modules/obsidian-smart-env/node_modules/smart-environment/smart_env.js
var ROOT_SCOPE = typeof globalThis !== "undefined" ? globalThis : Function("return this")();
var SmartEnv = class {
  /**
   * @type {number} version - Bump this number when shipping a new version of SmartEnv.
   * If a newer version is loaded into a runtime that already has an older environment,
   * an automatic reload of all existing mains will occur.
   */
  static version = 2.139247;
  scope_name = "smart_env";
  static global_ref = ROOT_SCOPE;
  global_ref = this.constructor.global_ref;
  constructor(opts = {}) {
    this.state = "init";
    this._components = {};
    this.collections = {};
    this.load_timeout = null;
    this._collections_version_signature = null;
    if (opts.primary_main_key) this.primary_main_key = opts.primary_main_key;
  }
  // ========================================================================
  // ──  CONFIG (now version-aware)                                          ──
  // ========================================================================
  /**
   * Builds or returns the cached configuration object.
   * The cache is invalidated automatically whenever the “version signature”
   * of any collection class changes (controlled by its static `version`).
   *
   * @returns {Object} the merged, up-to-date environment config
   */
  get config() {
    const signature = this.compute_collections_version_signature();
    if (this._config && signature === this._collections_version_signature) {
      return this._config;
    }
    this._collections_version_signature = signature;
    this._config = {};
    const sorted_configs = Object.entries(this.smart_env_configs).sort(([main_key]) => {
      if (!this.primary_main_key) return 0;
      return main_key === this.primary_main_key ? -1 : 0;
    });
    for (const [key, rec] of sorted_configs) {
      if (!rec?.main) {
        console.warn(`SmartEnv: '${key}' unloaded, skipping`);
        delete this.smart_env_configs[key];
        continue;
      }
      if (!rec?.opts) {
        console.warn(`SmartEnv: '${key}' opts missing, skipping`);
        continue;
      }
      merge_env_config(
        this._config,
        deep_clone_config(normalize_opts(rec.opts))
      );
    }
    return this._config;
  }
  /**
   * Produces a deterministic string representing the current versions of every
   * collection class across all mains.  When any collection ships a higher
   * `static version`, the signature changes – automatically invalidating the
   * cached `config`.
   *
   * @returns {string} pipe-delimited version signature
   */
  compute_collections_version_signature() {
    const list = [];
    for (const rec of Object.values(this.smart_env_configs)) {
      const { opts } = rec || {};
      if (!opts) continue;
      for (const [collection_key, def] of Object.entries(opts.collections || {})) {
        const cls = def?.class;
        const v = typeof cls?.version === "number" ? cls.version : 0;
        list.push(`${collection_key}:${v}`);
      }
    }
    return list.sort().join("|");
  }
  // ========================================================================
  // ──  GLOBAL HELPERS / STATIC API                                         ──
  // ========================================================================
  get env_start_wait_time() {
    if (typeof this.config.env_start_wait_time === "number") return this.config.env_start_wait_time;
    return 5e3;
  }
  static get global_env() {
    return this.global_ref.smart_env;
  }
  static set global_env(env) {
    this.global_ref.smart_env = env;
  }
  static get mains() {
    return Object.keys(this.global_ref.smart_env_configs || {});
  }
  get mains() {
    return Object.keys(this.global_ref.smart_env_configs || {});
  }
  static get should_reload() {
    if (!this.global_env) return true;
    if (this.global_env.state === "loaded") return true;
    if (typeof this.global_env?.constructor?.version === "undefined") return true;
    if (this.global_env.constructor.version < this.version) {
      console.warn(
        "SmartEnv: Reloading environment because of version mismatch",
        `${this.version} > ${this.global_env.constructor.version}`
      );
      return true;
    }
    return false;
  }
  static get smart_env_configs() {
    if (!this.global_ref.smart_env_configs) this.global_ref.smart_env_configs = {};
    return this.global_ref.smart_env_configs;
  }
  get smart_env_configs() {
    if (!this.global_ref.smart_env_configs) this.global_ref.smart_env_configs = {};
    return this.global_ref.smart_env_configs;
  }
  /**
   * Waits for either a specific main to be registered in the environment,
   * or (if `opts.main` is not specified) waits for environment collections to load.
   * @param {object} opts
   * @param {object} [opts.main] - if set, the function waits until that main is found.
   * @returns {Promise<SmartEnv>} Resolves with the environment instance
   */
  static wait_for(opts = {}) {
    return new Promise((resolve) => {
      if (opts.main) {
        const interval = setInterval(() => {
          if (this.global_env && this.global_env[opts.main]) {
            clearInterval(interval);
            resolve(this.global_env);
          }
        }, 1e3);
      } else {
        const interval = setInterval(() => {
          if (this.global_env && this.global_env.state === "loaded") {
            clearInterval(interval);
            resolve(this.global_env);
          }
        }, 100);
      }
    });
  }
  /**
   * Creates or updates a SmartEnv instance.
   * - If a global environment exists and is an older version or lacks 'init_main', it is replaced.
   * @param {Object} main - The main object to be added to the SmartEnv instance.
   * @param {Object} [main_env_opts={}] - Options for configuring the SmartEnv instance.
   * @returns {SmartEnv} The SmartEnv instance.
   * @throws {TypeError} If an invalid main object is provided.
   * @throws {Error} If there's an error creating or updating the SmartEnv instance.
   */
  static async create(main, main_env_opts = null) {
    if (!main || typeof main !== "object") {
      throw new TypeError("SmartEnv: Invalid main object provided");
    }
    if (!main_env_opts) {
      if (!main.smart_env_config) {
        throw new Error("SmartEnv: No main_env_opts or main.smart_env_config provided");
      }
      main_env_opts = main.smart_env_config;
    }
    this.add_main(main, main_env_opts);
    if (this.should_reload) {
      const opts = {};
      if (this.global_env && this.version > (this.global_env.constructor?.version || 0)) {
        opts.primary_main_key = camel_case_to_snake_case(main.constructor.name);
      }
      if (this.global_env?.load_timeout) clearTimeout(this.global_env.load_timeout);
      this.global_env = new this(opts);
      const g = this.global_ref;
      if (!g.all_envs) g.all_envs = [];
      g.all_envs.push(this.global_env);
    }
    clearTimeout(this.global_env.load_timeout);
    this.global_env.load_timeout = setTimeout(async () => {
      await this.global_env.load();
      this.global_env.load_timeout = null;
    }, this.global_env.env_start_wait_time);
    return this.global_env;
  }
  static add_main(main, main_env_opts = null) {
    if (this.global_env) {
      this.global_env._config = null;
      this.global_env._collections_version_signature = null;
    }
    if (!main_env_opts) main_env_opts = main.smart_env_config;
    const main_key = camel_case_to_snake_case(main.constructor.name);
    this.smart_env_configs[main_key] = { main, opts: main_env_opts };
    this.create_env_getter(main);
  }
  /**
   * Creates a dynamic environment getter on any instance object.
   * The returned 'env' property will yield the global `smart_env`.
   * @param {Object} instance_to_receive_getter
   */
  static create_env_getter(instance_to_receive_getter) {
    Object.defineProperty(instance_to_receive_getter, "env", {
      configurable: true,
      get: () => this.global_env
    });
  }
  create_env_getter(instance_to_receive_getter) {
    this.constructor.create_env_getter(instance_to_receive_getter);
  }
  async load() {
    this.state = "loading";
    await this.fs.load_files();
    if (!this.settings) await SmartSettings.create(this);
    if (this.config.default_settings) {
      deep_merge_no_overwrite(this.settings, this.config.default_settings);
    }
    this.smart_settings.save();
    await this.init_collections();
    for (const [main_key, { main, opts }] of Object.entries(this.smart_env_configs)) {
      this[main_key] = main;
    }
    await this.ready_to_load_collections();
    await this.load_collections();
    this.state = "loaded";
  }
  /**
   * Initializes collection classes if they have an 'init' function.
   * @param {Object} [config=this.config]
  */
  async init_collections(config = this.config) {
    for (const key of Object.keys(config.collections || {})) {
      const _class = config.collections[key]?.class;
      if (!_class) continue;
      if (_class.default_settings) {
        deep_merge_no_overwrite(
          this.settings,
          {
            [key]: _class.default_settings
          }
        );
      }
      if (typeof _class.init !== "function") continue;
      await _class.init(this, { ...config.collections[key] });
      this.collections[key] = "init";
    }
  }
  /**
   * Hook/Override this method to wait for any conditions before loading collections. 
   * @param {Object} main
   */
  async ready_to_load_collections() {
  }
  /**
   * Loads any available collections, processing their load queues.
   * @param {Object} [collections=this.collections] - Key-value map of collection instances.
   */
  async load_collections(collections = this.collections) {
    for (const key of Object.keys(collections || {})) {
      const time_start = Date.now();
      if (typeof this[key]?.process_load_queue === "function") {
        await this[key].process_load_queue();
        this[key].load_time_ms = Date.now() - time_start;
        this.collections[key] = "loaded";
        console.log(`Loaded ${this[key].collection_key} in ${this[key].load_time_ms}ms`);
      }
    }
  }
  /**
   * Removes a main from the global.smart_env_configs to exclude it on reload
   * @param {Class} main
   * @param {Object|null} [unload_config=null]
   */
  static unload_main(main) {
    const main_key = camel_case_to_snake_case(main.constructor.name);
    this.smart_env_configs[main_key] = null;
    delete this.smart_env_configs[main_key];
  }
  unload_main(main) {
    this.constructor.unload_main(main);
  }
  /**
   * Triggers a save event in all known collections.
   */
  save() {
    for (const key of Object.keys(this.collections)) {
      this[key].process_save_queue?.();
    }
  }
  /**
   * Initialize a module from the configured `this.opts.modules`.
   * @param {string} module_key
   * @param {object} opts
   * @returns {object|null} instance of the requested module or null if not found
   */
  init_module(module_key, opts = {}) {
    const module_config = this.opts.modules[module_key];
    if (!module_config) {
      return console.warn(`SmartEnv: module ${module_key} not found`);
    }
    opts = {
      ...{ ...module_config, class: null },
      ...opts
    };
    return new module_config.class(opts);
  }
  get notices() {
    if (!this._notices) {
      const SmartNoticesClass = this.config.modules.smart_notices.class;
      this._notices = new SmartNoticesClass(this, {
        adapter: this.config.modules.smart_notices.adapter
      });
    }
    return this._notices;
  }
  /**
   * Exposes a settings template function from environment opts or defaults.
   * @returns {Function}
   */
  get settings_template() {
    return this.opts.components?.smart_env?.settings || render;
  }
  /**
   * Renders settings UI into a container, using the environment's `settings_template`.
   * @param {HTMLElement} [container=this.settings_container]
   */
  async render_settings(container = this.settings_container) {
    if (!this.settings_container || container !== this.settings_container) {
      this.settings_container = container;
    }
    if (!container) {
      throw new Error("Container is required");
    }
    const frag = await this.render_component("settings", this, {});
    this.smart_view.empty(container);
    container.appendChild(frag);
    return frag;
  }
  /**
   * Renders a named component using an optional scope and options.
   * @param {string} component_key
   * @param {Object} scope
   * @param {Object} [opts]
   * @returns {Promise<HTMLElement>}
   */
  async render_component(component_key, scope, opts = {}) {
    const component_renderer = this.get_component(component_key, scope);
    if (!component_renderer) {
      console.warn(`SmartEnv: component ${component_key} not found for scope ${scope.constructor.name}`);
      return this.smart_view.create_doc_fragment(`<div class="smart-env-component-not-found">
        <h1>Component Not Found</h1>
        <p>The component ${component_key} was not found for scope ${scope.constructor.name}.</p>
      </div>`);
    }
    const frag = await component_renderer(scope, opts);
    return frag;
  }
  /**
   * Retrieves or creates a memoized component renderer function.
   * @param {string} component_key
   * @param {Object} scope
   * @returns {Function|undefined}
   */
  get_component(component_key, scope) {
    const scope_name = scope.collection_key ?? scope.scope_name;
    const _cache_key = scope_name ? `${scope_name}-${component_key}` : component_key;
    if (!this._components[_cache_key]) {
      try {
        if (this.opts.components[scope_name]?.[component_key]) {
          this._components[_cache_key] = this.opts.components[scope_name][component_key].bind(
            this.init_module("smart_view")
          );
        } else if (this.opts.components[component_key]) {
          this._components[_cache_key] = this.opts.components[component_key].bind(
            this.init_module("smart_view")
          );
        } else {
          console.warn(
            `SmartEnv: component ${component_key} not found for scope ${scope_name}`
          );
        }
      } catch (e) {
        console.error("Error getting component", e);
        console.log(
          `scope_name: ${scope_name}; component_key: ${component_key}; this.opts.components: ${Object.keys(
            this.opts.components || {}
          ).join(", ")}; this.opts.components[scope_name]: ${Object.keys(
            this.opts.components[scope_name] || {}
          ).join(", ")}`
        );
      }
    }
    return this._components[_cache_key];
  }
  /**
   * Lazily instantiate the module 'smart_view'.
   * @returns {object}
   */
  get smart_view() {
    if (!this._smart_view) {
      this._smart_view = this.init_module("smart_view");
    }
    return this._smart_view;
  }
  /**
   * A built-in settings schema for this environment.
   * @returns {Object}
   */
  get settings_config() {
    return {
      is_obsidian_vault: {
        name: "Obsidian Vault",
        description: "Toggle on if this is an Obsidian vault.",
        type: "toggle",
        default: false
      },
      file_exclusions: {
        name: "File Exclusions",
        description: "Comma-separated list of files to exclude.",
        type: "text",
        default: "",
        callback: "update_exclusions"
      },
      folder_exclusions: {
        name: "Folder Exclusions",
        description: "Comma-separated list of folders to exclude.",
        type: "text",
        default: "",
        callback: "update_exclusions"
      },
      excluded_headings: {
        name: "Excluded Headings",
        description: "Comma-separated list of headings to exclude. Note: currently only applies to blocks (2025-04-07).",
        type: "text",
        default: ""
      }
    };
  }
  get global_prop() {
    return this.opts.global_prop ?? "smart_env";
  }
  get item_types() {
    return this.opts.item_types;
  }
  get fs_module_config() {
    return this.opts.modules.smart_fs;
  }
  get fs() {
    if (!this.smart_fs) {
      this.smart_fs = new this.fs_module_config.class(this, {
        adapter: this.fs_module_config.adapter,
        fs_path: this.opts.env_path || ""
      });
    }
    return this.smart_fs;
  }
  get env_data_dir() {
    const env_settings_files = this.fs.file_paths?.filter((path) => path.endsWith("smart_env.json")) || [];
    let env_data_dir = ".smart-env";
    if (env_settings_files.length > 0) {
      if (env_settings_files.length > 1) {
        const env_data_dir_counts = env_settings_files.map((path) => {
          const dir = path.split("/").slice(-2, -1)[0];
          return {
            dir,
            count: this.fs.file_paths.filter((p) => p.includes(dir)).length
          };
        });
        env_data_dir = env_data_dir_counts.reduce(
          (max, dirObj) => dirObj.count > max.count ? dirObj : max,
          env_data_dir_counts[0]
        ).dir;
      } else {
        env_data_dir = env_settings_files[0].split("/").slice(-2, -1)[0];
      }
    }
    return env_data_dir;
  }
  get data_fs() {
    if (!this._fs) {
      this._fs = new this.fs_module_config.class(this, {
        adapter: this.fs_module_config.adapter,
        fs_path: this.data_fs_path
      });
    }
    return this._fs;
  }
  get data_fs_path() {
    if (!this._data_fs_path) {
      this._data_fs_path = (this.opts.env_path + (this.opts.env_path ? this.opts.env_path.includes("\\") ? "\\" : "/" : "") + this.env_data_dir).replace(/\\\\/g, "\\").replace(/\/\//g, "/");
    }
    return this._data_fs_path;
  }
  /**
   * Saves the current settings to the file system.
   * @param {Object|null} [settings=null] - Optional settings to override the current settings before saving.
   * @returns {Promise<void>}
   */
  async save_settings(settings) {
    this._saved = false;
    if (!await this.data_fs.exists("")) {
      await this.data_fs.mkdir("");
    }
    await this.data_fs.write("smart_env.json", JSON.stringify(settings, null, 2));
    this._saved = true;
  }
  /**
   * Loads settings from the file system, merging with any `default_settings` or `smart_env_settings`.
   * @returns {Promise<Object>} the loaded settings
   */
  async load_settings() {
    if (!await this.data_fs.exists("smart_env.json")) await this.save_settings({});
    let settings = JSON.parse(JSON.stringify(this.config.default_settings || {}));
    deep_merge(settings, JSON.parse(await this.data_fs.read("smart_env.json")));
    deep_merge(settings, this.opts?.smart_env_settings || {});
    this._saved = true;
    if (this.fs.auto_excluded_files) {
      const existing_file_exclusions = settings.file_exclusions.split(",").map((s) => s.trim()).filter(Boolean);
      settings.file_exclusions = [...existing_file_exclusions, ...this.fs.auto_excluded_files].filter((value, index, self) => self.indexOf(value) === index).join(",");
    }
    return settings;
  }
  /**
   * Refreshes file-system state if exclusions changed,
   * then re-renders relevant settings UI
   */
  async update_exclusions() {
    this.smart_sources._fs = null;
    await this.smart_sources.init_fs();
  }
  // DEPRECATED
  /** @deprecated access `this.state` and `collection.state` directly instead */
  get collections_loaded() {
    return this.state === "loaded";
  }
  /** @deprecated Use this['main_class_name'] instead of this.main/this.plugin */
  get main() {
    return this.smart_env_configs[this.mains[0]]?.main;
  }
  /**
   * @deprecated use component pattern instead
   */
  get ejs() {
    return this.opts.ejs;
  }
  /**
   * @deprecated use component pattern instead
   */
  get templates() {
    return this.opts.templates;
  }
  /**
   * @deprecated use component pattern instead
   */
  get views() {
    return this.opts.views;
  }
  /**
   * @deprecated use this.config instead
   */
  get opts() {
    return this.config;
  }
  /**
   * @deprecated Use this.main_class_name instead of this.plugin
   */
  get plugin() {
    return this.main;
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-file-system/utils/glob_to_regex.js
function create_regex(pattern, { case_sensitive, extended_glob, windows_paths }) {
  const regex_pattern = glob_to_regex_pattern(pattern, extended_glob);
  const adjusted_pattern = adjust_for_windows_paths(regex_pattern, windows_paths);
  const flags = case_sensitive ? "" : "i";
  return new RegExp(`^${adjusted_pattern}$`, flags);
}
function adjust_for_windows_paths(pattern, windows_paths) {
  return windows_paths ? pattern.replace(/\\\//g, "[\\\\/]").replace(/\\\\\\/g, "[\\\\/]") : pattern;
}
function glob_to_regex_pattern(pattern, extended_glob) {
  let in_class = false;
  let in_brace = 0;
  let result = "";
  for (let i = 0; i < pattern.length; i++) {
    const char = pattern[i];
    switch (char) {
      case "\\":
        if (i + 1 < pattern.length) {
          result += `\\${pattern[i + 1]}`;
          i++;
        } else {
          result += "\\\\";
        }
        break;
      case "/":
        result += "\\/";
        break;
      case "[":
        if (!in_class) {
          const closingIndex = pattern.indexOf("]", i + 1);
          if (closingIndex === -1) {
            result += "\\[";
          } else {
            in_class = true;
            if (pattern[i + 1] === "!") {
              result += "[^";
              i++;
            } else {
              result += "[";
            }
          }
        } else {
          result += "\\[";
        }
        break;
      case "]":
        if (in_class) {
          in_class = false;
          result += "]";
        } else {
          result += "\\]";
        }
        break;
      case "{":
        if (!in_class) {
          const closingIndex = pattern.indexOf("}", i + 1);
          if (closingIndex === -1) {
            result += "\\{";
          } else {
            in_brace++;
            result += "(";
          }
        } else {
          result += "\\{";
        }
        break;
      case "}":
        if (!in_class && in_brace > 0) {
          in_brace--;
          result += ")";
        } else {
          result += "\\}";
        }
        break;
      case ",":
        if (!in_class && in_brace > 0) {
          result += "|";
        } else {
          result += ",";
        }
        break;
      case "*":
        if (!in_class) {
          if (i + 1 < pattern.length && pattern[i + 1] === "*") {
            result += ".*";
            i++;
          } else {
            result += "[^/]*";
          }
        } else {
          result += "\\*";
        }
        break;
      case "?":
        if (!in_class) {
          result += "[^/]";
        } else {
          result += "\\?";
        }
        break;
      // We escape these to ensure they remain literal
      case "(":
      case ")":
      case "+":
      case "|":
      case "^":
      case "$":
      case ".":
        result += `\\${char}`;
        break;
      default:
        result += char;
        break;
    }
  }
  if (in_class) {
    result += "]";
    in_class = false;
  }
  if (extended_glob) {
    result = result.replace(/\\\+\\\((.*?)\\\)/g, "($1)+").replace(/\\\@\\\((.*?)\\\)/g, "($1)").replace(/\\\!\\\((.*?)\\\)/g, "(?!$1).*").replace(/\\\?\\\((.*?)\\\)/g, "($1)?").replace(/\\\*\\\((.*?)\\\)/g, "($1)*");
  }
  return result;
}
function glob_to_regex(pattern, options = {}) {
  const default_options = {
    case_sensitive: true,
    extended_glob: false,
    windows_paths: false
  };
  const merged_options = { ...default_options, ...options };
  if (pattern === "") {
    return /^$/;
  }
  if (pattern === "*" && !merged_options.windows_paths) {
    return /^[^/]+$/;
  }
  if (pattern === "**" && !merged_options.windows_paths) {
    return /^.+$/;
  }
  return create_regex(pattern, merged_options);
}

// node_modules/obsidian-smart-env/node_modules/smart-file-system/utils/fuzzy_search.js
function fuzzy_search(arr, search_term) {
  let matches = [];
  for (let i = 0; i < arr.length; i++) {
    const search_chars = search_term.toLowerCase().split("");
    let match = true;
    let distance = 0;
    const name = arr[i];
    const label_name = name.toLowerCase();
    for (let j = 0; j < search_chars.length; j++) {
      const search_index = label_name.substring(distance).indexOf(search_chars[j]);
      if (search_index >= 0) {
        distance += search_index + 1;
      } else {
        match = false;
        break;
      }
    }
    if (match) matches.push({ name, distance });
  }
  matches.sort((a, b) => a.distance - b.distance);
  return matches.map((match) => match.name);
}

// node_modules/obsidian-smart-env/node_modules/smart-file-system/smart_fs.js
var SmartFs = class {
  /**
   * Create a new SmartFs instance
   * 
   * @param {Object} env - The Smart Environment instance
   * @param {Object} [opts={}] - Optional configuration
   * @param {string} [opts.fs_path] - Custom environment path
   */
  constructor(env, opts = {}) {
    this.env = env;
    this.opts = opts;
    this.fs_path = opts.fs_path || opts.env_path || "";
    if (!opts.adapter) throw new Error("SmartFs requires an adapter");
    this.adapter = new opts.adapter(this);
    this.excluded_patterns = [];
    if (Array.isArray(opts.exclude_patterns)) {
      opts.exclude_patterns.forEach((pattern) => this.add_ignore_pattern(pattern));
    }
    this.folders = {};
    this.files = {};
    this.file_paths = [];
    this.folder_paths = [];
    this.auto_excluded_files = [];
  }
  async refresh() {
    this.files = {};
    this.file_paths = [];
    this.folders = {};
    this.folder_paths = [];
    await this.init();
  }
  async init() {
    await this.load_exclusions();
    await this.load_files();
  }
  async load_files() {
    const all = await this.list_recursive();
    this.file_paths = [];
    this.folder_paths = [];
    all.forEach((file) => {
      if (file.type === "file") {
        this.files[file.path] = file;
        this.file_paths.push(file.path);
      } else if (file.type === "folder") {
        this.folders[file.path] = file;
        this.folder_paths.push(file.path);
      }
    });
  }
  include_file(file_path) {
    const file = this.adapter.get_file(file_path);
    this.files[file.path] = file;
    this.file_paths.push(file.path);
    return file;
  }
  /**
   * Load .gitignore patterns
   * 
   * @returns {Promise<RegExp[]>} Array of RegExp patterns
   */
  async load_exclusions() {
    const gitignore_path = ".gitignore";
    const gitignore_exists = await this.adapter.exists(gitignore_path);
    if (gitignore_exists && !this.env.settings.skip_excluding_gitignore) {
      const gitignore_content = await this.adapter.read(gitignore_path, "utf-8");
      gitignore_content.split("\n").filter((line) => !line.startsWith("#")).filter(Boolean).forEach((pattern) => this.add_ignore_pattern(pattern));
    }
    this.add_ignore_pattern(".**");
    this.add_ignore_pattern("**/.**");
    this.add_ignore_pattern("**/.*/**");
    this.add_ignore_pattern("**/*.ajson");
  }
  /**
   * Add a new ignore pattern
   * 
   * @param {string} pattern - The pattern to add
   */
  add_ignore_pattern(pattern, opts = {}) {
    this.excluded_patterns.push(glob_to_regex(pattern.trim(), opts));
  }
  /**
   * Check if a path is ignored based on gitignore patterns
   * 
   * @param {string} _path - The path to check
   * @returns {boolean} True if the path is ignored, false otherwise
   */
  is_excluded(_path) {
    try {
      if (_path.includes("#")) return true;
      if (!this.excluded_patterns.length) return false;
      return this.excluded_patterns.some((pattern) => pattern.test(_path));
    } catch (e) {
      console.error(`Error checking if path is excluded: ${e.message}`);
      console.error(`Path: `, _path);
      throw e;
    }
  }
  /**
   * Check if any path in an array of paths is excluded
   * 
   * @param {string[]} paths - Array of paths to check
   * @returns {boolean} True if any path is excluded, false otherwise
   */
  has_excluded_patterns(paths) {
    return paths.some((p) => this.is_excluded(p));
  }
  /**
   * Pre-process an array of paths, throwing an error if any path is excluded
   * 
   * @param {string[]} paths - Array of paths to pre-process
   * @throws {Error} If any path in the array is excluded
   * @returns {string[]} The array of paths
   */
  pre_process(paths) {
    if (this.has_excluded_patterns(paths)) {
      throw new Error(`Path is excluded: ${paths.find((p) => this.is_excluded(p))}`);
    }
    return paths;
  }
  /**
   * Post-process the result of an operation
   * 
   * @param {any} returned_value - The value returned by the operation
   * @returns {any} The post-processed value
   */
  post_process(returned_value) {
    if (this.adapter.post_process) return this.adapter.post_process(returned_value);
    if (Array.isArray(returned_value)) {
      returned_value = returned_value.filter((r) => {
        if (typeof r === "string") return !this.is_excluded(r);
        if (typeof r === "object" && r.path) return !this.is_excluded(r.path);
        return true;
      });
    }
    return returned_value;
  }
  // v2
  /**
   * Use the adapter for a method
   * runs pre_process and post_process (checks exclusions)
   * @param {string} method - The method to use
   * @param {string[]} paths - The paths to use
   * @param {...any} args - Additional arguments for the method
   * @returns {Promise<any>} The result of the method
   */
  async use_adapter(method, paths, ...args) {
    if (!this.adapter[method]) throw new Error(`Method ${method} not found in adapter`);
    paths = this.pre_process(paths ?? []);
    let resp = await this.adapter[method](...paths, ...args);
    return this.post_process(resp);
  }
  /**
   * Append content to a file
   * 
   * @param {string} rel_path - The relative path of the file to append to
   * @param {string|Buffer} content - The content to append
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async append(rel_path, content) {
    return await this.use_adapter("append", [rel_path], content);
  }
  /**
   * Create a new directory
   * 
   * @param {string} rel_path - The relative path of the directory to create
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async mkdir(rel_path, opts = { recursive: true }) {
    return await this.use_adapter("mkdir", [rel_path], opts);
  }
  /**
   * Check if a file or directory exists
   * 
   * @param {string} rel_path - The relative path to check
   * @returns {Promise<boolean>} True if the path exists, false otherwise
   */
  async exists(rel_path) {
    return await this.use_adapter("exists", [rel_path]);
  }
  /**
   * List files in a directory
   * 
   * @param {string} rel_path - The relative path to list
   * @returns {Promise<string[]>} Array of file paths
   */
  async list(rel_path = "/") {
    return await this.use_adapter("list", [rel_path]);
  }
  async list_recursive(rel_path = "/") {
    return await this.use_adapter("list_recursive", [rel_path]);
  }
  async list_files(rel_path = "/") {
    return await this.use_adapter("list_files", [rel_path]);
  }
  async list_files_recursive(rel_path = "/") {
    return await this.use_adapter("list_files_recursive", [rel_path]);
  }
  async list_folders(rel_path = "/") {
    return await this.use_adapter("list_folders", [rel_path]);
  }
  async list_folders_recursive(rel_path = "/") {
    return await this.use_adapter("list_folders_recursive", [rel_path]);
  }
  /**
   * Read the contents of a file
   * 
   * @param {string} rel_path - The relative path of the file to read
   * @returns {Promise<string|Buffer>} The contents of the file
   */
  async read(rel_path, encoding = "utf-8") {
    try {
      const content = await this.adapter.read(rel_path, encoding);
      return content;
    } catch (error) {
      console.warn("Error during read: " + error.message, rel_path);
      if (error.code === "ENOENT") return null;
      return { error: error.message };
    }
  }
  /**
   * Remove a file
   * 
   * @param {string} rel_path - The relative path of the file to remove
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async remove(rel_path) {
    return await this.use_adapter("remove", [rel_path]);
  }
  /**
   * Remove a directory
   * 
   * @param {string} rel_path - The relative path of the directory to remove
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async remove_dir(rel_path, recursive = false) {
    return await this.use_adapter("remove_dir", [rel_path], recursive);
  }
  /**
   * Rename a file or directory
   * 
   * @param {string} rel_path - The current relative path
   * @param {string} new_rel_path - The new relative path
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async rename(rel_path, new_rel_path) {
    await this.use_adapter("rename", [rel_path, new_rel_path]);
    await this.refresh();
  }
  /**
   * Get file or directory statistics
   * 
   * @param {string} rel_path - The relative path to get statistics for
   * @returns {Promise<Object>} An object containing file or directory statistics
   */
  async stat(rel_path) {
    return await this.use_adapter("stat", [rel_path]);
  }
  /**
   * Write content to a file
   * Should handle when target path is within a folder that doesn't exist
   * 
   * @param {string} rel_path - The relative path of the file to write to
   * @param {string|Buffer} content - The content to write
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async write(rel_path, content) {
    try {
      await this.adapter.write(rel_path, content);
    } catch (error) {
      console.error("Error during write:", error);
      throw error;
    }
  }
  // // aliases
  // async create(rel_path, content) { return await this.use_adapter('write', [rel_path], content); }
  // async update(rel_path, content) { return await this.use_adapter('write', [rel_path], content); }
  get_link_target_path(link_target, source_path) {
    if (this.adapter.get_link_target_path) return this.adapter.get_link_target_path(link_target, source_path);
    if (!this.file_paths) return console.warn("get_link_target_path: file_paths not found");
    const matching_file_paths = this.file_paths.filter((path) => path.includes(link_target));
    return fuzzy_search(matching_file_paths, link_target)[0];
  }
  get sep() {
    return this.adapter.sep || "/";
  }
  get_full_path(rel_path = "") {
    return this.adapter.get_full_path(rel_path);
  }
  get base_path() {
    return this.adapter.get_base_path();
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-file-system/adapters/obsidian.js
var obsidian = __toESM(require("obsidian"), 1);
var SmartFsObsidianAdapter = class {
  /**
   * Create an SmartFsObsidianAdapter instance
   * 
   * @param {Object} smart_fs - The SmartFs instance
   */
  constructor(smart_fs) {
    this.smart_fs = smart_fs;
    this.obsidian = obsidian;
    this.obsidian_app = smart_fs.env.main.app;
    this.obsidian_adapter = smart_fs.env.main.app.vault.adapter;
  }
  get fs_path() {
    return this.smart_fs.fs_path;
  }
  get_file(file_path) {
    const file = {};
    file.path = file_path.replace(/\\/g, "/").replace(this.smart_fs.fs_path, "").replace(/^\//, "");
    file.type = "file";
    file.extension = file.path.split(".").pop().toLowerCase();
    file.name = file.path.split("/").pop();
    file.basename = file.name.split(".").shift();
    Object.defineProperty(file, "stat", {
      get: () => {
        const tfile = this.obsidian_app.vault.getAbstractFileByPath(file_path);
        if (tfile) {
          return {
            ctime: tfile.stat.ctime,
            mtime: tfile.stat.mtime,
            size: tfile.stat.size,
            isDirectory: () => tfile instanceof this.obsidian.TFolder,
            isFile: () => tfile instanceof this.obsidian.TFile
          };
        }
        return null;
      }
    });
    return file;
  }
  /**
   * Append content to a file
   * 
   * @param {string} rel_path - The relative path of the file to append to
   * @param {string} data - The content to append
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async append(rel_path, data) {
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    return await this.obsidian_adapter.append(rel_path, data);
  }
  /**
   * Create a new directory
   * 
   * @param {string} rel_path - The relative path of the directory to create
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async mkdir(rel_path) {
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    return await this.obsidian_adapter.mkdir(rel_path);
  }
  /**
   * Check if a file or directory exists
   * 
   * @param {string} rel_path - The relative path to check
   * @returns {Promise<boolean>} True if the path exists, false otherwise
   */
  async exists(rel_path) {
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    return await this.obsidian_adapter.exists(rel_path);
  }
  /**
   * List files in a directory (NOT up-to-date with list_recursive)
   * 
   * @param {string} rel_path - The relative path to list
   * @returns {Promise<string[]>} Array of file paths
   */
  async list(rel_path, opts = {}) {
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    if (rel_path.startsWith("/")) rel_path = rel_path.slice(1);
    if (rel_path.endsWith("/")) rel_path = rel_path.slice(0, -1);
    if (rel_path.includes(".")) {
      const { files: file_paths } = await this.obsidian_adapter.list(rel_path);
      const files2 = file_paths.map((file_path) => {
        if (this.smart_fs.fs_path) file_path = file_path.replace(this.smart_fs.fs_path, "").slice(1);
        const file_name = file_path.split("/").pop();
        const file = {
          basename: file_name.split(".")[0],
          extension: file_name.split(".").pop().toLowerCase(),
          name: file_name,
          path: file_path
        };
        return file;
      });
      return files2;
    }
    const files = this.obsidian_app.vault.getAllLoadedFiles().filter((file) => {
      const last_slash = file.path.lastIndexOf("/");
      if (last_slash === -1 && rel_path !== "") return false;
      const folder_path = file.path.slice(0, last_slash);
      if (folder_path !== rel_path) return false;
      return true;
    });
    return files;
  }
  // NOTE: currently does not handle hidden files and folders
  async list_recursive(rel_path, opts = {}) {
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    if (rel_path.startsWith("/")) rel_path = rel_path.slice(1);
    if (rel_path.endsWith("/")) rel_path = rel_path.slice(0, -1);
    const files = this.obsidian_app.vault.getAllLoadedFiles().filter((file) => {
      if (file.path.length > 200) {
        this.smart_fs.auto_excluded_files.push(file.path);
        return false;
      }
      if (rel_path !== "" && !file.path.startsWith(rel_path)) return false;
      if (file instanceof this.obsidian.TFile) {
        if (opts.type === "folder") return false;
        file.type = "file";
      } else if (file instanceof this.obsidian.TFolder) {
        if (opts.type === "file") return false;
        delete file.basename;
        delete file.extension;
        file.type = "folder";
      }
      if (this.smart_fs.fs_path) file.path = file.path.replace(this.smart_fs.fs_path, "").slice(1);
      return true;
    });
    return files;
  }
  async list_files(rel_path) {
    return await this.list(rel_path, { type: "file" });
  }
  async list_files_recursive(rel_path) {
    return await this.list_recursive(rel_path, { type: "file" });
  }
  async list_folders(rel_path) {
    return await this.list(rel_path, { type: "folder" });
  }
  async list_folders_recursive(rel_path) {
    return await this.list_recursive(rel_path, { type: "folder" });
  }
  /**
   * Read the contents of a file
   * 
   * @param {string} rel_path - The relative path of the file to read
   * @returns {Promise<string>} The contents of the file
   */
  async read(rel_path, encoding, opts = {}) {
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    if (encoding === "utf-8") {
      if (!opts.no_cache) {
        const tfile = this.obsidian_app.vault.getFileByPath(rel_path);
        if (tfile) return await this.obsidian_app.vault.cachedRead(tfile);
      }
      return await this.obsidian_adapter.read(rel_path);
    }
    if (encoding === "base64") {
      const array_buffer2 = await this.obsidian_adapter.readBinary(rel_path, "base64");
      const base642 = this.obsidian.arrayBufferToBase64(array_buffer2);
      return base642;
    }
    const array_buffer = await this.obsidian_adapter.readBinary(rel_path);
    return array_buffer;
  }
  /**
   * Rename a file or directory
   * 
   * @param {string} old_path - The current path of the file or directory
   * @param {string} new_path - The new path for the file or directory
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async rename(old_path, new_path) {
    if (!old_path.startsWith(this.fs_path)) old_path = this.fs_path + "/" + old_path;
    if (!new_path.startsWith(this.fs_path)) new_path = this.fs_path + "/" + new_path;
    return await this.obsidian_adapter.rename(old_path, new_path);
  }
  /**
   * Remove a file
   * 
   * @param {string} rel_path - The relative path of the file to remove
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async remove(rel_path) {
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    try {
      return await this.obsidian_adapter.remove(rel_path);
    } catch (error) {
      console.warn(`Error removing file: ${rel_path}`, error);
    }
  }
  /**
   * Remove a directory
   * 
   * @param {string} rel_path - The relative path of the directory to remove
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async remove_dir(rel_path, recursive = false) {
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    return await this.obsidian_adapter.rmdir(rel_path, recursive);
  }
  /**
   * Get file or directory information
   * 
   * @param {string} rel_path - The relative path of the file or directory
   * @returns {Promise<Object>} An object containing file or directory information
   */
  async stat(rel_path) {
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    return await this.obsidian_adapter.stat(rel_path);
  }
  /**
   * Write content to a file
   * 
   * @param {string} rel_path - The relative path of the file to write to
   * @param {string} data - The content to write
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async write(rel_path, data) {
    if (!data) data = "";
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    const folder_path = rel_path.split("/").slice(0, -1).join("/");
    if (!await this.exists(folder_path)) {
      await this.mkdir(folder_path);
      console.log(`Created folder: ${folder_path}`);
    }
    return await this.obsidian_adapter.write(rel_path, data);
  }
  get_link_target_path(link_path, file_path) {
    return this.obsidian_app.metadataCache.getFirstLinkpathDest(link_path, file_path)?.path;
  }
  get_base_path() {
    return this.obsidian_adapter.basePath;
  }
  get_full_path(rel_path = "") {
    const sep = rel_path.includes("/") ? "/" : "\\";
    return this.get_base_path() + sep + rel_path;
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-view/utils/empty.js
function empty(elm) {
  const range = document.createRange();
  range.selectNodeContents(elm);
  range.deleteContents();
}

// node_modules/obsidian-smart-env/node_modules/smart-view/utils/replace_html.js
var replace_html = /* @__PURE__ */ (() => {
  const cache = /* @__PURE__ */ new Map();
  return (container, html_snippet) => {
    const key = html_snippet.trim();
    let tpl = cache.get(key);
    if (!tpl) {
      tpl = document.createElement("template");
      tpl.innerHTML = key;
      cache.set(key, tpl);
    }
    container.replaceChildren(tpl.content.cloneNode(true));
  };
})();

// node_modules/obsidian-smart-env/node_modules/smart-view/utils/replace_with_fragment.js
var replace_with_fragment = (container, html_snippet) => {
  const range = document.createRange();
  const frag = range.createContextualFragment(html_snippet.trim());
  container.replaceChildren(frag);
};

// node_modules/obsidian-smart-env/node_modules/smart-view/utils/safe_inner_html.js
var restricted_re = /<(td|th|tr|thead|tbody|tfoot|caption|col|colgroup|option|optgroup|li|dt|dd|source|track)\b/i;
var safe_inner_html = (container, html_snippet) => {
  const trimmed = html_snippet.trim();
  (restricted_re.test(trimmed) ? replace_with_fragment : replace_html)(container, trimmed);
};

// node_modules/obsidian-smart-env/node_modules/smart-view/smart_view.js
var SmartView = class {
  /**
   * @constructor
   * @param {object} opts - Additional options or overrides for rendering.
   */
  constructor(opts = {}) {
    this.opts = opts;
    this._adapter = null;
  }
  /**
   * Renders all setting components within a container.
   * @async
   * @param {HTMLElement} container - The container element.
   * @param {Object} opts - Additional options for rendering.
   * @returns {Promise<void>}
   */
  async render_setting_components(container, opts = {}) {
    const components = container.querySelectorAll(".setting-component");
    const promises = [];
    for (const component of components) {
      promises.push(this.render_setting_component(component, opts));
    }
    await Promise.all(promises);
    return container;
  }
  /**
   * Creates a document fragment from HTML string.
   * @param {string} html - The HTML string.
   * @returns {DocumentFragment}
   */
  create_doc_fragment(html) {
    return document.createRange().createContextualFragment(html);
  }
  /**
   * Gets the adapter instance used for rendering (e.g., Obsidian or Node, etc.).
   * @returns {Object} The adapter instance.
   */
  get adapter() {
    if (!this._adapter) {
      if (!this.opts.adapter) {
        throw new Error("No adapter provided to SmartView. Provide a 'smart_view.adapter' in env config.");
      }
      const AdapterClass = this.opts.adapter;
      this._adapter = new AdapterClass(this);
    }
    return this._adapter;
  }
  /**
   * Gets an icon (implemented in the adapter).
   * @param {string} icon_name - Name of the icon to get.
   * @returns {string} The icon HTML string.
   */
  get_icon_html(icon_name) {
    return this.adapter.get_icon_html(icon_name);
  }
  /**
   * Renders a single setting component (implemented in adapter).
   * @async
   * @param {HTMLElement} setting_elm - The DOM element for the setting.
   * @param {Object} opts - Additional options for rendering.
   * @returns {Promise<*>}
   */
  async render_setting_component(setting_elm, opts = {}) {
    return await this.adapter.render_setting_component(setting_elm, opts);
  }
  /**
   * Renders markdown content (implemented in adapter).
   * @param {string} markdown - The markdown content.
   * @param {object|null} scope - The scope to pass for rendering.
   * @returns {Promise<DocumentFragment>}
   */
  async render_markdown(markdown, scope = null) {
    return await this.adapter.render_markdown(markdown, scope);
  }
  /**
   * Gets a value from an object by path.
   * @param {Object} obj - The object to search in.
   * @param {string} path - The path to the value.
   * @returns {*}
   */
  get_by_path(obj, path, settings_scope = null) {
    return get_by_path(obj, path, settings_scope);
  }
  /**
   * Sets a value in an object by path.
   * @param {Object} obj - The object to modify.
   * @param {string} path - The path to set the value.
   * @param {*} value - The value to set.
   */
  set_by_path(obj, path, value, settings_scope = null) {
    set_by_path(obj, path, value, settings_scope);
  }
  /**
   * Deletes a value from an object by path.
   * @param {Object} obj - The object to modify.
   * @param {string} path - The path to delete.
   */
  delete_by_path(obj, path, settings_scope = null) {
    delete_by_path(obj, path, settings_scope);
  }
  /**
   * Escapes HTML special characters in a string.
   * @param {string} str - The string to escape.
   * @returns {string} The escaped string.
   */
  escape_html(str) {
    if (typeof str !== "string") return str;
    return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  /**
   * A convenience method to build a setting HTML snippet from a config object.
   * @param {Object} setting_config
   * @returns {string}
   */
  render_setting_html(setting_config) {
    if (setting_config.type === "html") {
      return setting_config.value;
    }
    const attributes = Object.entries(setting_config).map(([attr, value]) => {
      if (attr.includes("class")) return "";
      if (typeof value === "number") return `data-${attr.replace(/_/g, "-")}=${value}`;
      return `data-${attr.replace(/_/g, "-")}="${value}"`;
    }).join("\n");
    return `<div class="setting-component${setting_config.scope_class ? " " + setting_config.scope_class : ""}"
data-setting="${setting_config.setting}"
${attributes}
></div>`;
  }
  /**
   * Renders settings from a config, returning a fragment.
   * @async
   * @param {Object} settings_config
   * @param {Object} opts
   * @returns {Promise<DocumentFragment>}
   */
  async render_settings(settings_config5, opts = {}) {
    const html = Object.entries(settings_config5).map(([setting_key, setting_config]) => {
      if (!setting_config.setting) {
        setting_config.setting = setting_key;
      }
      return this.render_setting_html(setting_config);
    }).join("\n");
    const frag = this.create_doc_fragment(`<div>${html}</div>`);
    return await this.render_setting_components(frag, opts);
  }
  /**
   * @function add_settings_listeners
   * @description
   * Scans the given container for elements that have `data-smart-setting` and attaches
   * a 'change' event listener. On change, it updates the corresponding path in `scope.settings`.
   * 
   * @param {Object} scope - An object containing a `settings` property, where new values will be stored.
   * @param {HTMLElement} [container=document] - The DOM element to scan. Defaults to the entire document.
   */
  add_settings_listeners(scope, container = document) {
    const elements = container.querySelectorAll("[data-smart-setting]");
    elements.forEach((elm) => {
      const path = elm.dataset.smartSetting;
      if (!path) return;
      if (!elm.dataset.listenerAttached) {
        elm.dataset.listenerAttached = "true";
        elm.addEventListener("change", () => {
          let newValue;
          if (elm instanceof HTMLInputElement) {
            if (elm.type === "checkbox") {
              newValue = elm.checked;
            } else if (elm.type === "radio") {
              if (elm.checked) {
                newValue = elm.value;
              } else {
                return;
              }
            } else {
              newValue = elm.value;
            }
          } else if (elm instanceof HTMLSelectElement || elm instanceof HTMLTextAreaElement) {
            newValue = elm.value;
          } else {
            newValue = elm.value ?? elm.textContent;
          }
          this.set_by_path(scope.settings, path, newValue);
        });
      }
    });
  }
  apply_style_sheet(sheet) {
    if ("adoptedStyleSheets" in Document.prototype) {
      document.adoptedStyleSheets = [...document.adoptedStyleSheets, sheet];
    } else {
      const styleEl = document.createElement("style");
      if (sheet.cssRules) {
        styleEl.textContent = Array.from(sheet.cssRules).map((rule) => rule.cssText).join("\n");
      }
      document.head.appendChild(styleEl);
    }
  }
  empty(elm) {
    empty(elm);
  }
  safe_inner_html(elm, html) {
    safe_inner_html(elm, html);
  }
};
function get_by_path(obj, path, settings_scope = null) {
  if (!path) return "";
  const keys = path.split(".");
  if (settings_scope) {
    keys.unshift(settings_scope);
  }
  const finalKey = keys.pop();
  const instance = keys.reduce((acc, key) => acc && acc[key], obj);
  if (instance && typeof instance[finalKey] === "function") {
    return instance[finalKey].bind(instance);
  }
  return instance ? instance[finalKey] : void 0;
}
function set_by_path(obj, path, value, settings_scope = null) {
  const keys = path.split(".");
  if (settings_scope) {
    keys.unshift(settings_scope);
  }
  const final_key = keys.pop();
  const target = keys.reduce((acc, key) => {
    if (!acc[key] || typeof acc[key] !== "object") {
      acc[key] = {};
    }
    return acc[key];
  }, obj);
  target[final_key] = value;
}
function delete_by_path(obj, path, settings_scope = null) {
  const keys = path.split(".");
  if (settings_scope) {
    keys.unshift(settings_scope);
  }
  const finalKey = keys.pop();
  const instance = keys.reduce((acc, key) => acc && acc[key], obj);
  if (instance) {
    delete instance[finalKey];
  }
}

// node_modules/obsidian-smart-env/node_modules/smart-view/adapters/_adapter.js
var SmartViewAdapter = class {
  constructor(main) {
    this.main = main;
  }
  // NECESSARY OVERRIDES
  /**
   * Retrieves the class used for settings.
   * Must be overridden by subclasses to return the appropriate setting class.
   * @abstract
   * @returns {Function} The setting class constructor.
   * @throws Will throw an error if not implemented in the subclass.
   */
  get setting_class() {
    throw new Error("setting_class() not implemented");
  }
  /**
   * Generates the HTML for a specified icon.
   * Must be overridden by subclasses to provide the correct icon HTML.
   * @abstract
   * @param {string} icon_name - The name of the icon to generate HTML for.
   * @returns {string} The HTML string representing the icon.
   * @throws Will throw an error if not implemented in the subclass.
   */
  get_icon_html(icon_name) {
    throw new Error("get_icon_html() not implemented");
  }
  /**
   * Renders Markdown content within a specific scope.
   * Must be overridden by subclasses to handle Markdown rendering appropriately.
   * @abstract
   * @param {string} markdown - The Markdown content to render.
   * @param {object|null} [scope=null] - The scope within which to render the Markdown.
   * @returns {Promise<void>} A promise that resolves when rendering is complete.
   * @throws Will throw an error if not implemented in the subclass.
   */
  async render_markdown(markdown, scope = null) {
    throw new Error("render_markdown() not implemented");
  }
  /**
   * Opens a specified URL.
   * Should be overridden by subclasses to define how URLs are opened.
   * @abstract
   * @param {string} url - The URL to open.
   */
  open_url(url) {
    throw new Error("open_url() not implemented");
  }
  /**
   * Handles the selection of a folder by invoking the folder selection dialog and updating the setting.
   * @abstract
   * @param {string} setting - The path of the setting being modified.
   * @param {string} value - The current value of the setting.
   * @param {HTMLElement} elm - The HTML element associated with the setting.
   * @param {object} scope - The current scope containing settings and actions.
   */
  handle_folder_select(path, value, elm, scope) {
    throw new Error("handle_folder_select not implemented");
  }
  /**
   * Handles the selection of a file by invoking the file selection dialog and updating the setting.
   * @abstract
   * @param {string} setting - The path of the setting being modified.
   * @param {string} value - The current value of the setting.
   * @param {HTMLElement} elm - The HTML element associated with the setting.
   * @param {object} scope - The current scope containing settings and actions.
   */
  handle_file_select(path, value, elm, scope) {
    throw new Error("handle_file_select not implemented");
  }
  /**
   * Performs actions before a setting is changed, such as clearing notices and updating the UI.
   * @abstract
   * @param {string} setting - The path of the setting being changed.
   * @param {*} value - The new value for the setting.
   * @param {HTMLElement} elm - The HTML element associated with the setting.
   * @param {object} scope - The current scope containing settings and actions.
   */
  pre_change(path, value, elm) {
  }
  /**
   * Performs actions after a setting is changed, such as updating UI elements.
   * @abstract
   * @param {string} setting - The path of the setting that was changed.
   * @param {*} value - The new value for the setting.
   * @param {HTMLElement} elm - The HTML element associated with the setting.
   * @param {object} changed - Additional information about the change.
   */
  post_change(path, value, elm) {
  }
  /**
   * Reverts a setting to its previous value in case of validation failure or error.
   * @abstract
   * @param {string} setting - The path of the setting to revert.
   * @param {HTMLElement} elm - The HTML element associated with the setting.
   * @param {object} scope - The current scope containing settings.
   */
  revert_setting(path, elm, scope) {
    console.warn("revert_setting() not implemented");
  }
  // DEFAULT IMPLEMENTATIONS (may be overridden)
  get setting_renderers() {
    return {
      text: this.render_text_component,
      string: this.render_text_component,
      password: this.render_password_component,
      number: this.render_number_component,
      dropdown: this.render_dropdown_component,
      toggle: this.render_toggle_component,
      textarea: this.render_textarea_component,
      textarea_array: this.render_textarea_array_component,
      button: this.render_button_component,
      remove: this.render_remove_component,
      folder: this.render_folder_select_component,
      "text-file": this.render_file_select_component,
      file: this.render_file_select_component,
      slider: this.render_slider_component,
      html: this.render_html_component,
      button_with_confirm: this.render_button_with_confirm_component
    };
  }
  async render_setting_component(elm, opts = {}) {
    this.empty(elm);
    const path = elm.dataset.setting;
    const scope = opts.scope || this.main.main;
    const settings_scope = opts.settings_scope || null;
    try {
      let value = elm.dataset.value ?? this.main.get_by_path(scope.settings, path, settings_scope);
      if (typeof value === "undefined" && typeof elm.dataset.default !== "undefined") {
        value = elm.dataset.default;
        if (typeof value === "string") value = value.toLowerCase() === "true" ? true : value === "false" ? false : value;
        this.main.set_by_path(scope.settings, path, value, settings_scope);
      }
      const renderer = this.setting_renderers[elm.dataset.type];
      if (!renderer) {
        console.warn(`Unsupported setting type: ${elm.dataset.type}`);
        return elm;
      }
      const setting = renderer.call(this, elm, path, value, scope, settings_scope);
      if (elm.dataset.name) setting.setName(elm.dataset.name);
      if (elm.dataset.description) {
        const frag = this.main.create_doc_fragment(`<span>${elm.dataset.description}</span>`);
        setting.setDesc(frag);
      }
      if (elm.dataset.tooltip) setting.setTooltip(elm.dataset.tooltip);
      this.add_button_if_needed(setting, elm, path, scope);
      this.handle_disabled_and_hidden(elm);
      return elm;
    } catch (e) {
      console.error(JSON.stringify({ path, elm }, null, 2));
      console.error(JSON.stringify(e, null, 2));
    }
  }
  render_dropdown_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    let options;
    if (elm.dataset.optionsCallback) {
      console.log(`getting options callback: ${elm.dataset.optionsCallback}`);
      const opts_callback = this.main.get_by_path(scope, elm.dataset.optionsCallback);
      if (typeof opts_callback === "function") options = opts_callback();
      else console.warn(`optionsCallback is not a function: ${elm.dataset.optionsCallback}`, scope);
    }
    if (!options || !options.length) {
      options = this.get_dropdown_options(elm);
    }
    smart_setting.addDropdown((dropdown) => {
      if (elm.dataset.required) dropdown.inputEl.setAttribute("required", true);
      options.forEach((option) => {
        const opt = dropdown.addOption(option.value, option.name ?? option.value);
        opt.selected = option.value === value;
      });
      dropdown.onChange((value2) => {
        this.handle_on_change(path, value2, elm, scope, settings_scope);
      });
      dropdown.setValue(value);
    });
    return smart_setting;
  }
  render_text_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addText((text) => {
      text.setPlaceholder(elm.dataset.placeholder || "");
      if (value) text.setValue(value);
      let debounceTimer;
      if (elm.dataset.button) {
        smart_setting.addButton((button) => {
          button.setButtonText(elm.dataset.button);
          button.onClick(async () => this.handle_on_change(path, text.getValue(), elm, scope));
        });
      } else {
        text.onChange(async (value2) => {
          clearTimeout(debounceTimer);
          debounceTimer = setTimeout(() => this.handle_on_change(path, value2.trim(), elm, scope, settings_scope), 2e3);
        });
      }
    });
    return smart_setting;
  }
  render_password_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addText((text) => {
      text.inputEl.type = "password";
      text.setPlaceholder(elm.dataset.placeholder || "");
      if (value) text.setValue(value);
      let debounceTimer;
      text.onChange(async (value2) => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => this.handle_on_change(path, value2, elm, scope, settings_scope), 2e3);
      });
    });
    return smart_setting;
  }
  render_number_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addText((number) => {
      number.inputEl.type = "number";
      number.setPlaceholder(elm.dataset.placeholder || "");
      if (typeof value !== "undefined") number.inputEl.value = parseInt(value);
      number.inputEl.min = elm.dataset.min || 0;
      if (elm.dataset.max) number.inputEl.max = elm.dataset.max;
      let debounceTimer;
      number.onChange(async (value2) => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => this.handle_on_change(path, parseInt(value2), elm, scope, settings_scope), 2e3);
      });
    });
    return smart_setting;
  }
  render_toggle_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addToggle((toggle) => {
      let checkbox_val = value ?? false;
      if (typeof checkbox_val === "string") {
        checkbox_val = checkbox_val.toLowerCase() === "true";
      }
      toggle.setValue(checkbox_val);
      toggle.onChange(async (value2) => this.handle_on_change(path, value2, elm, scope, settings_scope));
    });
    return smart_setting;
  }
  render_textarea_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addTextArea((textarea) => {
      textarea.setPlaceholder(elm.dataset.placeholder || "");
      textarea.setValue(value || "");
      let debounceTimer;
      textarea.onChange(async (value2) => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => this.handle_on_change(path, value2, elm, scope, settings_scope), 2e3);
      });
    });
    return smart_setting;
  }
  render_textarea_array_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addTextArea((textarea) => {
      textarea.setPlaceholder(elm.dataset.placeholder || "");
      textarea.setValue(Array.isArray(value) ? value.join("\n") : value || "");
      let debounceTimer;
      textarea.onChange(async (value2) => {
        value2 = value2.split("\n").map((v) => v.trim()).filter((v) => v);
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => this.handle_on_change(path, value2, elm, scope, settings_scope), 2e3);
      });
    });
    return smart_setting;
  }
  render_button_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addButton((button) => {
      button.setButtonText(elm.dataset.btnText || elm.dataset.name);
      button.onClick(async () => {
        if (elm.dataset.confirm && !confirm(elm.dataset.confirm)) return;
        if (elm.dataset.href) this.open_url(elm.dataset.href);
        if (elm.dataset.callback) {
          const callback = this.main.get_by_path(scope, elm.dataset.callback);
          if (callback) callback(path, value, elm, scope, settings_scope);
        }
      });
    });
    return smart_setting;
  }
  render_remove_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addButton((button) => {
      button.setButtonText(elm.dataset.btnText || elm.dataset.name || "Remove");
      button.onClick(async () => {
        this.main.delete_by_path(scope.settings, path, settings_scope);
        if (elm.dataset.callback) {
          const callback = this.main.get_by_path(scope, elm.dataset.callback);
          if (callback) callback(path, value, elm, scope, settings_scope);
        }
      });
    });
    return smart_setting;
  }
  render_folder_select_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addFolderSelect((folder_select) => {
      folder_select.setPlaceholder(elm.dataset.placeholder || "");
      if (value) folder_select.setValue(value);
      folder_select.inputEl.closest("div").addEventListener("click", () => {
        this.handle_folder_select(path, value, elm, scope);
      });
      folder_select.inputEl.querySelector("input").addEventListener("change", (e) => {
        const folder = e.target.value;
        this.handle_on_change(path, folder, elm, scope, settings_scope);
      });
    });
    return smart_setting;
  }
  render_file_select_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addFileSelect((file_select) => {
      file_select.setPlaceholder(elm.dataset.placeholder || "");
      if (value) file_select.setValue(value);
      file_select.inputEl.closest("div").addEventListener("click", () => {
        this.handle_file_select(path, value, elm, scope, settings_scope);
      });
    });
    return smart_setting;
  }
  render_slider_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addSlider((slider) => {
      const min = parseFloat(elm.dataset.min) || 0;
      const max = parseFloat(elm.dataset.max) || 100;
      const step = parseFloat(elm.dataset.step) || 1;
      const currentValue = typeof value !== "undefined" ? parseFloat(value) : min;
      slider.setLimits(min, max, step);
      slider.setValue(currentValue);
      slider.onChange((newVal) => {
        const numericVal = parseFloat(newVal);
        this.handle_on_change(path, numericVal, elm, scope, settings_scope);
      });
    });
    return smart_setting;
  }
  render_html_component(elm, path, value, scope) {
    this.safe_inner_html(elm, value);
    return elm;
  }
  add_button_if_needed(smart_setting, elm, path, scope) {
    if (elm.dataset.btn) {
      smart_setting.addButton((button) => {
        button.setButtonText(elm.dataset.btn);
        button.inputEl.addEventListener("click", (e) => {
          if (elm.dataset.btnCallback && typeof scope[elm.dataset.btnCallback] === "function") {
            if (elm.dataset.btnCallbackArg) scope[elm.dataset.btnCallback](elm.dataset.btnCallbackArg);
            else scope[elm.dataset.btnCallback](path, null, smart_setting, scope);
          } else if (elm.dataset.btnHref) {
            this.open_url(elm.dataset.btnHref);
          } else if (elm.dataset.callback && typeof this.main.get_by_path(scope, elm.dataset.callback) === "function") {
            this.main.get_by_path(scope, elm.dataset.callback)(path, null, smart_setting, scope);
          } else if (elm.dataset.href) {
            this.open_url(elm.dataset.href);
          } else {
            console.error("No callback or href found for button.");
          }
        });
        if (elm.dataset.btnDisabled || elm.dataset.disabled && elm.dataset.btnDisabled !== "false") {
          button.inputEl.disabled = true;
        }
      });
    }
  }
  handle_disabled_and_hidden(elm) {
    if (elm.dataset.disabled && elm.dataset.disabled !== "false") {
      elm.classList.add("disabled");
      elm.querySelector("input, select, textarea, button").disabled = true;
    }
    if (elm.dataset.hidden && elm.dataset.hidden !== "false") {
      elm.style.display = "none";
    }
  }
  get_dropdown_options(elm) {
    return Object.entries(elm.dataset).reduce((acc, [k, v]) => {
      if (!k.startsWith("option")) return acc;
      const [value, name] = v.split("|");
      acc.push({ value, name: name || value });
      return acc;
    }, []);
  }
  handle_on_change(path, value, elm, scope, settings_scope) {
    this.pre_change(path, value, elm, scope);
    if (elm.dataset.validate) {
      const valid = this[elm.dataset.validate](path, value, elm, scope);
      if (!valid) {
        elm.querySelector(".setting-item").style.border = "2px solid red";
        this.revert_setting(path, elm, scope);
        return;
      }
    }
    this.main.set_by_path(scope.settings, path, value, settings_scope);
    if (elm.dataset.callback) {
      const callback = this.main.get_by_path(scope, elm.dataset.callback);
      if (callback) callback(path, value, elm, scope);
    }
    this.post_change(path, value, elm, scope);
  }
  render_button_with_confirm_component(elm, path, value, scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addButton((button) => {
      button.setButtonText(elm.dataset.btnText || elm.dataset.name);
      elm.appendChild(this.main.create_doc_fragment(`
        <div class="sc-inline-confirm-row" style="
          display: none;
        ">
          <span style="margin-right: 10px;">
            ${elm.dataset.confirm || "Are you sure?"}
          </span>
          <span class="sc-inline-confirm-row-buttons">
            <button class="sc-inline-confirm-yes">Yes</button>
            <button class="sc-inline-confirm-cancel">Cancel</button>
          </span>
        </div>
      `));
      const confirm_row = elm.querySelector(".sc-inline-confirm-row");
      const confirm_yes = confirm_row.querySelector(".sc-inline-confirm-yes");
      const confirm_cancel = confirm_row.querySelector(".sc-inline-confirm-cancel");
      button.onClick(async () => {
        confirm_row.style.display = "block";
        elm.querySelector(".setting-item").style.display = "none";
      });
      confirm_yes.addEventListener("click", async () => {
        if (elm.dataset.href) this.open_url(elm.dataset.href);
        if (elm.dataset.callback) {
          const callback = this.main.get_by_path(scope, elm.dataset.callback);
          if (callback) callback(path, value, elm, scope);
        }
        elm.querySelector(".setting-item").style.display = "block";
        confirm_row.style.display = "none";
      });
      confirm_cancel.addEventListener("click", () => {
        confirm_row.style.display = "none";
        elm.querySelector(".setting-item").style.display = "block";
      });
    });
    return smart_setting;
  }
  empty(elm) {
    empty(elm);
  }
  safe_inner_html(elm, html) {
    safe_inner_html(elm, html);
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-view/adapters/obsidian.js
var import_obsidian = require("obsidian");
var SmartViewObsidianAdapter = class extends SmartViewAdapter {
  get setting_class() {
    return import_obsidian.Setting;
  }
  open_url(url) {
    window.open(url);
  }
  async render_file_select_component(elm, path, value) {
    return super.render_text_component(elm, path, value);
  }
  async render_markdown(markdown, scope) {
    const component = scope.env.smart_connections_plugin?.connections_view || new import_obsidian.Component();
    if (!scope) return console.warn("Scope required for rendering markdown in Obsidian adapter");
    const frag = this.main.create_doc_fragment("<div><div class='inner'></div></div>");
    const container = frag.querySelector(".inner");
    try {
      await import_obsidian.MarkdownRenderer.render(
        scope.env.plugin.app,
        markdown,
        container,
        scope?.file_path || "",
        component
      );
    } catch (e) {
      console.warn("Error rendering markdown in Obsidian adapter", e);
    }
    return frag;
  }
  get_icon_html(name) {
    return (0, import_obsidian.getIcon)(name).outerHTML;
  }
  // Obsidian Specific
  is_mod_event(event) {
    return import_obsidian.Keymap.isModEvent(event);
  }
  render_folder_select_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    const folders = scope.env.plugin.app.vault.getAllFolders().sort((a, b) => a.path.localeCompare(b.path));
    smart_setting.addDropdown((dropdown) => {
      if (elm.dataset.required) dropdown.inputEl.setAttribute("required", true);
      dropdown.addOption("", "No folder selected");
      folders.forEach((folder) => {
        dropdown.addOption(folder.path, folder.path);
      });
      dropdown.onChange((value2) => {
        this.handle_on_change(path, value2, elm, scope, settings_scope);
      });
      dropdown.setValue(value);
    });
    return smart_setting;
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-collections/utils/collection_instance_name_from.js
function collection_instance_name_from(class_name) {
  if (class_name.endsWith("Item")) {
    return class_name.replace(/Item$/, "").toLowerCase();
  }
  return class_name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase().replace(/y$/, "ie") + "s";
}

// node_modules/obsidian-smart-env/node_modules/smart-collections/utils/helpers.js
function create_uid(data) {
  const str = JSON.stringify(data);
  let hash = 0;
  if (str.length === 0) return hash;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
    if (hash < 0) hash = hash * -1;
  }
  return hash.toString() + str.length;
}
function deep_merge2(target, source2) {
  for (const key in source2) {
    if (source2.hasOwnProperty(key)) {
      if (is_obj(source2[key]) && is_obj(target[key])) deep_merge2(target[key], source2[key]);
      else target[key] = source2[key];
    }
  }
  return target;
  function is_obj(item) {
    return item && typeof item === "object" && !Array.isArray(item);
  }
}

// node_modules/obsidian-smart-env/node_modules/smart-collections/utils/deep_equal.js
function deep_equal(obj1, obj2, visited = /* @__PURE__ */ new WeakMap()) {
  if (obj1 === obj2) return true;
  if (obj1 === null || obj2 === null || obj1 === void 0 || obj2 === void 0) return false;
  if (typeof obj1 !== typeof obj2 || Array.isArray(obj1) !== Array.isArray(obj2)) return false;
  if (Array.isArray(obj1)) {
    if (obj1.length !== obj2.length) return false;
    return obj1.every((item, index) => deep_equal(item, obj2[index], visited));
  }
  if (typeof obj1 === "object") {
    if (visited.has(obj1)) return visited.get(obj1) === obj2;
    visited.set(obj1, obj2);
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length) return false;
    return keys1.every((key) => deep_equal(obj1[key], obj2[key], visited));
  }
  return obj1 === obj2;
}

// node_modules/obsidian-smart-env/node_modules/smart-collections/item.js
var CollectionItem = class _CollectionItem {
  /**
   * Default properties for an instance of CollectionItem.
   * Override in subclasses to define different defaults.
   * @returns {Object}
   */
  static get defaults() {
    return {
      data: {}
    };
  }
  /**
   * @param {Object} env - The environment/context.
   * @param {Object|null} [data=null] - Initial data for the item.
   */
  constructor(env, data = null) {
    env.create_env_getter(this);
    this.config = this.env?.config;
    this.merge_defaults();
    if (data) deep_merge2(this.data, data);
    if (!this.data.class_name) this.data.class_name = this.collection.item_class_name;
  }
  /**
   * Loads an item from data and initializes it.
   * @param {Object} env
   * @param {Object} data
   * @returns {CollectionItem}
   */
  static load(env, data) {
    const item = new this(env, data);
    item.init();
    return item;
  }
  /**
   * Merge default properties from the entire inheritance chain.
   * @private
   */
  merge_defaults() {
    let current_class = this.constructor;
    while (current_class) {
      for (let key in current_class.defaults) {
        const default_val = current_class.defaults[key];
        if (typeof default_val === "object") {
          this[key] = { ...default_val, ...this[key] };
        } else {
          this[key] = this[key] === void 0 ? default_val : this[key];
        }
      }
      current_class = Object.getPrototypeOf(current_class);
    }
  }
  /**
   * Generates or retrieves a unique key for the item.
   * Key syntax supports:
   * - `[i]` for sequences
   * - `/` for super-sources (groups, directories, clusters)
   * - `#` for sub-sources (blocks)
   * @returns {string} The unique key
   */
  get_key() {
    return create_uid(this.data);
  }
  /**
   * Updates the item data and returns true if changed.
   * @param {Object} data
   * @returns {boolean} True if data changed.
   */
  update_data(data) {
    const sanitized_data = this.sanitize_data(data);
    const current_data = { ...this.data };
    deep_merge2(current_data, sanitized_data);
    const changed = !deep_equal(this.data, current_data);
    if (!changed) return false;
    this.data = current_data;
    return true;
  }
  /**
   * Sanitizes data for saving. Ensures no circular references.
   * @param {*} data
   * @returns {*} Sanitized data.
   */
  sanitize_data(data) {
    if (data instanceof _CollectionItem) return data.ref;
    if (Array.isArray(data)) return data.map((val) => this.sanitize_data(val));
    if (typeof data === "object" && data !== null) {
      return Object.keys(data).reduce((acc, key) => {
        acc[key] = this.sanitize_data(data[key]);
        return acc;
      }, {});
    }
    return data;
  }
  /**
   * Initializes the item. Override as needed.
   * @param {Object} [input_data] - Additional data that might be provided on creation.
   */
  init(input_data) {
  }
  /**
   * Queues this item for saving.
   */
  queue_save() {
    this._queue_save = true;
  }
  /**
   * Saves this item using its data adapter.
   * @returns {Promise<void>}
   */
  async save() {
    try {
      await this.data_adapter.save_item(this);
      this.init();
    } catch (err) {
      this._queue_save = true;
      console.error(err, err.stack);
    }
  }
  /**
   * Queues this item for loading.
   */
  queue_load() {
    this._queue_load = true;
  }
  /**
   * Loads this item using its data adapter.
   * @returns {Promise<void>}
   */
  async load() {
    try {
      await this.data_adapter.load_item(this);
      this.init();
    } catch (err) {
      this._load_error = err;
      this.on_load_error(err);
    }
  }
  /**
   * Handles load errors by re-queuing for load.
   * Override if needed.
   * @param {Error} err
   */
  on_load_error(err) {
    this.queue_load();
  }
  /**
   * Validates the item before saving. Checks for presence and validity of key.
   * @returns {boolean}
   */
  validate_save() {
    if (!this.key) return false;
    if (this.key.trim() === "") return false;
    if (this.key === "undefined") return false;
    return true;
  }
  /**
   * Marks this item as deleted. This does not immediately remove it from memory,
   * but queues a save that will result in the item being removed from persistent storage.
   */
  delete() {
    this.deleted = true;
    this.queue_save();
  }
  /**
   * Filters items in the collection based on provided options.
   * functional filter (returns true or false) for filtering items in collection; called by collection class
   * @param {Object} filter_opts - Filtering options.
   * @param {string} [filter_opts.exclude_key] - A single key to exclude.
   * @param {string[]} [filter_opts.exclude_keys] - An array of keys to exclude. If exclude_key is provided, it's added to this array.
   * @param {string} [filter_opts.exclude_key_starts_with] - Exclude keys starting with this string.
   * @param {string[]} [filter_opts.exclude_key_starts_with_any] - Exclude keys starting with any of these strings.
   * @param {string} [filter_opts.exclude_key_includes] - Exclude keys that include this string.
   * @param {string[]} [filter_opts.exclude_key_includes_any] - Exclude keys that include any of these strings.
   * @param {string} [filter_opts.exclude_key_ends_with] - Exclude keys ending with this string.
   * @param {string[]} [filter_opts.exclude_key_ends_with_any] - Exclude keys ending with any of these strings.
   * @param {string} [filter_opts.key_ends_with] - Include only keys ending with this string.
   * @param {string} [filter_opts.key_starts_with] - Include only keys starting with this string.
   * @param {string[]} [filter_opts.key_starts_with_any] - Include only keys starting with any of these strings.
   * @param {string} [filter_opts.key_includes] - Include only keys that include this string.
   * @returns {boolean} True if the item passes the filter, false otherwise.
   */
  filter(filter_opts = {}) {
    const {
      exclude_key,
      exclude_keys = exclude_key ? [exclude_key] : [],
      exclude_key_starts_with,
      exclude_key_starts_with_any,
      exclude_key_includes,
      exclude_key_includes_any,
      exclude_key_ends_with,
      exclude_key_ends_with_any,
      key_ends_with,
      key_starts_with,
      key_starts_with_any,
      key_includes,
      key_includes_any
    } = filter_opts;
    if (exclude_keys?.includes(this.key)) return false;
    if (exclude_key_starts_with && this.key.startsWith(exclude_key_starts_with)) return false;
    if (exclude_key_starts_with_any && exclude_key_starts_with_any.some((prefix) => this.key.startsWith(prefix))) return false;
    if (exclude_key_includes && this.key.includes(exclude_key_includes)) return false;
    if (exclude_key_includes_any && exclude_key_includes_any.some((include) => this.key.includes(include))) return false;
    if (exclude_key_ends_with && this.key.endsWith(exclude_key_ends_with)) return false;
    if (exclude_key_ends_with_any && exclude_key_ends_with_any.some((suffix) => this.key.endsWith(suffix))) return false;
    if (key_ends_with && !this.key.endsWith(key_ends_with)) return false;
    if (key_starts_with && !this.key.startsWith(key_starts_with)) return false;
    if (key_starts_with_any && !key_starts_with_any.some((prefix) => this.key.startsWith(prefix))) return false;
    if (key_includes && !this.key.includes(key_includes)) return false;
    if (key_includes_any && !key_includes_any.some((include) => this.key.includes(include))) return false;
    return true;
  }
  /**
   * Parses item data for additional processing. Override as needed.
   */
  parse() {
  }
  get actions() {
    if (!this._actions) {
      this._actions = Object.entries(this.env.opts.items[this.item_type_key].actions || {}).reduce((acc, [k, v]) => {
        acc[k] = v.bind(this);
        return acc;
      }, {});
    }
    return this._actions;
  }
  /**
   * Derives the collection key from the class name.
   * @returns {string}
   */
  static get collection_key() {
    let name = this.name;
    if (name.match(/\d$/)) name = name.slice(0, -1);
    return collection_instance_name_from(name);
  }
  /**
   * @returns {string} The collection key for this item.
   */
  get collection_key() {
    let name = this.constructor.name;
    if (name.match(/\d$/)) name = name.slice(0, -1);
    return collection_instance_name_from(name);
  }
  /**
   * Retrieves the parent collection from the environment.
   * @returns {Collection}
   */
  get collection() {
    return this.env[this.collection_key];
  }
  /**
   * @returns {string} The item's key.
   */
  get key() {
    return this.data?.key || this.get_key();
  }
  get item_type_key() {
    let name = this.constructor.name;
    if (name.match(/\d$/)) name = name.slice(0, -1);
    return camel_case_to_snake_case2(name);
  }
  /**
   * A simple reference object for this item.
   * @returns {{collection_key: string, key: string}}
   */
  get ref() {
    return { collection_key: this.collection_key, key: this.key };
  }
  /**
   * @returns {Object} The data adapter for this item's collection.
   */
  get data_adapter() {
    return this.collection.data_adapter;
  }
  /**
   * @returns {Object} The filesystem adapter.
   */
  get data_fs() {
    return this.collection.data_fs;
  }
  /**
   * Access to collection-level settings.
   * @returns {Object}
   */
  get settings() {
    if (!this.env.settings[this.collection_key]) this.env.settings[this.collection_key] = {};
    return this.env.settings[this.collection_key];
  }
  set settings(settings) {
    this.env.settings[this.collection_key] = settings;
    this.env.smart_settings.save();
  }
  // /**
  //  * Render this item into a container using the item's component.
  //  * @deprecated 2024-12-02 Use explicit component pattern from environment
  //  * @param {HTMLElement} container
  //  * @param {Object} opts
  //  * @returns {Promise<HTMLElement>}
  //  */
  // async render_item(container, opts = {}) {
  //   const frag = await this.component.call(this.smart_view, this, opts);
  //   this.env.smart_view.empty(container);
  //   container.appendChild(frag);
  //   return container;
  // }
  /**
   * @deprecated use env.smart_view
   * @returns {Object}
   */
  get smart_view() {
    if (!this._smart_view) this._smart_view = this.env.init_module("smart_view");
    return this._smart_view;
  }
  // /**
  //  * Override in child classes to set the component for this item
  //  * @deprecated 2024-12-02
  //  * @returns {Function} The render function for this component
  //  */
  // get component() { return item_component; }
};
function camel_case_to_snake_case2(str) {
  const result = str.replace(/([A-Z])/g, (match) => `_${match.toLowerCase()}`).replace(/^_/, "").replace(/2$/, "");
  return result;
}

// node_modules/obsidian-smart-env/node_modules/smart-collections/collection.js
var AsyncFunction = Object.getPrototypeOf(async function() {
}).constructor;
var Collection = class {
  /**
   * Constructs a new Collection instance.
   *
   * @param {Object} env - The environment context containing configurations and adapters.
   * @param {Object} [opts={}] - Optional configuration.
   * @param {string} [opts.collection_key] - Custom key to override default collection name.
   * @param {string} [opts.data_dir] - Custom data directory path.
   * @param {boolean} [opts.prevent_load_on_init] - Whether to prevent loading items on initialization.
   */
  constructor(env, opts = {}) {
    env.create_env_getter(this);
    this.opts = opts;
    if (opts.collection_key) this.collection_key = opts.collection_key;
    this.env[this.collection_key] = this;
    this.config = this.env.config;
    this.items = {};
    this.loaded = null;
    this._loading = false;
    this.load_time_ms = null;
    this.settings_container = null;
  }
  /**
   * Initializes a new collection in the environment. Override in subclass if needed.
   *
   * @param {Object} env
   * @param {Object} [opts={}]
   * @returns {Promise<void>}
   */
  static async init(env, opts = {}) {
    env[this.collection_key] = new this(env, opts);
    await env[this.collection_key].init();
    env.collections[this.collection_key] = "init";
  }
  /**
   * The unique collection key derived from the class name.
   * @returns {string}
   */
  static get collection_key() {
    let name = this.name;
    if (name.match(/\d$/)) name = name.slice(0, -1);
    return name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
  }
  /**
   * Instance-level init. Override in subclasses if necessary.
   * @returns {Promise<void>}
   */
  async init() {
  }
  /**
   * Creates or updates an item in the collection.
   * - If `data` includes a key that matches an existing item, that item is updated.
   * - Otherwise, a new item is created.
   * After updating or creating, the item is validated. If validation fails, the item is logged and returned without being saved.
   * If validation succeeds for a new item, it is added to the collection and marked for saving.
   *
   * If the item’s `init()` method is async, a promise is returned that resolves once init completes.
   *
   * @param {Object} [data={}] - Data for creating/updating an item.
   * @returns {Promise<Item>|Item} The created or updated item. May return a promise if `init()` is async.
   */
  create_or_update(data = {}) {
    const existing_item = this.find_by(data);
    const item = existing_item ? existing_item : new this.item_type(this.env);
    item._queue_save = !existing_item;
    const data_changed = item.update_data(data);
    if (!existing_item && !item.validate_save()) {
      return item;
    }
    if (!existing_item) {
      this.set(item);
    }
    if (existing_item && !data_changed) return existing_item;
    if (item.init instanceof AsyncFunction) {
      return new Promise((resolve) => {
        item.init(data).then(() => resolve(item));
      });
    }
    item.init(data);
    return item;
  }
  /**
   * Finds an item by partial data match (first checks key). If `data.key` provided,
   * returns the item with that key; otherwise attempts a match by merging data.
   *
   * @param {Object} data - Data to match against.
   * @returns {Item|null}
   */
  find_by(data) {
    if (data.key) return this.get(data.key);
    const temp = new this.item_type(this.env);
    const temp_data = JSON.parse(JSON.stringify(data, temp.sanitize_data(data)));
    deep_merge2(temp.data, temp_data);
    return temp.key ? this.get(temp.key) : null;
  }
  /**
   * Filters items based on provided filter options or a custom function.
   *
   * @param {Object|Function} [filter_opts={}] - Filter options or a predicate function.
   * @returns {Item[]} Array of filtered items.
   */
  filter(filter_opts = {}) {
    if (typeof filter_opts === "function") {
      return Object.values(this.items).filter(filter_opts);
    }
    filter_opts = this.prepare_filter(filter_opts);
    const results = [];
    const { first_n } = filter_opts;
    for (const item of Object.values(this.items)) {
      if (first_n && results.length >= first_n) break;
      if (item.filter(filter_opts)) results.push(item);
    }
    return results;
  }
  /**
   * Alias for `filter()`
   * @param {Object|Function} filter_opts
   * @returns {Item[]}
   */
  list(filter_opts) {
    return this.filter(filter_opts);
  }
  /**
   * Prepares filter options. Can be overridden by subclasses to normalize filter options.
   *
   * @param {Object} filter_opts
   * @returns {Object} Prepared filter options.
   */
  prepare_filter(filter_opts) {
    return filter_opts;
  }
  /**
   * Retrieves an item by key.
   * @param {string} key
   * @returns {Item|undefined}
   */
  get(key) {
    return this.items[key];
  }
  /**
   * Retrieves multiple items by an array of keys.
   * @param {string[]} keys
   * @returns {Item[]}
   */
  get_many(keys = []) {
    if (!Array.isArray(keys)) {
      console.error("get_many called with non-array keys:", keys);
      return [];
    }
    return keys.map((key) => this.get(key)).filter(Boolean);
  }
  /**
   * Retrieves a random item from the collection, optionally filtered by options.
   * @param {Object} [opts]
   * @returns {Item|undefined}
   */
  get_rand(opts = null) {
    if (opts) {
      const filtered = this.filter(opts);
      return filtered[Math.floor(Math.random() * filtered.length)];
    }
    const keys = this.keys;
    return this.items[keys[Math.floor(Math.random() * keys.length)]];
  }
  /**
   * Adds or updates an item in the collection.
   * @param {Item} item
   */
  set(item) {
    if (!item.key) throw new Error("Item must have a key property");
    this.items[item.key] = item;
  }
  /**
   * Updates multiple items by their keys.
   * @param {string[]} keys
   * @param {Object} data
   */
  update_many(keys = [], data = {}) {
    this.get_many(keys).forEach((item) => item.update_data(data));
  }
  /**
   * Clears all items from the collection.
   */
  clear() {
    this.items = {};
  }
  /**
   * @returns {string} The collection key, can be overridden by opts.collection_key
   */
  get collection_key() {
    return this._collection_key ? this._collection_key : this.constructor.collection_key;
  }
  set collection_key(key) {
    this._collection_key = key;
  }
  /**
   * Lazily initializes and returns the data adapter instance for this collection.
   * @returns {Object} The data adapter instance.
   */
  get data_adapter() {
    if (!this._data_adapter) {
      const AdapterClass = this.get_adapter_class("data");
      this._data_adapter = new AdapterClass(this);
    }
    return this._data_adapter;
  }
  get_adapter_class(type) {
    const config = this.env.opts.collections?.[this.collection_key];
    const adapter_key = type + "_adapter";
    const adapter_module = config?.[adapter_key] ?? this.env.opts.collections?.smart_collections?.[adapter_key];
    if (typeof adapter_module === "function") return adapter_module;
    if (typeof adapter_module?.collection === "function") return adapter_module.collection;
    throw new Error(`No '${type}' adapter class found for ${this.collection_key} or smart_collections`);
  }
  /**
   * Data directory strategy for this collection. Defaults to 'multi'.
   * @returns {string}
   */
  get data_dir() {
    return this.collection_key;
  }
  /**
   * File system adapter from the environment.
   * @returns {Object}
   */
  get data_fs() {
    return this.env.data_fs;
  }
  /**
   * Derives the corresponding item class name based on this collection's class name.
   * @returns {string}
   */
  get item_class_name() {
    let name = this.constructor.name;
    if (name.match(/\d$/)) name = name.slice(0, -1);
    if (name.endsWith("ies")) return name.slice(0, -3) + "y";
    else if (name.endsWith("s")) return name.slice(0, -1);
    return name + "Item";
  }
  /**
   * Derives a readable item name from the item class name.
   * @returns {string}
   */
  get item_name() {
    return this.item_class_name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
  }
  /**
   * Retrieves the item type (constructor) from the environment.
   * @returns {Function} Item constructor.
   */
  get item_type() {
    if (this.opts.item_type) return this.opts.item_type;
    return this.env.item_types[this.item_class_name];
  }
  /**
   * Returns an array of all keys in the collection.
   * @returns {string[]}
   */
  get keys() {
    return Object.keys(this.items);
  }
  /**
   * @deprecated use data_adapter instead (2024-09-14)
   */
  get adapter() {
    return this.data_adapter;
  }
  /**
   * @method process_save_queue
   * @description 
   * Saves items flagged for saving (_queue_save) back to AJSON or SQLite. This ensures persistent storage 
   * of any updates made since last load/import. This method also writes changes to disk (AJSON files or DB).
   */
  async process_save_queue(opts = {}) {
    if (opts.force) {
      Object.values(this.items).forEach((item) => item._queue_save = true);
    }
    await this.data_adapter.process_save_queue(opts);
  }
  /**
   * @alias process_save_queue
   * @returns {Promise<void>}
   */
  async save(opts = {}) {
    await this.process_save_queue(opts);
  }
  /**
   * @method process_load_queue
   * @description 
   * Loads items that have been flagged for loading (_queue_load). This may involve 
   * reading from AJSON/SQLite or re-importing from markdown if needed. 
   * Called once initial environment is ready and collections are known.
   */
  async process_load_queue() {
    await this.data_adapter.process_load_queue();
  }
  /**
   * Retrieves processed settings configuration.
   * @returns {Object}
   */
  get settings_config() {
    return this.process_settings_config({});
  }
  /**
   * Processes given settings config, adding prefixes and handling conditionals.
   *
   * @private
   * @param {Object} _settings_config
   * @param {string} [prefix='']
   * @returns {Object}
   */
  process_settings_config(_settings_config, prefix = "") {
    const add_prefix = (key) => prefix && !key.includes(`${prefix}.`) ? `${prefix}.${key}` : key;
    return Object.entries(_settings_config).reduce((acc, [key, val]) => {
      let new_val = { ...val };
      if (new_val.conditional) {
        if (!new_val.conditional(this)) return acc;
        delete new_val.conditional;
      }
      if (new_val.callback) new_val.callback = add_prefix(new_val.callback);
      if (new_val.btn_callback) new_val.btn_callback = add_prefix(new_val.btn_callback);
      if (new_val.options_callback) new_val.options_callback = add_prefix(new_val.options_callback);
      const new_key = add_prefix(this.process_setting_key(key));
      acc[new_key] = new_val;
      return acc;
    }, {});
  }
  /**
   * Processes an individual setting key. Override if needed.
   * @param {string} key
   * @returns {string}
   */
  process_setting_key(key) {
    return key;
  }
  /**
   * Default settings for this collection. Override in subclasses as needed.
   * @returns {Object}
   */
  get default_settings() {
    return {};
  }
  /**
   * Current settings for the collection.
   * Initializes with default settings if none exist.
   * @returns {Object}
   */
  get settings() {
    if (!this.env.settings[this.collection_key]) {
      this.env.settings[this.collection_key] = this.default_settings;
    }
    return this.env.settings[this.collection_key];
  }
  /**
   * @deprecated use env.smart_view instead
   * @returns {Object} smart_view instance
   */
  get smart_view() {
    if (!this._smart_view) this._smart_view = this.env.init_module("smart_view");
    return this._smart_view;
  }
  /**
   * Renders the settings for the collection into a given container.
   * @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
   * @param {HTMLElement} [container=this.settings_container]
   * @param {Object} opts
   * @returns {Promise<HTMLElement>}
   */
  async render_settings(container = this.settings_container, opts = {}) {
    return await this.render_collection_settings(container, opts);
  }
  /**
   * Helper function to render collection settings.
   * @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
   * @param {HTMLElement} [container=this.settings_container]
   * @param {Object} opts
   * @returns {Promise<HTMLElement>}
   */
  async render_collection_settings(container = this.settings_container, opts = {}) {
    if (container && (!this.settings_container || this.settings_container !== container)) {
      this.settings_container = container;
    } else if (!container) {
      container = this.env.smart_view.create_doc_fragment("<div></div>");
    }
    this.env.smart_view.safe_inner_html(container, `<div class="sc-loading">Loading ${this.collection_key} settings...</div>`);
    const frag = await this.env.render_component("settings", this, opts);
    this.env.smart_view.empty(container);
    container.appendChild(frag);
    return container;
  }
  /**
   * Unloads collection data from memory.
   */
  unload() {
    this.clear();
    this.unloaded = true;
    this.env.collections[this.collection_key] = null;
  }
  // only show process notice if taking longer than 1 second
  show_process_notice(process2, opts = {}) {
    if (!this.debounce_process_notice) this.debounce_process_notice = {};
    this.debounce_process_notice[process2] = setTimeout(() => {
      this.debounce_process_notice[process2] = null;
      this.env.notices?.show(process2, { collection_key: this.collection_key, ...opts });
    }, 1e3);
  }
  clear_process_notice(process2) {
    if (this.debounce_process_notice?.[process2]) {
      clearTimeout(this.debounce_process_notice[process2]);
      this.debounce_process_notice[process2] = null;
    } else {
      this.env.notices?.remove(process2);
    }
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-entities/adapters/_adapter.js
var EntitiesVectorAdapter = class {
  /**
   * @constructor
   * @param {Object} collection - The collection (SmartEntities or derived class) instance.
   */
  constructor(collection) {
    this.collection = collection;
  }
  /**
   * Find the nearest entities to the given vector.
   * @async
   * @param {number[]} vec - The reference vector.
   * @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
   * @returns {Promise<Array<{item:Object, score:number}>>} Array of results sorted by score descending.
   * @throws {Error} Not implemented by default.
   */
  async nearest(vec, filter = {}) {
    throw new Error("EntitiesVectorAdapter.nearest() not implemented");
  }
  /**
   * Find the furthest entities from the given vector.
   * @async
   * @param {number[]} vec - The reference vector.
   * @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
   * @returns {Promise<Array<{item:Object, score:number}>>} Array of results sorted by score ascending (furthest).
   * @throws {Error} Not implemented by default.
   */
  async furthest(vec, filter = {}) {
    throw new Error("EntitiesVectorAdapter.furthest() not implemented");
  }
  /**
   * Embed a batch of entities.
   * @async
   * @param {Object[]} entities - Array of entity instances to embed.
   * @returns {Promise<void>}
   * @throws {Error} Not implemented by default.
   */
  async embed_batch(entities) {
    throw new Error("EntitiesVectorAdapter.embed_batch() not implemented");
  }
  /**
   * Process a queue of entities waiting to be embedded.
   * Typically, this will call embed_batch in batches and update entities.
   * @async
   * @param {Object[]} embed_queue - Array of entities to embed.
   * @returns {Promise<void>}
   * @throws {Error} Not implemented by default.
   */
  async process_embed_queue(embed_queue) {
    throw new Error("EntitiesVectorAdapter.process_embed_queue() not implemented");
  }
};
var EntityVectorAdapter = class {
  /**
   * @constructor
   * @param {Object} item - The SmartEntity instance that this adapter is associated with.
   */
  constructor(item) {
    this.item = item;
  }
  /**
   * Retrieve the current vector embedding for this entity.
   * @async
   * @returns {Promise<number[]|undefined>} The entity's vector or undefined if not set.
   * @throws {Error} Not implemented by default.
   */
  async get_vec() {
    throw new Error("EntityVectorAdapter.get_vec() not implemented");
  }
  /**
   * Store/update the vector embedding for this entity.
   * @async
   * @param {number[]} vec - The vector to set.
   * @returns {Promise<void>}
   * @throws {Error} Not implemented by default.
   */
  async set_vec(vec) {
    throw new Error("EntityVectorAdapter.set_vec() not implemented");
  }
  /**
   * Delete/remove the vector embedding for this entity.
   * @async
   * @returns {Promise<void>}
   * @throws {Error} Not implemented by default.
   */
  async delete_vec() {
    throw new Error("EntityVectorAdapter.delete_vec() not implemented");
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-entities/utils/cos_sim.js
function cos_sim(vector1, vector2) {
  if (vector1.length !== vector2.length) {
    throw new Error("Vectors must have the same length");
  }
  let dot_product = 0;
  let magnitude1 = 0;
  let magnitude2 = 0;
  const epsilon = 1e-8;
  for (let i = 0; i < vector1.length; i++) {
    dot_product += vector1[i] * vector2[i];
    magnitude1 += vector1[i] * vector1[i];
    magnitude2 += vector2[i] * vector2[i];
  }
  magnitude1 = Math.sqrt(magnitude1);
  magnitude2 = Math.sqrt(magnitude2);
  if (magnitude1 < epsilon || magnitude2 < epsilon) {
    return 0;
  }
  return dot_product / (magnitude1 * magnitude2);
}

// node_modules/obsidian-smart-env/node_modules/smart-entities/utils/results_acc.js
function results_acc(_acc, result, ct = 10) {
  if (_acc.results.size < ct) {
    _acc.results.add(result);
    if (_acc.results.size === ct && _acc.min === Number.POSITIVE_INFINITY) {
      let { minScore, minObj } = find_min(_acc.results);
      _acc.min = minScore;
      _acc.minResult = minObj;
    }
  } else if (result.score > _acc.min) {
    _acc.results.add(result);
    _acc.results.delete(_acc.minResult);
    let { minScore, minObj } = find_min(_acc.results);
    _acc.min = minScore;
    _acc.minResult = minObj;
  }
}
function furthest_acc(_acc, result, ct = 10) {
  if (_acc.results.size < ct) {
    _acc.results.add(result);
    if (_acc.results.size === ct && _acc.max === Number.NEGATIVE_INFINITY) {
      let { maxScore, maxObj } = find_max(_acc.results);
      _acc.max = maxScore;
      _acc.maxResult = maxObj;
    }
  } else if (result.score < _acc.max) {
    _acc.results.add(result);
    _acc.results.delete(_acc.maxResult);
    let { maxScore, maxObj } = find_max(_acc.results);
    _acc.max = maxScore;
    _acc.maxResult = maxObj;
  }
}
function find_min(results) {
  let minScore = Number.POSITIVE_INFINITY;
  let minObj = null;
  for (const obj of results) {
    if (obj.score < minScore) {
      minScore = obj.score;
      minObj = obj;
    }
  }
  return { minScore, minObj };
}
function find_max(results) {
  let maxScore = Number.NEGATIVE_INFINITY;
  let maxObj = null;
  for (const obj of results) {
    if (obj.score > maxScore) {
      maxScore = obj.score;
      maxObj = obj;
    }
  }
  return { maxScore, maxObj };
}

// node_modules/obsidian-smart-env/node_modules/smart-entities/utils/sort_by_score.js
function sort_by_score(a, b) {
  const epsilon = 1e-9;
  const score_diff = a.score - b.score;
  if (Math.abs(score_diff) < epsilon) return 0;
  return score_diff > 0 ? -1 : 1;
}
function sort_by_score_descending(a, b) {
  return sort_by_score(a, b);
}
function sort_by_score_ascending(a, b) {
  return sort_by_score(a, b) * -1;
}

// node_modules/obsidian-smart-env/node_modules/smart-entities/adapters/default.js
var DefaultEntitiesVectorAdapter = class extends EntitiesVectorAdapter {
  constructor(collection) {
    super(collection);
    this._is_processing_embed_queue = false;
    this._reset_embed_queue_stats();
  }
  /**
   * Find the nearest entities to the given vector.
   * @async
   * @param {number[]} vec - The reference vector.
   * @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
   * @returns {Promise<Array<{item:Object, score:number}>>} Array of results sorted by score descending.
   */
  async nearest(vec, filter = {}) {
    if (!vec || !Array.isArray(vec)) {
      throw new Error("Invalid vector input to nearest()");
    }
    const {
      limit = 50
      // TODO: default configured in settings
    } = filter;
    const nearest = this.collection.filter(filter).reduce((acc, item) => {
      if (!item.vec) return acc;
      const result = { item, score: cos_sim(vec, item.vec) };
      results_acc(acc, result, limit);
      return acc;
    }, { min: 0, results: /* @__PURE__ */ new Set() });
    return Array.from(nearest.results).sort(sort_by_score_descending);
  }
  /**
   * Find the furthest entities from the given vector.
   * @async
   * @param {number[]} vec - The reference vector.
   * @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
   * @returns {Promise<Array<{item:Object, score:number}>>} Array of results sorted by score ascending (furthest).
   */
  async furthest(vec, filter = {}) {
    if (!vec || !Array.isArray(vec)) {
      throw new Error("Invalid vector input to furthest()");
    }
    const {
      limit = 50
      // TODO: default configured in settings
    } = filter;
    const furthest = this.collection.filter(filter).reduce((acc, item) => {
      if (!item.vec) return acc;
      const result = { item, score: cos_sim(vec, item.vec) };
      furthest_acc(acc, result, limit);
      return acc;
    }, { max: 0, results: /* @__PURE__ */ new Set() });
    return Array.from(furthest.results).sort(sort_by_score_ascending);
  }
  /**
   * Embed a batch of entities.
   * @async
   * @param {Object[]} entities - Array of entity instances to embed.
   * @returns {Promise<void>}
   */
  async embed_batch(entities) {
    if (!this.collection.embed_model) {
      throw new Error("No embed_model found in collection for embedding");
    }
    await Promise.all(entities.map((e) => e.get_embed_input()));
    const embeddings = await this.collection.embed_model.embed_batch(entities);
    embeddings.forEach((emb, i) => {
      const entity = entities[i];
      entity.vec = emb.vec;
      entity.data.last_embed = entity.data.last_read;
      if (emb.tokens !== void 0) entity.tokens = emb.tokens;
    });
  }
  /**
   * Process a queue of entities waiting to be embedded.
   * Prevents multiple concurrent runs by using `_is_processing_embed_queue`.
   * @async
   * @returns {Promise<void>}
   */
  async process_embed_queue() {
    if (this._is_processing_embed_queue) {
      console.log("process_embed_queue is already running, skipping concurrent call.");
      return;
    }
    this._is_processing_embed_queue = true;
    try {
      if (!this.collection.embed_model.is_loaded) {
        await this.collection.embed_model.load();
      }
    } catch (e) {
      this.notices?.show("Failed to load embed_model");
      return;
    }
    try {
      const embed_queue = this.collection.embed_queue;
      this._reset_embed_queue_stats();
      if (this.collection.embed_model_key === "None") {
        console.log(`Smart Connections: No active embedding model for ${this.collection.collection_key}, skipping embedding`);
        return;
      }
      if (!this.collection.embed_model) {
        console.log(`Smart Connections: No active embedding model for ${this.collection.collection_key}, skipping embedding`);
        return;
      }
      const datetime_start = /* @__PURE__ */ new Date();
      if (!embed_queue.length) {
        console.log(`Smart Connections: No items in ${this.collection.collection_key} embed queue`);
        return;
      }
      console.log(`Time spent getting embed queue: ${(/* @__PURE__ */ new Date()).getTime() - datetime_start.getTime()}ms`);
      console.log(`Processing ${this.collection.collection_key} embed queue: ${embed_queue.length} items`);
      for (let i = 0; i < embed_queue.length; i += this.collection.embed_model.batch_size) {
        if (this.is_queue_halted) {
          this.is_queue_halted = false;
          break;
        }
        this._show_embed_progress_notice(embed_queue.length);
        const batch = embed_queue.slice(i, i + this.collection.embed_model.batch_size);
        await Promise.all(batch.map((item) => item.get_embed_input()));
        try {
          const start_time = Date.now();
          await this.embed_batch(batch);
          this.total_time += Date.now() - start_time;
        } catch (e) {
          if (e && e.message && e.message.includes("API key not set")) {
            this.halt_embed_queue_processing(`API key not set for ${this.collection.embed_model_key}
Please set the API key in the settings.`);
          }
          console.error(e);
          console.error(`Error processing ${this.collection.collection_key} embed queue: ` + JSON.stringify(e || {}, null, 2));
        }
        batch.forEach((item) => {
          item.embed_hash = item.read_hash;
          item._queue_save = true;
        });
        this.embedded_total += batch.length;
        this.total_tokens += batch.reduce((acc, item) => acc + (item.tokens || 0), 0);
        if (this.embedded_total - this.last_save_total > 1e3) {
          this.last_save_total = this.embedded_total;
          await this.collection.process_save_queue();
          if (this.collection.block_collection) {
            console.log(`Saving ${this.collection.block_collection.collection_key} block collection`);
            await this.collection.block_collection.process_save_queue();
          }
        }
      }
      this._show_embed_completion_notice(embed_queue.length);
      await this.collection.process_save_queue();
      if (this.collection.block_collection) {
        await this.collection.block_collection.process_save_queue();
      }
    } finally {
      this._is_processing_embed_queue = false;
    }
  }
  get should_show_embed_progress_notice() {
    if (Date.now() - (this.last_notice_time ?? 0) > 3e4) {
      return true;
    }
    return this.embedded_total - this.last_notice_embedded_total >= 100;
  }
  /**
   * Displays the embedding progress notice.
   * @private
   * @returns {void}
   */
  _show_embed_progress_notice(embed_queue_length) {
    if (!this.should_show_embed_progress_notice) return;
    this.last_notice_time = Date.now();
    this.last_notice_embedded_total = this.embedded_total;
    this.notices?.show("embedding_progress", {
      progress: this.embedded_total,
      total: embed_queue_length,
      tokens_per_second: this._calculate_embed_tokens_per_second(),
      model_name: this.collection.embed_model_key
    });
  }
  /**
   * Displays the embedding completion notice.
   * @private
   * @returns {void}
   */
  _show_embed_completion_notice() {
    this.notices?.remove("embedding_progress");
    this.notices?.show("embedding_complete", {
      total_embeddings: this.embedded_total,
      tokens_per_second: this._calculate_embed_tokens_per_second(),
      model_name: this.collection.embed_model_key
    });
  }
  /**
   * Halts the embed queue processing.
   * @param {string|null} msg - Optional message.
   */
  halt_embed_queue_processing(msg = null) {
    this.is_queue_halted = true;
    console.log("Embed queue processing halted");
    this.notices?.remove("embedding_progress");
    this.notices?.show("embedding_paused", {
      progress: this.embedded_total,
      total: this.collection._embed_queue.length,
      tokens_per_second: this._calculate_embed_tokens_per_second(),
      model_name: this.collection.embed_model_key
    });
  }
  /**
   * Resumes the embed queue processing after a delay.
   * @param {number} [delay=0] - The delay in milliseconds before resuming.
   * @returns {void}
   */
  resume_embed_queue_processing(delay = 0) {
    console.log("resume_embed_queue_processing");
    this.notices?.remove("embedding_paused");
    setTimeout(() => {
      this.embedded_total = 0;
      this.process_embed_queue();
    }, delay);
  }
  /**
   * Calculates the number of tokens processed per second.
   * @private
   * @returns {number} Tokens per second.
   */
  _calculate_embed_tokens_per_second() {
    const elapsed_time = this.total_time / 1e3;
    return Math.round(this.total_tokens / (elapsed_time || 1));
  }
  /**
   * Resets the statistics related to embed queue processing.
   * @private
   * @returns {void}
   */
  _reset_embed_queue_stats() {
    this.collection._embed_queue = [];
    this.embedded_total = 0;
    this.is_queue_halted = false;
    this.last_save_total = 0;
    this.last_notice_embedded_total = 0;
    this.total_tokens = 0;
    this.total_time = 0;
  }
  get notices() {
    return this.collection.notices;
  }
};
var DefaultEntityVectorAdapter = class extends EntityVectorAdapter {
  get data() {
    return this.item.data;
  }
  /**
   * Retrieve the current vector embedding for this entity.
   * @async
   * @returns {Promise<number[]|undefined>} The entity's vector or undefined if not set.
   */
  async get_vec() {
    return this.vec;
  }
  /**
   * Store/update the vector embedding for this entity.
   * @async
   * @param {number[]} vec - The vector to set.
   * @returns {Promise<void>}
   */
  async set_vec(vec) {
    this.vec = vec;
  }
  /**
   * Delete/remove the vector embedding for this entity.
   * @async
   * @returns {Promise<void>}
   */
  async delete_vec() {
    if (this.item.data?.embeddings?.[this.item.embed_model_key]) {
      delete this.item.data.embeddings[this.item.embed_model_key].vec;
    }
  }
  // adds synchronous get/set for vec
  get vec() {
    return this.item.data?.embeddings?.[this.item.embed_model_key]?.vec;
  }
  set vec(vec) {
    if (!this.item.data.embeddings) {
      this.item.data.embeddings = {};
    }
    if (!this.item.data.embeddings[this.item.embed_model_key]) {
      this.item.data.embeddings[this.item.embed_model_key] = {};
    }
    this.item.data.embeddings[this.item.embed_model_key].vec = vec;
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-entities/actions/find_connections.js
async function find_connections(params = {}) {
  const filter_opts = this.prepare_find_connections_filter_opts(params);
  const limit = params.filter?.limit || params.limit || this.env.settings.smart_view_filter?.results_limit || 10;
  const cache_key = this.key + JSON.stringify(params);
  if (!this.env.connections_cache) this.env.connections_cache = {};
  if (!this.env.connections_cache[cache_key]) {
    const connections = (await this.nearest(filter_opts)).sort(sort_by_score).slice(0, limit);
    this.connections_to_cache(cache_key, connections);
  }
  return this.connections_from_cache(cache_key);
}

// node_modules/obsidian-smart-env/node_modules/smart-entities/smart_entity.js
var SmartEntity = class extends CollectionItem {
  /**
   * Creates an instance of SmartEntity.
   * @constructor
   * @param {Object} env - The environment instance.
   * @param {Object} [opts={}] - Configuration options.
   */
  constructor(env, opts = {}) {
    super(env, opts);
    this.entity_adapter = new DefaultEntityVectorAdapter(this);
  }
  /**
   * Provides default values for a SmartEntity instance.
   * @static
   * @readonly
   * @returns {Object} The default values.
   */
  static get defaults() {
    return {
      data: {
        path: null,
        last_embed: {
          hash: null
        },
        embeddings: {}
      }
    };
  }
  get vector_adapter() {
    if (!this._vector_adapter) {
      this._vector_adapter = new this.collection.opts.vector_adapter.item(this);
    }
    return this._vector_adapter;
  }
  /**
   * Initializes the SmartEntity instance.
   * Checks if the entity has a vector and if it matches the model dimensions.
   * If not, it queues an embed.
   * Removes embeddings for inactive models.
   * @returns {void}
   */
  init() {
    super.init();
    if (!this.vec || !this.vec.length) {
      this.vec = null;
      this.queue_embed();
    }
    Object.entries(this.data.embeddings || {}).forEach(([model, embedding]) => {
      if (model !== this.embed_model_key) {
        this.data.embeddings[model] = null;
        delete this.data.embeddings[model];
      }
    });
  }
  /**
   * Queues the entity for embedding.
   * @returns {void}
   */
  queue_embed() {
    this._queue_embed = true;
  }
  /**
   * Finds the nearest entities to this entity.
   * @param {Object} [filter={}] - Optional filters to apply.
   * @returns {Array<{item:Object, score:number}>} An array of result objects with score and item.
   */
  async nearest(filter = {}) {
    return await this.collection.nearest_to(this, filter);
  }
  /**
   * Prepares the input for embedding.
   * @async
   * @param {string} [content=null] - Optional content to use instead of calling subsequent read()
   * @returns {Promise<void>} Should be overridden in child classes.
   */
  async get_embed_input(content = null) {
  }
  // override in child class
  /**
   * Retrieves the embed input, either from cache or by generating it.
   * @readonly
   * @returns {string|Promise<string>} The embed input string or a promise resolving to it.
   */
  get embed_input() {
    return this._embed_input ? this._embed_input : this.get_embed_input();
  }
  /**
   * Prepares filter options for finding connections based on parameters.
   * @param {Object} [params={}] - Parameters for finding connections.
   * @returns {Object} The prepared filter options.
   */
  prepare_find_connections_filter_opts(params = {}) {
    const opts = {
      ...this.env.settings.smart_view_filter || {},
      ...params,
      entity: this
    };
    if (opts.filter?.limit) delete opts.filter.limit;
    if (opts.limit) delete opts.limit;
    return opts;
  }
  /**
   * Finds connections relevant to this entity based on provided parameters.
   * @async
   * @param {Object} [params={}] - Parameters for finding connections.
   * @returns {Array<{item:Object, score:number}>} An array of result objects with score and item.
   */
  async find_connections(params = {}) {
    return await this.actions.find_connections(params);
  }
  /**
   * Retrieves connections from the cache based on the cache key.
   * @param {string} cache_key - The cache key.
   * @returns {Array<{item:Object, score:number}>} The cached connections.
   */
  connections_from_cache(cache_key) {
    return this.env.connections_cache[cache_key];
  }
  /**
   * Stores connections in the cache with the provided cache key.
   * @param {string} cache_key - The cache key.
   * @param {Array<{item:Object, score:number}>} connections - The connections to cache.
   * @returns {void}
   */
  connections_to_cache(cache_key, connections) {
    this.env.connections_cache[cache_key] = connections;
  }
  get read_hash() {
    return this.data.last_read?.hash;
  }
  set read_hash(hash) {
    if (!this.data.last_read) this.data.last_read = {};
    this.data.last_read.hash = hash;
  }
  get embedding_data() {
    if (!this.data.embeddings[this.embed_model_key]) {
      this.data.embeddings[this.embed_model_key] = {};
    }
    return this.data.embeddings[this.embed_model_key];
  }
  get last_embed() {
    if (!this.embedding_data.last_embed) {
      this.embedding_data.last_embed = {};
      if (this.data.last_embed) {
        this.embedding_data.last_embed = this.data.last_embed;
        delete this.data.last_embed;
        this.queue_save();
      }
    }
    return this.embedding_data.last_embed;
  }
  get embed_hash() {
    return this.last_embed?.hash;
  }
  set embed_hash(hash) {
    if (!this.embedding_data.last_embed) this.embedding_data.last_embed = {};
    this.embedding_data.last_embed.hash = hash;
  }
  /**
   * Gets the embed link for the entity.
   * @readonly
   * @returns {string} The embed link.
   */
  get embed_link() {
    return `![[${this.path}]]`;
  }
  /**
   * Gets the key of the embedding model.
   * @readonly
   * @returns {string} The embedding model key.
   */
  get embed_model_key() {
    return this.collection.embed_model_key;
  }
  /**
   * Gets the name of the entity, formatted based on settings.
   * @readonly
   * @returns {string} The entity name.
   */
  get name() {
    return (!this.should_show_full_path ? this.path.split("/").pop() : this.path.split("/").join(" > ")).split("#").join(" > ").replace(".md", "");
  }
  /**
   * Determines whether to show the full path of the entity.
   * @readonly
   * @returns {boolean} True if the full path should be shown, false otherwise.
   */
  get should_show_full_path() {
    return this.env.settings.smart_view_filter?.show_full_path;
  }
  /**
   * @deprecated Use embed_model instead.
   * @readonly
   * @returns {Object} The smart embedding model.
   */
  get smart_embed() {
    return this.embed_model;
  }
  /**
   * Gets the embedding model instance from the collection.
   * @readonly
   * @returns {Object} The embedding model instance.
   */
  get embed_model() {
    return this.collection.embed_model;
  }
  /**
   * Determines if the entity should be embedded if unembedded. NOT the same as is_unembedded.
   * @readonly
   * @returns {boolean} True if no vector is set, false otherwise.
   */
  get should_embed() {
    return this.size > (this.settings?.min_chars || 300);
  }
  /**
   * Sets the error for the embedding model.
   * @param {string} error - The error message.
   */
  set error(error) {
    this.data.embeddings[this.embed_model_key].error = error;
  }
  /**
   * Gets the number of tokens associated with the entity's embedding.
   * @readonly
   * @returns {number|undefined} The number of tokens, or undefined if not set.
   */
  get tokens() {
    return this.last_embed?.tokens;
  }
  /**
   * Sets the number of tokens for the embedding.
   * @param {number} tokens - The number of tokens.
   */
  set tokens(tokens) {
    this.last_embed.tokens = tokens;
  }
  /**
   * Gets the vector representation from the entity adapter.
   * @readonly
   * @returns {Array<number>|undefined} The vector or undefined if not set.
   */
  get vec() {
    return this.entity_adapter.vec;
  }
  /**
   * Sets the vector representation in the entity adapter.
   * @param {Array<number>} vec - The vector to set.
   */
  set vec(vec) {
    this.entity_adapter.vec = vec;
    this._queue_embed = false;
    this._embed_input = null;
    this.queue_save();
  }
  /**
   * Removes all embeddings from the entity.
   * @returns {void}
   */
  remove_embeddings() {
    this.data.embeddings = null;
    this.queue_save();
  }
  /**
   * Retrieves the key of the entity.
   * @returns {string} The entity key.
   */
  get_key() {
    return this.data.key || this.data.path;
  }
  /**
   * Retrieves the path of the entity.
   * @readonly
   * @returns {string|null} The entity path.
   */
  get path() {
    return this.data.path;
  }
  get is_unembedded() {
    if (!this.vec) return true;
    if (!this.embed_hash || this.embed_hash !== this.read_hash) return true;
    return false;
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-entities/smart_entities.js
var SmartEntities = class extends Collection {
  /**
   * Creates an instance of SmartEntities.
   * @constructor
   * @param {Object} env - The environment instance.
   * @param {Object} opts - Configuration options.
   */
  constructor(env, opts) {
    super(env, opts);
    this.entities_vector_adapter = new DefaultEntitiesVectorAdapter(this);
    this.model_instance_id = null;
    this._embed_queue = [];
  }
  /**
   * Initializes the SmartEntities instance by loading embeddings.
   * @async
   * @returns {Promise<void>}
   */
  async init() {
    await super.init();
    await this.load_smart_embed();
    if (!this.embed_model) {
      console.log(`SmartEmbed not loaded for **${this.collection_key}**. Continuing without embedding capabilities.`);
    }
  }
  /**
   * Loads the smart embedding model.
   * @async
   * @returns {Promise<void>}
   */
  async load_smart_embed() {
    if (this.embed_model_key === "None") return;
    if (!this.embed_model) return;
    if (this.embed_model.is_loading) return console.log(`SmartEmbedModel already loading for ${this.embed_model_key}`);
    if (this.embed_model.is_loaded) return console.log(`SmartEmbedModel already loaded for ${this.embed_model_key}`);
    try {
      console.log(`Loading SmartEmbedModel in ${this.collection_key}, current state: ${this.embed_model.state}`);
      await this.embed_model.load();
    } catch (e) {
      console.error(`Error loading SmartEmbedModel for ${this.embed_model.model_key}`);
      console.error(e);
    }
  }
  /**
   * Unloads the smart embedding model.
   * @async
   * @returns {Promise<void>}
   */
  async unload() {
    if (typeof this.embed_model?.unload === "function") {
      this.embed_model.unload();
    }
    super.unload();
  }
  /**
   * Gets the key of the embedding model.
   * @readonly
   * @returns {string} The embedding model key.
   */
  get embed_model_key() {
    return this.embed_model?.model_key;
  }
  /**
   * Gets or creates the container for smart embeddings in the DOM.
   * @readonly
   * @returns {HTMLElement|undefined} The container element or undefined if not available.
   */
  get smart_embed_container() {
    if (!this.model_instance_id) return console.log("model_key not set");
    const id = this.model_instance_id.replace(/[^a-zA-Z0-9]/g, "_");
    if (!window.document) return console.log("window.document not available");
    if (window.document.querySelector(`#${id}`)) return window.document.querySelector(`#${id}`);
    const container = window.document.createElement("div");
    container.id = id;
    window.document.body.appendChild(container);
    return container;
  }
  /**
   * @deprecated Use embed_model instead.
   * @readonly
   * @returns {Object} The smart embedding model.
   */
  get smart_embed() {
    return this.embed_model;
  }
  /**
   * Gets the embedding model instance.
   * @readonly
   * @returns {Object|null} The embedding model instance or null if none.
   */
  get embed_model() {
    if (!this.env._embed_model && this.env.opts.modules.smart_embed_model?.class) this.env._embed_model = new this.env.opts.modules.smart_embed_model.class({
      settings: this.settings.embed_model,
      adapters: this.env.opts.modules.smart_embed_model?.adapters,
      re_render_settings: () => this.env.render_component("collection_settings", this, { settings_container: this.settings_container }),
      reload_model: this.reload_embed_model.bind(this)
    });
    return this.env._embed_model;
  }
  set embed_model(embed_model) {
    this.env._embed_model = embed_model;
  }
  reload_embed_model() {
    console.log("reload_embed_model");
    this.embed_model.unload();
    this.env._embed_model = null;
  }
  /**
   * Finds the nearest entities to a given entity.
   * @async
   * @param {Object} entity - The reference entity.
   * @param {Object} [filter={}] - Optional filters to apply.
   * @returns {Promise<Array<{item:Object, score:number}>>} An array of result objects with score and item.
   */
  async nearest_to(entity, filter = {}) {
    return await this.nearest(entity.vec, filter);
  }
  /**
   * Finds the nearest entities to a vector using the default adapter.
   * @async
   * @param {Array<number>} vec - The vector to compare against.
   * @param {Object} [filter={}] - Optional filters to apply.
   * @returns {Promise<Array<{item:Object, score:number}>>} An array of result objects with score and item.
   */
  async nearest(vec, filter = {}) {
    if (!vec) {
      console.warn("nearest: no vec");
      return [];
    }
    return await this.entities_vector_adapter.nearest(vec, filter);
  }
  /**
   * Finds the furthest entities from a vector using the default adapter.
   * @async
   * @param {Array<number>} vec - The vector to compare against.
   * @param {Object} [filter={}] - Optional filters to apply.
   * @returns {Promise<Array<{item:Object, score:number}>>} An array of result objects with score and item.
   */
  async furthest(vec, filter = {}) {
    if (!vec) return console.warn("furthest: no vec");
    return await this.entities_vector_adapter.furthest(vec, filter);
  }
  /**
   * Gets the file name based on collection key and embedding model key.
   * @readonly
   * @returns {string} The constructed file name.
   */
  get file_name() {
    return this.collection_key + "-" + this.embed_model_key.split("/").pop();
  }
  /**
   * Calculates the relevance of an item based on the search filter.
   * @param {Object} item - The item to calculate relevance for.
   * @param {Object} search_filter - The search filter containing keywords.
   * @returns {number} The relevance score:
   *                   1 if any keyword is found in the item's path,
   *                   0 otherwise (default relevance for keyword in content).
   */
  calculate_relevance(item, search_filter) {
    if (search_filter.keywords.some((keyword) => item.path?.includes(keyword))) return 1;
    return 0;
  }
  /**
   * Prepares the filter options by incorporating entity-based filters.
   * @param {Object} [opts={}] - The filter options.
   * @param {Object} [opts.entity] - The entity to base the filters on.
   * @param {string|string[]} [opts.exclude_filter] - Keys or prefixes to exclude.
   * @param {string|string[]} [opts.include_filter] - Keys or prefixes to include.
   * @param {boolean} [opts.exclude_inlinks] - Whether to exclude inlinks of the entity.
   * @param {boolean} [opts.exclude_outlinks] - Whether to exclude outlinks of the entity.
   * @returns {Object} The modified filter options.
   */
  prepare_filter(opts = {}) {
    const {
      entity,
      exclude_filter,
      include_filter,
      exclude_inlinks,
      exclude_outlinks
    } = opts;
    if (entity) {
      if (typeof opts.exclude_key_starts_with_any === "undefined") opts.exclude_key_starts_with_any = [];
      if (opts.exclude_key_starts_with) {
        opts.exclude_key_starts_with_any = [
          opts.exclude_key_starts_with
        ];
        delete opts.exclude_key_starts_with;
      }
      opts.exclude_key_starts_with_any.push(entity.source_key || entity.key);
      if (exclude_filter) {
        if (!Array.isArray(opts.exclude_key_includes_any)) opts.exclude_key_includes_any = [];
        if (typeof exclude_filter === "string") {
          if (exclude_filter.includes(",")) {
            opts.exclude_key_includes_any.push(...exclude_filter.split(","));
          } else {
            opts.exclude_key_includes_any.push(exclude_filter);
          }
        }
      }
      if (include_filter) {
        if (!Array.isArray(opts.key_includes_any)) opts.key_includes_any = [];
        if (typeof include_filter === "string") {
          if (include_filter.includes(",")) {
            opts.key_includes_any.push(...include_filter.split(","));
          } else {
            opts.key_includes_any.push(include_filter);
          }
        }
      }
      if (exclude_inlinks && entity?.inlinks?.length) {
        if (!Array.isArray(opts.exclude_key_starts_with_any)) opts.exclude_key_starts_with_any = [];
        opts.exclude_key_starts_with_any.push(...entity.inlinks);
      }
      if (exclude_outlinks && entity?.outlinks?.length) {
        if (!Array.isArray(opts.exclude_key_starts_with_any)) opts.exclude_key_starts_with_any = [];
        opts.exclude_key_starts_with_any.push(...entity.outlinks);
      }
    }
    return opts;
  }
  /**
   * Looks up entities based on hypothetical content.
   * @async
   * @param {Object} [params={}] - The parameters for the lookup.
   * @param {Array<string>} [params.hypotheticals=[]] - The hypothetical content to lookup.
   * @param {Object} [params.filter] - The filter to use for the lookup.
   * @param {number} [params.k] - Deprecated: Use `filter.limit` instead.
   * @returns {Promise<Array<Result>|Object>} The lookup results or an error object.
   */
  async lookup(params = {}) {
    const { hypotheticals = [] } = params;
    if (!hypotheticals?.length) return { error: "hypotheticals is required" };
    if (!this.embed_model) return { error: "Embedding search is not enabled." };
    const hyp_vecs = await this.embed_model.embed_batch(hypotheticals.map((h) => ({ embed_input: h })));
    const limit = params.filter?.limit || params.k || this.env.settings.lookup_k || 10;
    if (params.filter?.limit) delete params.filter.limit;
    const filter = {
      ...this.env.chats?.current?.scope || {},
      // DEPRECATED: since Smart Chat v1 (remove after removing legacy Smart Chat v0 from obsidian-smart-connections)
      ...params.filter || {}
    };
    const results = await hyp_vecs.reduce(async (acc_promise, embedding, i) => {
      const acc = await acc_promise;
      const results2 = await this.nearest(embedding.vec, filter);
      results2.forEach((result) => {
        if (!acc[result.item.path] || result.score > acc[result.item.path].score) {
          acc[result.item.path] = {
            key: result.item.key,
            score: result.score,
            item: result.item,
            hypothetical_i: i
          };
        } else {
          result.score = acc[result.item.path].score;
        }
      });
      return acc;
    }, Promise.resolve({}));
    const top_k = Object.values(results).sort(sort_by_score).slice(0, limit);
    console.log(`Found and returned ${top_k.length} ${this.collection_key}.`);
    return top_k;
  }
  /**
   * Gets the configuration for settings.
   * @readonly
   * @returns {Object} The settings configuration.
   */
  get settings_config() {
    return settings_config;
  }
  /**
   * @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
   */
  async render_settings(container = this.settings_container, opts = {}) {
    container = await this.render_collection_settings(container, opts);
    const embed_model_settings_frag = await this.env.render_component("settings", this.embed_model, opts);
    container.appendChild(embed_model_settings_frag);
    return container;
  }
  /**
   * Gets the notices from the environment.
   * @readonly
   * @returns {Object} The notices object.
   */
  get notices() {
    return this.env.smart_connections_plugin?.notices || this.env.main?.notices;
  }
  /**
   * Gets the embed queue containing items to be embedded.
   * @readonly
   * @returns {Array<Object>} The embed queue.
   */
  get embed_queue() {
    if (!this._embed_queue?.length) {
      console.time(`Building embed queue`);
      this._embed_queue = Object.values(this.items).filter((item) => item._queue_embed || item.is_unembedded && item.should_embed);
      console.timeEnd(`Building embed queue`);
    }
    return this._embed_queue;
  }
  /**
   * Processes the embed queue by delegating to the default vector adapter.
   * @async
   * @returns {Promise<void>}
   */
  async process_embed_queue() {
    await this.entities_vector_adapter.process_embed_queue();
  }
  /**
   * Handles changes to the embedding model by reinitializing and processing the load queue.
   * @async
   * @returns {Promise<void>}
   */
  async embed_model_changed() {
    await this.unload();
    await this.init();
    this.render_settings();
    await this.process_load_queue();
  }
  get connections_filter_config() {
    return connections_filter_config;
  }
};
var settings_config = {
  "min_chars": {
    name: "Minimum length",
    type: "number",
    description: "Minimum length of entity to embed (in characters).",
    placeholder: "Enter number ex. 300",
    default: 300
  }
};
var connections_filter_config = {
  "smart_view_filter.show_full_path": {
    "name": "Show full path",
    "type": "toggle",
    "description": "Turning on will include the folder path in the connections results."
  },
  "smart_view_filter.render_markdown": {
    "name": "Render markdown",
    "type": "toggle",
    "description": "Turn off to prevent rendering markdown and display connection results as plain text."
  },
  "smart_view_filter.results_limit": {
    "name": "Results limit",
    "type": "number",
    "description": "Adjust the number of connections displayed in the connections view (default 20).",
    "default": 20
  },
  "smart_view_filter.exclude_inlinks": {
    "name": "Exclude inlinks (backlinks)",
    "type": "toggle",
    "description": "Exclude notes that already link to the current note from the connections results."
  },
  "smart_view_filter.exclude_outlinks": {
    "name": "Exclude outlinks",
    "type": "toggle",
    "description": "Exclude notes that are already linked from within the current note from appearing in the connections results."
  },
  "smart_view_filter.include_filter": {
    "name": "Include filter",
    "type": "text",
    "description": "Notes must match this value in their file/folder path. Matching notes will be included in the connections results. Separate multiple values with commas."
  },
  "smart_view_filter.exclude_filter": {
    "name": "Exclude filter",
    "type": "text",
    "description": "Notes must *not* match this value in their file/folder path. Matching notes will be *excluded* from the connections results. Separate multiple values with commas."
  },
  // should be better scoped at source-level (leaving here for now since connections_filter_config needs larger refactor)
  "smart_view_filter.exclude_blocks_from_source_connections": {
    "name": "Hide blocks in results",
    "type": "toggle",
    "description": "Show only sources in the connections results (no blocks)."
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-sources/components/source.js
async function render2(entity, opts = {}) {
  let markdown;
  if (should_render_embed(entity)) markdown = `${entity.embed_link}

${await entity.read()}`;
  else markdown = process_for_rendering(await entity.read());
  let frag;
  if (source.env.settings.smart_view_filter.render_markdown) frag = await this.render_markdown(markdown, source);
  else frag = this.create_doc_fragment(`<span>${markdown}</span>`);
  return await post_process2.call(this, source, frag, opts);
}
function process_for_rendering(content) {
  if (content.includes("```dataview")) content = content.replace(/```dataview/g, "```\\dataview");
  if (content.includes("![[")) content = content.replace(/\!\[\[/g, "! [[");
  return content;
}
async function post_process2(scope, frag, opts = {}) {
  return frag;
}
function should_render_embed(entity) {
  if (!entity) return false;
  if (entity.is_media) return true;
  return false;
}

// node_modules/smart-utils/geom.js
function compute_centroid(points) {
  if (!points || points.length === 0) {
    return null;
  }
  const n = points.length;
  const dim = points[0].length;
  const sums = new Float64Array(dim);
  for (let i = 0; i < n; i++) {
    const p = points[i];
    for (let d = 0; d < dim; d++) {
      sums[d] += p[d];
    }
  }
  for (let d = 0; d < dim; d++) {
    sums[d] /= n;
  }
  return Array.from(sums);
}
function compute_medoid(points) {
  if (!points || points.length === 0) {
    return null;
  }
  if (points.length === 1) {
    return points[0];
  }
  const n = points.length;
  const dim = points[0].length;
  const sum_of_distances = new Float64Array(n);
  for (let i = 0; i < n - 1; i++) {
    const p_i = points[i];
    for (let j = i + 1; j < n; j++) {
      const p_j = points[j];
      let dist_sq = 0;
      for (let d = 0; d < dim; d++) {
        const diff = p_i[d] - p_j[d];
        dist_sq += diff * diff;
      }
      const dist = Math.sqrt(dist_sq);
      sum_of_distances[i] += dist;
      sum_of_distances[j] += dist;
    }
  }
  let min_index = 0;
  let min_sum = sum_of_distances[0];
  for (let i = 1; i < n; i++) {
    if (sum_of_distances[i] < min_sum) {
      min_sum = sum_of_distances[i];
      min_index = i;
    }
  }
  return points[min_index];
}

// node_modules/obsidian-smart-env/node_modules/smart-sources/actions/find_connections.js
async function find_connections2(params = {}) {
  let connections;
  if (this.block_collection.settings.embed_blocks && !params.exclude_blocks_from_source_connections) connections = [];
  else connections = await find_connections.call(this, params);
  const filter_opts = this.prepare_find_connections_filter_opts(params);
  const limit = params.filter?.limit || params.limit || this.env.settings.smart_view_filter?.results_limit || 20;
  if (params.filter?.limit) delete params.filter.limit;
  if (params.limit) delete params.limit;
  if (!params.exclude_blocks_from_source_connections) {
    const cache_key = this.key + JSON.stringify(params) + "_blocks";
    if (!this.env.connections_cache) this.env.connections_cache = {};
    if (!this.env.connections_cache[cache_key]) {
      const nearest = (await this.env.smart_blocks.nearest(this.vec, filter_opts)).sort(sort_by_score).slice(0, limit);
      this.connections_to_cache(cache_key, nearest);
    }
    connections = [
      ...connections,
      ...this.connections_from_cache(cache_key)
    ].sort(sort_by_score).slice(0, limit);
  }
  return connections;
}

// node_modules/obsidian-smart-env/node_modules/smart-sources/smart_source.js
var SmartSource = class extends SmartEntity {
  /**
   * Provides default values for a SmartSource instance.
   * @static
   * @readonly
   * @returns {Object} The default values.
   */
  static get defaults() {
    return {
      data: {
        last_read: {
          hash: null,
          mtime: 0
        },
        embeddings: {}
      },
      _embed_input: null,
      // Stored temporarily
      _queue_load: true
    };
  }
  /**
   * Initializes the SmartSource instance by queuing an import if blocks are missing.
   * @returns {void}
   */
  init() {
    super.init();
    if (!this.data.blocks) this.queue_import();
  }
  /**
   * Queues the SmartSource for import.
   * @returns {void}
   */
  queue_import() {
    this._queue_import = true;
  }
  /**
   * Imports the SmartSource by checking for updates and parsing content.
   * @async
   * @returns {Promise<void>}
   */
  async import() {
    this._queue_import = false;
    try {
      await this.source_adapter?.import();
    } catch (err) {
      if (err.code === "ENOENT") {
        console.log(`Smart Connections: Deleting ${this.path} data because it no longer exists on disk`);
        this.delete();
      } else {
        console.warn("Smart Connections: Error during import: re-queueing import", err);
        this.queue_import();
      }
    }
  }
  /**
   * @deprecated likely extraneous
   */
  async parse_content(content = null) {
    const parse_fns = this.env?.opts?.collections?.smart_sources?.content_parsers || [];
    for (const fn of parse_fns) {
      await fn(this, content);
    }
    if (this.data.last_import?.hash === this.data.last_read?.hash) {
      if (this.data.blocks) return;
    }
  }
  /**
   * Finds connections relevant to this SmartSource based on provided parameters.
   * @async
   * @param {Object} [params={}] - Parameters for finding connections.
   * @param {boolean} [params.exclude_blocks_from_source_connections=false] - Whether to exclude block connections from source connections.
   * @returns {Array<SmartSource>} An array of relevant SmartSource entities.
   */
  async find_connections(params = {}) {
    return await this.actions.find_connections(params);
  }
  /**
   * Prepares the embed input for the SmartSource by reading content and applying exclusions.
   * @async
   * @returns {Promise<string|false>} The embed input string or `false` if already embedded.
   */
  async get_embed_input(content = null) {
    if (typeof this._embed_input === "string" && this._embed_input.length) return this._embed_input;
    if (!content) content = await this.read();
    if (!content) {
      console.warn("SmartSource.get_embed_input: No content available for embedding: " + this.path);
      return "";
    }
    if (this.excluded_lines.length) {
      const content_lines = content.split("\n");
      this.excluded_lines.forEach((lines) => {
        const { start, end } = lines;
        for (let i = start; i <= end; i++) {
          content_lines[i] = "";
        }
      });
      content = content_lines.filter((line) => line.length).join("\n");
    }
    const breadcrumbs = this.path.split("/").join(" > ").replace(".md", "");
    const max_tokens = this.collection.embed_model.model_config.max_tokens || 500;
    const max_chars = Math.floor(max_tokens * 3.7);
    this._embed_input = `${breadcrumbs}:
${content}`.substring(0, max_chars);
    return this._embed_input;
  }
  /**
   * Opens the SmartSource note in the SmartConnections plugin.
   * @returns {void}
   */
  open() {
    this.env.smart_connections_plugin.open_note(this.path);
  }
  /**
   * Retrieves the block associated with a specific line number.
   * @param {number} line - The line number to search for.
   * @returns {SmartBlock|null} The corresponding SmartBlock or `null` if not found.
   */
  get_block_by_line(line) {
    return Object.entries(this.data.blocks || {}).reduce((acc, [sub_key, range]) => {
      if (acc) return acc;
      if (range[0] <= line && range[1] >= line) {
        const block = this.block_collection.get(this.key + sub_key);
        if (block?.vec) return block;
      }
      return acc;
    }, null);
  }
  /**
   * Checks if the source file exists in the file system.
   * @async
   * @returns {Promise<boolean>} A promise that resolves to `true` if the file exists, `false` otherwise.
   */
  async has_source_file() {
    return await this.fs.exists(this.path);
  }
  // CRUD
  /**
   * FILTER/SEARCH METHODS
   */
  /**
   * Searches for keywords within the entity's data and content.
   * @async
   * @param {Object} search_filter - The search filter object.
   * @param {string[]} search_filter.keywords - An array of keywords to search for.
   * @param {string} [search_filter.type='any'] - The type of search to perform. 'any' counts all matching keywords, 'all' counts only if all keywords match.
   * @returns {Promise<number>} A promise that resolves to the number of matching keywords.
   */
  async search(search_filter = {}) {
    const { keywords, type = "any", limit } = search_filter;
    if (!keywords || !Array.isArray(keywords)) {
      console.warn("Entity.search: keywords not set or is not an array");
      return 0;
    }
    if (limit && this.collection.search_results_ct >= limit) return 0;
    const lowercased_keywords = keywords.map((keyword) => keyword.toLowerCase());
    const content = await this.read();
    const lowercased_content = content.toLowerCase();
    const lowercased_path = this.path.toLowerCase();
    const matching_keywords = lowercased_keywords.filter(
      (keyword) => lowercased_path.includes(keyword) || lowercased_content.includes(keyword)
    );
    if (type === "all") {
      return matching_keywords.length === lowercased_keywords.length ? matching_keywords.length : 0;
    } else {
      return matching_keywords.length;
    }
  }
  /**
   * ADAPTER METHODS
   */
  /**
   * Appends content to the end of the source file.
   * @async
   * @param {string} content - The content to append to the file.
   * @returns {Promise<void>} A promise that resolves when the operation is complete.
   */
  async append(content) {
    await this.source_adapter.append(content);
    await this.import();
  }
  /**
   * Updates the entire content of the source file.
   * @async
   * @param {string} full_content - The new content to write to the file.
   * @param {Object} [opts={}] - Additional options for the update.
   * @returns {Promise<void>} A promise that resolves when the operation is complete.
   */
  async update(full_content, opts = {}) {
    try {
      await this.source_adapter.update(full_content, opts);
      await this.import();
    } catch (error) {
      console.error("Error during update:", error);
      throw error;
    }
  }
  /**
   * Reads the entire content of the source file.
   * @async
   * @param {Object} [opts={}] - Additional options for reading.
   * @returns {Promise<string>} A promise that resolves with the content of the file.
   */
  async read(opts = {}) {
    try {
      const content = await this.source_adapter.read(opts);
      return content;
    } catch (error) {
      console.error("Error during read:", error);
      throw error;
    }
  }
  /**
   * Removes the source file from the file system and deletes the entity.
   * This is different from `delete()` because it also removes the source file.
   * @async
   * @returns {Promise<void>} A promise that resolves when the operation is complete.
   */
  async remove() {
    try {
      await this.source_adapter.remove();
    } catch (error) {
      console.error("Error during remove:", error);
      throw error;
    }
  }
  /**
   * Moves the current source to a new location.
   * Handles the destination as a string (new path) or entity (block or source).
   *
   * @async
   * @param {string|Object|SmartEntity} entity_ref - The destination path or entity to move to.
   * @throws {Error} If the entity reference is invalid.
   * @returns {Promise<void>} A promise that resolves when the move operation is complete.
   */
  async move_to(entity_ref) {
    try {
      await this.source_adapter.move_to(entity_ref);
    } catch (error) {
      console.error("error_during_move:", error);
      throw error;
    }
  }
  /**
   * Merges the given content into the current source.
   * Parses the content into blocks and either appends to existing blocks, replaces blocks, or replaces all content.
   *
   * @async
   * @param {string} content - The content to merge into the current source.
   * @param {Object} [opts={}] - Options object.
   * @param {string} [opts.mode='append'] - The merge mode: 'append', 'replace_blocks', or 'replace_all'.
   * @returns {Promise<void>}
   */
  async merge(content, opts = {}) {
    try {
      await this.source_adapter.merge(content, opts);
      await this.import();
    } catch (error) {
      console.error("Error during merge:", error);
      throw error;
    }
  }
  /**
   * Handles errors during the load process.
   * @param {Error} err - The error encountered during load.
   * @returns {void}
   */
  on_load_error(err) {
    super.on_load_error(err);
    if (err.code === "ENOENT") {
      this._queue_load = false;
      this.queue_import();
    }
  }
  // GETTERS
  /**
   * Retrieves the block collection associated with SmartSources.
   * @readonly
   * @returns {SmartBlocks} The block collection instance.
   */
  get block_collection() {
    return this.env.smart_blocks;
  }
  /**
   * Retrieves the vector representations of all blocks within the SmartSource.
   * @readonly
   * @returns {Array<Array<number>>} An array of vectors.
   */
  get block_vecs() {
    return this.blocks.map((block) => block.vec).filter((vec) => vec);
  }
  /**
   * Retrieves all blocks associated with the SmartSource.
   * @readonly
   * @returns {Array<SmartBlock>} An array of SmartBlock instances.
   * @description
   * Uses block refs (Fastest) to get blocks without iterating over all blocks
   */
  get blocks() {
    if (this.data.blocks) return this.block_collection.get_many(Object.keys(this.data.blocks).map((key) => this.key + key));
    return [];
  }
  /**
   * Determines if the SmartSource is excluded from processing.
   * @readonly
   * @returns {boolean} `true` if excluded, `false` otherwise.
   */
  get excluded() {
    return this.fs.is_excluded(this.path);
  }
  /**
   * Retrieves the lines excluded from embedding.
   * @readonly
   * @returns {Array<Object>} An array of objects with `start` and `end` line numbers.
   */
  get excluded_lines() {
    return this.blocks.filter((block) => block.excluded).map((block) => block.lines);
  }
  /**
   * Retrieves the file system instance from the SmartSource's collection.
   * @readonly
   * @returns {SmartFS} The file system instance.
   */
  get fs() {
    return this.collection.fs;
  }
  /**
   * Retrieves the file object associated with the SmartSource.
   * @readonly
   * @returns {Object} The file object.
   */
  get file() {
    return this.fs.files[this.path];
  }
  /**
   * Retrieves the file name of the SmartSource.
   * @readonly
   * @returns {string} The file name.
   */
  get file_name() {
    return this.path.split("/").pop();
  }
  /**
   * Retrieves the file path of the SmartSource.
   * @readonly
   * @returns {string} The file path.
   */
  get file_path() {
    return this.path;
  }
  /**
   * Retrieves the file type based on the file extension.
   * @readonly
   * @returns {string} The file type in lowercase.
   */
  get file_type() {
    if (!this._ext) {
      this._ext = this.collection.get_extension_for_path(this.path) || "md";
    }
    return this._ext;
  }
  /**
   * Retrieves the modification time of the SmartSource.
   * @readonly
   * @returns {number} The modification time.
   */
  get mtime() {
    return this.file?.stat?.mtime || 0;
  }
  /**
   * Retrieves the size of the SmartSource.
   * @readonly
   * @returns {number} The size.
   */
  get size() {
    return this.source_adapter?.size || 0;
  }
  /**
   * Retrieves the last import stat of the SmartSource.
   * @readonly
   * @returns {Object} The last import stat.
   */
  get last_import() {
    return this.data?.last_import;
  }
  /**
   * Retrieves the last import modification time of the SmartSource.
   * @readonly
   * @returns {number} The last import modification time.
   */
  get last_import_mtime() {
    return this.last_import?.mtime || 0;
  }
  /**
   * Retrieves the last import size of the SmartSource.
   * @readonly
   * @returns {number} The last import size.
   */
  get last_import_size() {
    return this.last_import?.size || 0;
  }
  /**
   * Retrieves the paths of inlinks to this SmartSource.
   * @readonly
   * @returns {Array<string>} An array of inlink paths.
   */
  get inlinks() {
    return Object.keys(this.collection.links?.[this.path] || {});
  }
  get is_media() {
    return this.source_adapter.is_media || false;
  }
  /**
   * Determines if the SmartSource is gone (i.e., the file no longer exists).
   * @readonly
   * @returns {boolean} `true` if gone, `false` otherwise.
   */
  get is_gone() {
    return !this.file;
  }
  /**
   * Retrieves the last read hash of the SmartSource.
   * @readonly
   * @returns {string|undefined} The last read hash or `undefined` if not set.
   */
  get last_read() {
    return this.data.last_read;
  }
  get metadata() {
    return this.data.metadata;
  }
  /**
   * Retrieves the display name of the SmartSource.
   * @readonly
   * @returns {string} The display name.
   */
  get name() {
    if (this.should_show_full_path) return this.path.split("/").join(" > ").replace(".md", "");
    return this.path.split("/").pop().replace(".md", "");
  }
  get outdated() {
    return this.source_adapter.outdated;
  }
  /**
   * Retrieves the outlink paths from the SmartSource.
   * @readonly
   * @returns {Array<string>} An array of outlink paths.
   */
  get outlinks() {
    return (this.data.outlinks || []).map((link) => {
      const link_ref = link?.target || link;
      if (typeof link_ref !== "string") return null;
      if (link_ref.startsWith("http")) return null;
      const link_path = this.fs.get_link_target_path(link_ref, this.file_path);
      return link_path;
    }).filter((link_path) => link_path);
  }
  get path() {
    return this.data.path || this.data.key;
  }
  get source_adapters() {
    return this.collection.source_adapters;
  }
  get source_adapter() {
    if (this._source_adapter) return this._source_adapter;
    if (this.source_adapters[this.file_type]) this._source_adapter = new this.source_adapters[this.file_type](this);
    else {
    }
    return this._source_adapter;
  }
  // COMPONENTS
  /**
   * Retrieves the component responsible for rendering the SmartSource.
   * @deprecated
   * @readonly
   * @returns {Function} The render function for the source component.
   */
  get component() {
    return render2;
  }
  // Currently unused, but useful for later
  /**
   * Calculates the mean vector of all blocks within the SmartSource.
   * @readonly
   * @returns {Array<number>|null} The mean vector or `null` if no vectors are present.
   */
  get mean_block_vec() {
    if (this._mean_block_vec) {
      this._mean_block_vec = compute_centroid(this.block_vecs);
    }
    return this._mean_block_vec;
  }
  /**
   * Calculates the median vector of all blocks within the SmartSource.
   * @readonly
   * @returns {Array<number>|null} The median vector or `null` if no vectors are present.
   */
  get median_block_vec() {
    if (this._median_block_vec) {
      this._median_block_vec = compute_medoid(this.block_vecs);
    }
    return this._median_block_vec;
  }
  // DEPRECATED methods
  /**
   * @async
   * @deprecated Use `read` instead.
   * @returns {Promise<string>} A promise that resolves with the content of the file.
   */
  async _read() {
    return await this.source_adapter._read();
  }
  /**
   * @async
   * @deprecated Use `remove` instead.
   * @returns {Promise<void>} A promise that resolves when the entity is destroyed.
   */
  async destroy() {
    await this.remove();
  }
  /**
   * @async
   * @deprecated Use `update` instead.
   * @param {string} content - The content to update.
   * @returns {Promise<void>}
   */
  async _update(content) {
    await this.source_adapter.update(content);
  }
  /**
   * @deprecated Use `source` instead.
   * @readonly
   * @returns {SmartSource} The associated SmartSource instance.
   */
  get t_file() {
    return this.fs.files[this.path];
  }
};
var smart_source_default = {
  class: SmartSource,
  actions: {
    find_connections: find_connections2
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-sources/smart_sources.js
var SmartSources = class extends SmartEntities {
  /**
   * Creates an instance of SmartSources.
   * @constructor
   * @param {Object} env - The environment instance.
   * @param {Object} [opts={}] - Configuration options.
   */
  constructor(env, opts = {}) {
    super(env, opts);
    this.search_results_ct = 0;
    this._excluded_headings = null;
  }
  /**
   * Initializes the SmartSources instance by performing an initial scan of sources.
   * @async
   * @returns {Promise<void>}
   */
  async init() {
    await super.init();
    await this.init_items();
  }
  /**
   * Initializes items by letting each adapter do any necessary file-based scanning.
   * Adapters that do not rely on file scanning can skip or do nothing.
   * @async
   * @returns {Promise<void>}
   */
  async init_items() {
    this.show_process_notice("initial_scan");
    for (const AdapterClass of Object.values(this.source_adapters)) {
      if (typeof AdapterClass.init_items === "function") {
        await AdapterClass.init_items(this);
      }
    }
    this.clear_process_notice("initial_scan");
    this.notices?.show("done_initial_scan", { collection_key: this.collection_key });
  }
  /**
   * Creates (or returns existing) a SmartSource for a given file path, if the extension is recognized.
   * @param {string} file_path - The path to the file or pseudo-file
   * @returns {SmartSource|undefined} The newly created or existing SmartSource, or undefined if no recognized extension
   */
  init_file_path(file_path) {
    const ext = this.get_extension_for_path(file_path);
    if (!ext) {
      return;
    }
    if (this.fs.is_excluded(file_path)) {
      console.warn(`File ${file_path} is excluded from processing.`);
      return;
    }
    if (!this.fs.files[file_path]) {
      this.fs.include_file(file_path);
    }
    if (this.items[file_path]) return this.items[file_path];
    const item = new this.item_type(this.env, { path: file_path });
    this.items[file_path] = item;
    item.queue_import();
    item.queue_load();
    return item;
  }
  /**
   * Looks for an extension in descending order:
   * e.g. split "my.file.name.github" -> ["my","file","name","github"]
   * Try 'file.name.github', 'name.github', 'github'
   * Return the first that is in 'source_adapters'
   * @param {string} file_path
   * @returns {string|undefined} recognized extension, or undefined if none
   */
  get_extension_for_path(file_path) {
    if (!file_path) return void 0;
    const pcs = file_path.split(".");
    if (pcs.length < 2) return void 0;
    let last_ext;
    pcs.shift();
    while (pcs.length) {
      const supported_ext = pcs.join(".").toLowerCase();
      if (this.source_adapters[supported_ext]) {
        return supported_ext;
      }
      last_ext = pcs.shift();
    }
    return last_ext;
    return void 0;
  }
  /**
   * Builds a map of links between sources.
   * @returns {Object} An object mapping link paths to source keys.
   */
  build_links_map() {
    const start_time = Date.now();
    this.links = {};
    for (const source2 of Object.values(this.items)) {
      for (const link of source2.outlinks) {
        if (!this.links[link]) this.links[link] = {};
        this.links[link][source2.key] = true;
      }
    }
    const end_time = Date.now();
    console.log(`Time spent building links: ${end_time - start_time}ms`);
    return this.links;
  }
  /**
   * Creates a new source with the given key and content.
   * @async
   * @param {string} key - The key (path) of the new source.
   * @param {string} content - The content to write to the new source.
   * @returns {Promise<SmartSource>} The created SmartSource instance.
   */
  async create(key, content) {
    await this.fs.write(key, content);
    await this.fs.refresh();
    const source2 = await this.create_or_update({ path: key });
    await source2.import();
    return source2;
  }
  /**
   * Performs a lexical search for matching SmartSource content.
   * @async
   * @param {Object} search_filter - The filter criteria for the search.
   * @param {string[]} search_filter.keywords - An array of keywords to search for.
   * @param {number} [search_filter.limit] - The maximum number of results to return.
   * @returns {Promise<Array<SmartSource>>} A promise that resolves to an array of matching SmartSource entities.
   */
  async search(search_filter = {}) {
    const {
      keywords,
      limit,
      ...filter_opts
    } = search_filter;
    if (!keywords) {
      console.warn("search_filter.keywords not set");
      return [];
    }
    this.search_results_ct = 0;
    const initial_results = this.filter(filter_opts);
    const search_results = [];
    for (let i = 0; i < initial_results.length; i += 10) {
      const batch = initial_results.slice(i, i + 10);
      const batch_results = await Promise.all(
        batch.map(async (item) => {
          try {
            const matches = await item.search(search_filter);
            if (matches) {
              this.search_results_ct++;
              return { item, score: matches };
            } else return null;
          } catch (error) {
            console.error(`Error searching item ${item.id || "unknown"}:`, error);
            return null;
          }
        })
      );
      search_results.push(...batch_results.filter(Boolean));
    }
    return search_results.sort((a, b) => b.score - a.score).map((result) => result.item);
  }
  /**
   * Looks up entities based on the provided parameters.
   * @async
   * @param {Object} [params={}] - Parameters for the lookup.
   * @param {Object} [params.filter] - Filter options.
   * @param {number} [params.k] - Deprecated. Use `params.filter.limit` instead.
   * @returns {Promise<Array<SmartSource>>} A promise that resolves to an array of matching SmartSource entities.
   */
  async lookup(params = {}) {
    const limit = params.filter?.limit || params.k || this.env.settings.lookup_k || 10;
    if (params.filter?.limit) delete params.filter.limit;
    if (params.collection) {
      const collection = this.env[params.collection];
      if (collection && collection.lookup) {
        delete params.collection;
        params.skip_blocks = true;
        const results2 = await collection.lookup(params);
        if (results2.error) {
          console.warn(results2.error);
          return [];
        }
        return results2.slice(0, limit);
      }
    }
    let results = await super.lookup(params);
    if (results.error) {
      console.warn(results.error);
      return [];
    }
    if (this.block_collection?.settings?.embed_block && !params.skip_blocks) {
      results = [
        ...results,
        ...await this.block_collection.lookup(params)
      ].sort(sort_by_score);
    }
    return results.slice(0, limit);
  }
  /**
   * Processes the load queue by loading items and optionally importing them.
   * Called after a "re-load" from settings, or after environment init.
   * @async
   * @returns {Promise<void>}
   */
  async process_load_queue() {
    await super.process_load_queue();
    if (this.collection_key === "smart_sources" && this.env.smart_blocks) {
      Object.values(this.env.smart_blocks.items).forEach((item) => item.init());
    }
    if (this.block_collection) {
      this.block_collection.loaded = Object.keys(this.block_collection.items).length;
    }
    if (!this.opts.prevent_import_on_load) {
      await this.process_source_import_queue(this.opts);
    }
    this.build_links_map();
  }
  /**
   * @method process_source_import_queue
   * @description 
   * Imports items (SmartSources or SmartBlocks) that have been flagged for import.
   */
  async process_source_import_queue(opts = {}) {
    const { process_embed_queue = true, force = false } = opts;
    if (force) Object.values(this.items).forEach((item) => item._queue_import = true);
    const import_queue = Object.values(this.items).filter((item) => item._queue_import);
    console.log("import_queue " + import_queue.length);
    if (import_queue.length) {
      const time_start = Date.now();
      for (let i = 0; i < import_queue.length; i += 100) {
        this.notices?.show("import_progress", {
          progress: i,
          total: import_queue.length
        });
        await Promise.all(import_queue.slice(i, i + 100).map((item) => item.import()));
      }
      setTimeout(() => {
        this.notices?.remove("import_progress");
      }, 1e3);
      this.notices?.show("done_import", {
        count: import_queue.length,
        time_in_seconds: (Date.now() - time_start) / 1e3
      });
    } else {
      this.notices?.show("no_import_queue");
    }
    this.build_links_map();
    if (process_embed_queue) await this.process_embed_queue();
    else console.log("skipping process_embed_queue");
    await this.process_save_queue();
    await this.block_collection?.process_save_queue();
  }
  /**
   * Retrieves the source adapters based on the collection configuration.
   * @readonly
   * @returns {Object} An object mapping file extensions to adapter constructors.
   */
  get source_adapters() {
    if (!this._source_adapters) {
      const source_adapters = Object.values(this.env.opts.collections?.[this.collection_key]?.source_adapters || {});
      const _source_adapters = source_adapters.reduce((acc, adapter) => {
        adapter.extensions?.forEach((ext) => acc[ext] = adapter);
        return acc;
      }, {});
      if (Object.keys(_source_adapters).length) {
        this._source_adapters = _source_adapters;
      }
    }
    return this._source_adapters;
  }
  /**
   * Retrieves the notices system from the environment.
   * @readonly
   * @returns {Object} The notices object.
   */
  get notices() {
    return this.env.smart_connections_plugin?.notices || this.env.main?.notices;
  }
  /**
   * Retrieves the currently active note.
   * @readonly
   * @returns {SmartSource|null} The current SmartSource instance or null if none.
   */
  get current_note() {
    return this.get(this.env.smart_connections_plugin.app.workspace.getActiveFile().path);
  }
  /**
   * Retrieves the file system instance, initializing it if necessary.
   * @readonly
   * @returns {SmartFS} The file system instance.
   */
  get fs() {
    if (!this._fs) {
      this._fs = new this.env.opts.modules.smart_fs.class(this.env, {
        adapter: this.env.opts.modules.smart_fs.adapter,
        fs_path: this.env.opts.env_path || "",
        exclude_patterns: this.excluded_patterns || []
      });
    }
    return this._fs;
  }
  /**
   * Retrieves the settings configuration by combining superclass settings and adapter-specific settings.
   * @readonly
   * @returns {Object} The settings configuration object.
   */
  get settings_config() {
    const _settings_config = {
      ...super.settings_config,
      ...this.process_settings_config(settings_config2),
      ...this.process_settings_config(this.embed_model.settings_config, "embed_model"),
      ...Object.entries(this.source_adapters).reduce((acc, [file_extension, adapter_constructor]) => {
        if (acc[adapter_constructor]) return acc;
        const item = this.items[Object.keys(this.items).find((i) => i.endsWith(file_extension))];
        const adapter_instance = new adapter_constructor(item || new this.item_type(this.env, {}));
        if (adapter_instance.settings_config) {
          acc[adapter_constructor.name] = {
            type: "html",
            value: `<h4>${adapter_constructor.name} adapter</h4>`
          };
          acc = { ...acc, ...adapter_instance.settings_config };
        }
        return acc;
      }, {})
    };
    return _settings_config;
  }
  /**
   * Retrieves the block collection associated with SmartSources.
   * @readonly
   * @returns {SmartBlocks} The block collection instance.
   */
  get block_collection() {
    return this.env.smart_blocks;
  }
  /**
   * Retrieves the embed queue containing items and their blocks to be embedded.
   * @readonly
   * @returns {Array<Object>} The embed queue.
   */
  get embed_queue() {
    if (!this._embed_queue.length) {
      try {
        const embed_blocks = this.block_collection.settings.embed_blocks;
        this._embed_queue = Object.values(this.items).reduce((acc, item) => {
          if (item._queue_embed || item.should_embed && item.is_unembedded) acc.push(item);
          if (embed_blocks) item.blocks.forEach((block) => {
            if (block._queue_embed || block.should_embed && block.is_unembedded) acc.push(block);
          });
          return acc;
        }, []);
      } catch (e) {
        console.error(`Error getting embed queue:`, e);
      }
    }
    return this._embed_queue;
  }
  /**
   * Clears all data by removing sources and blocks, reinitializing the file system, and reimporting items.
   * @async
   * @returns {Promise<void>}
   */
  async run_clear_all() {
    this.notices?.show("clearing_all");
    await this.data_fs.remove_dir(this.data_dir, true);
    this.clear();
    this.block_collection.clear();
    this._fs = null;
    await this.init_fs();
    await this.init_items();
    this._excluded_headings = null;
    Object.values(this.items).forEach((item) => {
      item.queue_import();
      item.queue_embed();
      item.loaded_at = Date.now() + 9999999999;
    });
    this.notices?.remove("clearing_all");
    this.notices?.show("done_clearing_all");
    await this.process_source_import_queue();
  }
  async init_fs(opts = {}) {
    const { force_refresh = false } = opts;
    if (force_refresh) await this.env.fs.refresh();
    await this.fs.load_exclusions();
    this.fs.file_paths = this.fs.post_process(this.env.fs.file_paths);
    this.fs.files = this.fs.file_paths.reduce((acc, file_path) => {
      acc[file_path] = this.env.fs.files[file_path];
      return acc;
    }, {});
    this.fs.folder_paths = this.fs.post_process(this.env.fs.folder_paths);
    this.fs.folders = this.fs.folder_paths.reduce((acc, folder_path) => {
      acc[folder_path] = this.env.fs.folders[folder_path];
      return acc;
    }, {});
  }
  /**
   * Deletes all *.ajson files in the "multi/" data_dir, then re-saves all sources (opts.force=true).
   */
  async run_clean_up_data() {
    this.notices?.show("pruning_collection", { collection_key: this.block_collection.collection_key });
    const remove_smart_blocks = this.block_collection.filter((item) => {
      if (!item.vec) return false;
      if (item.is_gone) {
        item.reason = "is_gone";
        return true;
      }
      if (!item.should_embed) {
        item.reason = "should not embed";
        return true;
      }
      return false;
    });
    for (let i = 0; i < remove_smart_blocks.length; i++) {
      const item = remove_smart_blocks[i];
      if (item.is_gone) item.delete();
      else item.remove_embeddings();
    }
    this.notices?.remove("pruning_collection");
    this.notices?.show("done_pruning_collection", { collection_key: this.block_collection.collection_key, count: remove_smart_blocks.length });
    console.log(`Pruned ${remove_smart_blocks.length} blocks:
${remove_smart_blocks.map((item) => `${item.reason} - ${item.key}`).join("\n")}`);
    await this.data_fs.remove_dir(this.data_dir, true);
    await this.process_save_queue({ force: true });
  }
  /**
   * Retrieves patterns for excluding files/folders from processing.
   * @readonly
   * @returns {Array<string>}
   */
  get excluded_patterns() {
    return [
      ...this.file_exclusions?.map((file) => `${file}**`) || [],
      ...(this.folder_exclusions || []).map((folder) => `${folder}**`),
      this.env.env_data_dir + "/**"
    ];
  }
  /**
   * Retrieves the file exclusion patterns from settings.
   * @readonly
   * @returns {Array<string>} An array of file exclusion patterns.
   */
  get file_exclusions() {
    return this.env.settings?.file_exclusions?.length ? this.env.settings.file_exclusions.split(",").map((file) => file.trim()) : [];
  }
  /**
   * Retrieves the folder exclusion patterns from settings.
   * @readonly
   * @returns {Array<string>} An array of folder exclusion patterns.
   */
  get folder_exclusions() {
    return this.env.settings?.folder_exclusions?.length ? this.env.settings.folder_exclusions.split(",").map((folder) => {
      folder = folder.trim();
      if (folder === "") return false;
      if (folder === "/") return false;
      if (!folder.endsWith("/")) return folder + "/";
      return folder;
    }).filter(Boolean) : [];
  }
  /**
   * Retrieves the excluded headings from settings.
   * @readonly
   * @returns {Array<string>} An array of excluded headings.
   */
  get excluded_headings() {
    if (!this._excluded_headings) {
      this._excluded_headings = this.env.settings?.excluded_headings?.length ? this.env.settings.excluded_headings.split(",").map((heading) => heading.trim()) : [];
    }
    return this._excluded_headings;
  }
  /**
   * Retrieves the count of included files that are not excluded.
   * @readonly
   * @returns {number} The number of included files.
   */
  get included_files() {
    const extensions = Object.keys(this.source_adapters);
    return this.fs.file_paths.filter((file_path) => extensions.some((ext) => file_path.endsWith(ext)) && !this.fs.is_excluded(file_path)).length;
  }
  get excluded_file_paths() {
    return this.env.fs.file_paths.filter((file_path) => this.fs.is_excluded(file_path));
  }
  /**
   * Retrieves the total number of files, regardless of exclusion.
   * @readonly
   * @returns {number} The total number of files.
   */
  get total_files() {
    return this.fs.file_paths.filter((file) => file.endsWith(".md") || file.endsWith(".canvas")).length;
  }
  get data_dir() {
    return "multi";
  }
};
var settings_config2 = {
  // "smart_change.active": {
  //   "name": "Smart Change (change safety)",
  //   "description": "Enable Smart Changes (prevents accidental deletions/overwrites).",
  //   "type": "toggle",
  //   "default": true,
  // },
};

// node_modules/obsidian-smart-env/node_modules/smart-collections/adapters/_adapter.js
var CollectionDataAdapter = class {
  /**
   * @constructor
   * @param {Object} collection - The collection instance that this adapter manages.
   */
  constructor(collection) {
    this.collection = collection;
    this.env = collection.env;
  }
  /**
   * The class to use for item adapters.
   * @type {typeof ItemDataAdapter}
   */
  ItemDataAdapter = ItemDataAdapter;
  /**
   * Optional factory method to create item adapters.
   * If `this.item_adapter_class` is not null, it uses that; otherwise can be overridden by subclasses.
   * @param {Object} item - The item to create an adapter for.
   * @returns {ItemDataAdapter}
   */
  create_item_adapter(item) {
    if (!this.ItemDataAdapter) {
      throw new Error("No item_adapter_class specified and create_item_adapter not overridden.");
    }
    return new this.ItemDataAdapter(item);
  }
  /**
   * Load a single item by its key using an `ItemDataAdapter`.
   * @async
   * @param {string} key - The key of the item to load.
   * @returns {Promise<void>} Resolves when the item is loaded.
   */
  async load_item(key) {
    throw new Error("Not implemented");
  }
  /**
   * Save a single item by its key using its associated `ItemDataAdapter`.
   * @async
   * @param {string} key - The key of the item to save.
   * @returns {Promise<void>} Resolves when the item is saved.
   */
  async save_item(key) {
    throw new Error("Not implemented");
  }
  /**
   * Delete a single item by its key. This may involve updating or removing its file,
   * as handled by the `ItemDataAdapter`.
   * @async
   * @param {string} key - The key of the item to delete.
   * @returns {Promise<void>} Resolves when the item is deleted.
   */
  async delete_item(key) {
    throw new Error("Not implemented");
  }
  /**
   * Process any queued load operations. Typically orchestrates calling `load_item()` 
   * on items that have been flagged for loading.
   * @async
   * @returns {Promise<void>}
   */
  async process_load_queue() {
    throw new Error("Not implemented");
  }
  /**
   * Process any queued save operations. Typically orchestrates calling `save_item()` 
   * on items that have been flagged for saving.
   * @async
   * @returns {Promise<void>}
   */
  async process_save_queue() {
    throw new Error("Not implemented");
  }
  /**
   * Load the item's data from storage if it has been updated externally.
   * @async
   * @param {string} key - The key of the item to load.
   * @returns {Promise<void>} Resolves when the item is loaded.
   */
  async load_item_if_updated(item) {
    const adapter = this.create_item_adapter(item);
    await adapter.load_if_updated();
  }
};
var ItemDataAdapter = class {
  /**
   * @constructor
   * @param {Object} item - The collection item instance that this adapter manages.
   */
  constructor(item) {
    this.item = item;
  }
  /**
   * Load the item's data from storage. May involve reading a file and parsing 
   * its contents, then updating `item.data`.
   * @async
   * @returns {Promise<void>} Resolves when the item is fully loaded.
   */
  async load() {
    throw new Error("Not implemented");
  }
  /**
   * Save the item's data to storage. May involve writing to a file or appending 
   * lines in an append-only format.
   * @async
   * @param {string|null} [ajson=null] - An optional serialized representation of the item’s data.
   *                                     If not provided, the adapter should derive it from the item.
   * @returns {Promise<void>} Resolves when the item is saved.
   */
  async save(ajson = null) {
    throw new Error("Not implemented");
  }
  /**
   * Delete the item's data from storage. May involve removing a file or writing 
   * a `null` entry in an append-only file to signify deletion.
   * @async
   * @returns {Promise<void>} Resolves when the item’s data is deleted.
   */
  async delete() {
    throw new Error("Not implemented");
  }
  /**
   * Returns the file path or unique identifier used by this adapter to locate and store 
   * the item's data. This may be a file name derived from the item's key.
   * @returns {string} The path or identifier for the item's data.
   */
  get data_path() {
    throw new Error("Not implemented");
  }
  /**
   * @returns {CollectionDataAdapter} The collection data adapter that this item data adapter belongs to.
   */
  get collection_adapter() {
    return this.item.collection.data_adapter;
  }
  get env() {
    return this.item.env;
  }
  /**
   * Load the item's data from storage if it has been updated externally.
   * @async
   * @returns {Promise<void>} Resolves when the item is loaded.
   */
  async load_if_updated() {
    throw new Error("Not implemented");
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-collections/adapters/_file.js
var FileCollectionDataAdapter = class extends CollectionDataAdapter {
  /**
   * The class to use for item adapters.
   * @type {typeof ItemDataAdapter}
   */
  ItemDataAdapter = FileItemDataAdapter;
  /**
   * @returns {Object} Filesystem interface derived from environment or collection settings.
   */
  get fs() {
    return this.collection.data_fs || this.collection.env.data_fs;
  }
};
var FileItemDataAdapter = class extends ItemDataAdapter {
  /**
   * @returns {Object} Filesystem interface derived from environment or collection settings.
   */
  get fs() {
    return this.item.collection.data_fs || this.item.collection.env.data_fs;
  }
  get data_path() {
    throw new Error("Not implemented");
  }
  async load_if_updated() {
    const data_path = this.data_path;
    if (await this.fs.exists(data_path)) {
      const loaded_at = this.item.loaded_at || 0;
      const data_file_stat = await this.fs.stat(data_path);
      if (data_file_stat.mtime > loaded_at + 1 * 60 * 1e3) {
        console.log(`Smart Collections: Re-loading item ${this.item.key} because it has been updated on disk`);
        await this.load();
      }
    }
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-collections/adapters/ajson_multi_file.js
var class_to_collection_key = {
  "SmartSource": "smart_sources",
  "SmartNote": "smart_sources",
  // DEPRECATED
  "SmartBlock": "smart_blocks",
  "SmartDirectory": "smart_directories"
};
var AjsonMultiFileCollectionDataAdapter = class extends FileCollectionDataAdapter {
  /**
   * The class to use for item adapters.
   * @type {typeof ItemDataAdapter}
   */
  ItemDataAdapter = AjsonMultiFileItemDataAdapter;
  /**
   * Load a single item by its key.
   * @async
   * @param {string} key
   * @returns {Promise<void>}
   */
  async load_item(key) {
    const item = this.collection.get(key);
    if (!item) return;
    const adapter = this.create_item_adapter(item);
    await adapter.load();
  }
  /**
   * Save a single item by its key.
   * @async
   * @param {string} key
   * @returns {Promise<void>}
   */
  async save_item(key) {
    const item = this.collection.get(key);
    if (!item) return;
    const adapter = this.create_item_adapter(item);
    await adapter.save();
  }
  /**
   * Process any queued load operations.
   * @async
   * @returns {Promise<void>}
   */
  async process_load_queue() {
    this.collection.show_process_notice("loading_collection");
    if (!await this.fs.exists(this.collection.data_dir)) {
      await this.fs.mkdir(this.collection.data_dir);
    }
    const load_queue = Object.values(this.collection.items).filter((item) => item._queue_load);
    if (!load_queue.length) {
      this.collection.clear_process_notice("loading_collection");
      return;
    }
    console.log(`Loading ${this.collection.collection_key}: ${load_queue.length} items`);
    const batch_size = 100;
    for (let i = 0; i < load_queue.length; i += batch_size) {
      const batch = load_queue.slice(i, i + batch_size);
      await Promise.all(batch.map((item) => {
        const adapter = this.create_item_adapter(item);
        return adapter.load().catch((err) => {
          console.warn(`Error loading item ${item.key}`, err);
          item.queue_load();
        });
      }));
    }
    this.collection.loaded = load_queue.length;
    this.collection.clear_process_notice("loading_collection");
  }
  /**
   * Process any queued save operations.
   * @async
   * @returns {Promise<void>}
   */
  async process_save_queue() {
    this.collection.show_process_notice("saving_collection");
    const save_queue = Object.values(this.collection.items).filter((item) => item._queue_save);
    console.log(`Saving ${this.collection.collection_key}: ${save_queue.length} items`);
    const time_start = Date.now();
    const batch_size = 50;
    for (let i = 0; i < save_queue.length; i += batch_size) {
      const batch = save_queue.slice(i, i + batch_size);
      await Promise.all(batch.map((item) => {
        const adapter = this.create_item_adapter(item);
        return adapter.save().catch((err) => {
          console.warn(`Error saving item ${item.key}`, err);
          item.queue_save();
        });
      }));
    }
    const deleted_items = Object.values(this.collection.items).filter((item) => item.deleted);
    if (deleted_items.length) {
      deleted_items.forEach((item) => {
        delete this.collection.items[item.key];
      });
    }
    console.log(`Saved ${this.collection.collection_key} in ${Date.now() - time_start}ms`);
    this.collection.clear_process_notice("saving_collection");
  }
  get_item_data_path(key) {
    return [
      this.collection.data_dir || "multi",
      this.fs?.sep || "/",
      this.get_data_file_name(key) + ".ajson"
    ].join("");
  }
  /**
   * Transforms the item key into a safe filename.
   * Replaces spaces, slashes, and dots with underscores.
   * @returns {string} safe file name
   */
  get_data_file_name(key) {
    return key.split("#")[0].replace(/[\s\/\.]/g, "_").replace(".md", "");
  }
  /**
   * Build a single AJSON line for the given item and data.
   * @param {Object} item 
   * @returns {string}
   */
  get_item_ajson(item) {
    const collection_key = item.collection_key;
    const key = item.key;
    const data_value = item.deleted ? "null" : JSON.stringify(item.data);
    return `${JSON.stringify(`${collection_key}:${key}`)}: ${data_value},`;
  }
};
var AjsonMultiFileItemDataAdapter = class extends FileItemDataAdapter {
  /**
   * Derives the `.ajson` file path from the collection's data_dir and item key.
   * @returns {string}
   */
  get data_path() {
    return this.collection_adapter.get_item_data_path(this.item.key);
  }
  /**
   * Load the item from its `.ajson` file.
   * @async
   * @returns {Promise<void>}
   */
  async load() {
    try {
      const raw_data = await this.fs.adapter.read(this.data_path, "utf-8", { no_cache: true });
      if (!raw_data) {
        this.item.queue_import();
        return;
      }
      const { rewrite, file_data } = this._parse(raw_data);
      if (rewrite) {
        if (file_data.length) await this.fs.write(this.data_path, file_data);
        else await this.fs.remove(this.data_path);
      }
      const last_import_mtime = this.item.data.last_import?.at || 0;
      if (last_import_mtime && this.item.init_file_mtime > last_import_mtime) {
        this.item.queue_import();
      }
    } catch (e) {
      this.item.queue_import();
    }
  }
  /**
   * Parse the entire AJSON content as a JSON object, handle legacy keys, and extract final state.
   * @private
   * @param {string} ajson 
   * @returns {boolean}
   */
  _parse(ajson) {
    try {
      let rewrite = false;
      if (!ajson.length) return false;
      ajson = ajson.trim();
      const original_line_count = ajson.split("\n").length;
      const json_str = "{" + ajson.slice(0, -1) + "}";
      const data = JSON.parse(json_str);
      const entries = Object.entries(data);
      for (let i = 0; i < entries.length; i++) {
        const [ajson_key, value] = entries[i];
        if (!value) {
          delete data[ajson_key];
          rewrite = true;
          continue;
        }
        const { collection_key, item_key, changed } = this._parse_ajson_key(ajson_key);
        if (changed) {
          rewrite = true;
          data[collection_key + ":" + item_key] = value;
          delete data[ajson_key];
        }
        const collection = this.env[collection_key];
        if (!collection) continue;
        const existing_item = collection.get(item_key);
        if (!value.key) value.key = item_key;
        if (existing_item) {
          existing_item.data = value;
          existing_item._queue_load = false;
          existing_item.loaded_at = Date.now();
        } else {
          const ItemClass = collection.item_type;
          const new_item = new ItemClass(this.env, value);
          new_item._queue_load = false;
          new_item.loaded_at = Date.now();
          collection.set(new_item);
        }
      }
      if (rewrite || original_line_count > entries.length) {
        rewrite = true;
      }
      return {
        rewrite,
        file_data: rewrite ? Object.entries(data).map(([key, value]) => `${JSON.stringify(key)}: ${JSON.stringify(value)},`).join("\n") : null
      };
    } catch (e) {
      if (ajson.split("\n").some((line) => !line.endsWith(","))) {
        console.warn("fixing trailing comma error");
        ajson = ajson.split("\n").map((line) => line.endsWith(",") ? line : line + ",").join("\n");
        return this._parse(ajson);
      }
      console.warn("Error parsing JSON:", e);
      return { rewrite: true, file_data: null };
    }
  }
  _parse_ajson_key(ajson_key) {
    let changed;
    let [collection_key, ...item_key] = ajson_key.split(":");
    if (class_to_collection_key[collection_key]) {
      collection_key = class_to_collection_key[collection_key];
      changed = true;
    }
    return {
      collection_key,
      item_key: item_key.join(":"),
      changed
    };
  }
  /**
   * Save the current state of the item by appending a new line to its `.ajson` file.
   * @async
   * @returns {Promise<void>}
   */
  async save(retries = 0) {
    try {
      const ajson_line = this.get_item_ajson();
      await this.fs.append(this.data_path, "\n" + ajson_line);
      this.item._queue_save = false;
    } catch (e) {
      if (e.code === "ENOENT" && retries < 1) {
        const dir = this.collection_adapter.collection.data_dir;
        if (!await this.fs.exists(dir)) {
          await this.fs.mkdir(dir);
        }
        return await this.save(retries + 1);
      }
      console.warn("Error saving item", this.data_path, this.item.key, e);
    }
  }
  /**
   * Build a single AJSON line for the given item and data.
   * @param {Object} item 
   * @returns {string}
   */
  get_item_ajson() {
    return this.collection_adapter.get_item_ajson(this.item);
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-sources/adapters/data/ajson_multi_file.js
var AjsonMultiFileSourcesDataAdapter = class extends AjsonMultiFileCollectionDataAdapter {
  ItemDataAdapter = AjsonMultiFileSourceDataAdapter;
};
var AjsonMultiFileSourceDataAdapter = class extends AjsonMultiFileItemDataAdapter {
};

// node_modules/smart-utils/create_hash.js
function murmur_hash_32(input_string, seed = 0) {
  let remainder = input_string.length & 3;
  let bytes = input_string.length - remainder;
  let h1 = seed;
  let c1 = 3432918353;
  let c2 = 461845907;
  let i = 0;
  let k1 = 0;
  let chunk = 0;
  while (i < bytes) {
    chunk = input_string.charCodeAt(i) & 255 | (input_string.charCodeAt(i + 1) & 255) << 8 | (input_string.charCodeAt(i + 2) & 255) << 16 | (input_string.charCodeAt(i + 3) & 255) << 24;
    i += 4;
    k1 = chunk;
    k1 = multiply_32(k1, c1);
    k1 = rotate_left_32(k1, 15);
    k1 = multiply_32(k1, c2);
    h1 ^= k1;
    h1 = rotate_left_32(h1, 13);
    h1 = h1 * 5 + 3864292196 | 0;
  }
  k1 = 0;
  switch (remainder) {
    case 3:
      k1 ^= (input_string.charCodeAt(i + 2) & 255) << 16;
    // falls through
    case 2:
      k1 ^= (input_string.charCodeAt(i + 1) & 255) << 8;
    // falls through
    case 1:
      k1 ^= input_string.charCodeAt(i) & 255;
      k1 = multiply_32(k1, c1);
      k1 = rotate_left_32(k1, 15);
      k1 = multiply_32(k1, c2);
      h1 ^= k1;
      break;
  }
  h1 ^= input_string.length;
  h1 = fmix_32(h1);
  return h1 | 0;
}
function murmur_hash_32_alphanumeric(input_string, seed = 0) {
  const signed_hash = murmur_hash_32(input_string, seed);
  const unsigned_hash = signed_hash >>> 0;
  return unsigned_hash.toString(36);
}
function multiply_32(a, b) {
  return (a & 65535) * b + ((a >>> 16) * b << 16) | 0;
}
function rotate_left_32(value, shift) {
  return value << shift | value >>> 32 - shift;
}
function fmix_32(h) {
  h ^= h >>> 16;
  h = multiply_32(h, 2246822507);
  h ^= h >>> 13;
  h = multiply_32(h, 3266489909);
  h ^= h >>> 16;
  return h | 0;
}

// node_modules/obsidian-smart-env/node_modules/smart-sources/adapters/_adapter.js
var SourceContentAdapter = class {
  constructor(item) {
    this.item = item;
  }
  async import() {
    this.throw_not_implemented("import");
  }
  async create() {
    this.throw_not_implemented("create");
  }
  async update() {
    this.throw_not_implemented("update");
  }
  async read() {
    this.throw_not_implemented("read");
  }
  async remove() {
    this.throw_not_implemented("remove");
  }
  // HELPER METHODS
  get data() {
    return this.item.data;
  }
  // async create_hash(content) { return await create_hash(content); }
  create_hash(content) {
    return murmur_hash_32_alphanumeric(content);
  }
  get settings() {
    return this.item.env.settings.smart_sources[this.adapter_key];
  }
  get adapter_key() {
    return to_snake(this.constructor.name);
  }
  static get adapter_key() {
    return to_snake(this.name);
  }
  get fs() {
    return this.item.collection.fs;
  }
  get env() {
    return this.item.env;
  }
};
function to_snake(str) {
  return str[0].toLowerCase() + str.slice(1).replace(/([A-Z])/g, "_$1").toLowerCase();
}

// node_modules/obsidian-smart-env/node_modules/smart-blocks/parsers/markdown.js
function parse_markdown_blocks(markdown, opts = {}) {
  const { start_index = 1, line_keys = false } = opts;
  const lines = markdown.split("\n");
  const result = {};
  const heading_stack = [];
  const heading_lines = {};
  const heading_counts = {};
  const sub_block_counts = {};
  const subheading_counts = {};
  let current_list_item = null;
  let current_content_block = null;
  let in_frontmatter = false;
  let frontmatter_started = false;
  const root_heading_key = "#";
  let in_code_block = false;
  sub_block_counts[root_heading_key] = 0;
  for (let i = 0; i < lines.length; i++) {
    const line_number = i + start_index;
    const line = lines[i];
    const trimmed_line = line.trim();
    if (trimmed_line === "---") {
      if (!frontmatter_started) {
        frontmatter_started = true;
        in_frontmatter = true;
        heading_lines["#---frontmatter---"] = [line_number, null];
        continue;
      } else if (in_frontmatter) {
        in_frontmatter = false;
        heading_lines["#---frontmatter---"][1] = line_number;
        continue;
      }
    }
    if (in_frontmatter) {
      continue;
    }
    if (trimmed_line.startsWith("```")) {
      in_code_block = !in_code_block;
      if (!current_content_block) {
        const parent_key = heading_stack.length > 0 ? heading_stack[heading_stack.length - 1].key : root_heading_key;
        if (parent_key === root_heading_key && !heading_lines[root_heading_key]) {
          heading_lines[root_heading_key] = [line_number, null];
        }
        if (parent_key === root_heading_key) {
          current_content_block = { key: root_heading_key, start_line: line_number };
          if (heading_lines[root_heading_key][1] === null || heading_lines[root_heading_key][1] < line_number) {
            heading_lines[root_heading_key][1] = null;
          }
        } else {
          if (sub_block_counts[parent_key] === void 0) {
            sub_block_counts[parent_key] = 0;
          }
          sub_block_counts[parent_key] += 1;
          const n = sub_block_counts[parent_key];
          const key = `${parent_key}#{${n}}`;
          heading_lines[key] = [line_number, null];
          current_content_block = { key, start_line: line_number };
        }
      }
      continue;
    }
    const heading_match = trimmed_line.match(/^(#{1,6})\s*(.+)$/);
    if (heading_match && !in_code_block) {
      const level = heading_match[1].length;
      let title = heading_match[2].trim();
      while (heading_stack.length > 0 && heading_stack[heading_stack.length - 1].level >= level) {
        const finished_heading = heading_stack.pop();
        if (heading_lines[finished_heading.key][1] === null) {
          heading_lines[finished_heading.key][1] = line_number - 1;
        }
      }
      if (heading_stack.length === 0 && heading_lines[root_heading_key] && heading_lines[root_heading_key][1] === null) {
        heading_lines[root_heading_key][1] = line_number - 1;
      }
      if (current_content_block) {
        if (heading_lines[current_content_block.key][1] === null) {
          heading_lines[current_content_block.key][1] = line_number - 1;
        }
        current_content_block = null;
      }
      if (current_list_item) {
        if (heading_lines[current_list_item.key][1] === null) {
          heading_lines[current_list_item.key][1] = line_number - 1;
        }
        current_list_item = null;
      }
      let parent_key = "";
      let parent_level = 0;
      if (heading_stack.length > 0) {
        parent_key = heading_stack[heading_stack.length - 1].key;
        parent_level = heading_stack[heading_stack.length - 1].level;
      } else {
        parent_key = "";
        parent_level = 0;
      }
      if (heading_stack.length === 0) {
        heading_counts[title] = (heading_counts[title] || 0) + 1;
        if (heading_counts[title] > 1) {
          title += `[${heading_counts[title]}]`;
        }
      } else {
        if (!subheading_counts[parent_key]) {
          subheading_counts[parent_key] = {};
        }
        subheading_counts[parent_key][title] = (subheading_counts[parent_key][title] || 0) + 1;
        const count = subheading_counts[parent_key][title];
        if (count > 1) {
          title += `#{${count}}`;
        }
      }
      const level_diff = level - parent_level;
      const hashes = "#".repeat(level_diff);
      const key = parent_key + hashes + title;
      heading_lines[key] = [line_number, null];
      sub_block_counts[key] = 0;
      heading_stack.push({ level, title, key });
      continue;
    }
    const list_match = line.match(/^(\s*)([-*]|\d+\.) (.+)$/);
    if (list_match && !in_code_block) {
      const indentation = list_match[1].length;
      if (indentation === 0) {
        if (current_list_item) {
          if (heading_lines[current_list_item.key][1] === null) {
            heading_lines[current_list_item.key][1] = line_number - 1;
          }
          current_list_item = null;
        }
        if (current_content_block && current_content_block.key !== root_heading_key) {
          if (heading_lines[current_content_block.key][1] === null) {
            heading_lines[current_content_block.key][1] = line_number - 1;
          }
          current_content_block = null;
        }
        let parent_key = heading_stack.length > 0 ? heading_stack[heading_stack.length - 1].key : root_heading_key;
        if (parent_key === root_heading_key && !heading_lines[root_heading_key]) {
          heading_lines[root_heading_key] = [line_number, null];
        }
        if (sub_block_counts[parent_key] === void 0) {
          sub_block_counts[parent_key] = 0;
        }
        sub_block_counts[parent_key] += 1;
        const n = sub_block_counts[parent_key];
        let key;
        if (line_keys) {
          const words = get_longest_words_in_order(list_match[3], 10);
          key = `${parent_key}#${words}`;
        } else {
          key = `${parent_key}#{${n}}`;
        }
        heading_lines[key] = [line_number, null];
        current_list_item = { key, start_line: line_number };
        continue;
      }
      if (current_list_item) {
        continue;
      }
    }
    if (trimmed_line === "") {
      continue;
    }
    if (!current_content_block) {
      if (current_list_item) {
        if (heading_lines[current_list_item.key][1] === null) {
          heading_lines[current_list_item.key][1] = line_number - 1;
        }
        current_list_item = null;
      }
      let parent_key = heading_stack.length > 0 ? heading_stack[heading_stack.length - 1].key : root_heading_key;
      if (parent_key === root_heading_key) {
        if (!heading_lines[root_heading_key]) {
          heading_lines[root_heading_key] = [line_number, null];
        }
        if (heading_lines[root_heading_key][1] === null || heading_lines[root_heading_key][1] < line_number) {
          heading_lines[root_heading_key][1] = null;
        }
        current_content_block = { key: root_heading_key, start_line: line_number };
      } else {
        if (sub_block_counts[parent_key] === void 0) {
          sub_block_counts[parent_key] = 0;
        }
        sub_block_counts[parent_key] += 1;
        const n = sub_block_counts[parent_key];
        const key = `${parent_key}#{${n}}`;
        heading_lines[key] = [line_number, null];
        current_content_block = { key, start_line: line_number };
      }
    }
  }
  const total_lines = lines.length;
  while (heading_stack.length > 0) {
    const finished_heading = heading_stack.pop();
    if (heading_lines[finished_heading.key][1] === null) {
      heading_lines[finished_heading.key][1] = total_lines + start_index - 1;
    }
  }
  if (current_list_item) {
    if (heading_lines[current_list_item.key][1] === null) {
      heading_lines[current_list_item.key][1] = total_lines + start_index - 1;
    }
    current_list_item = null;
  }
  if (current_content_block) {
    if (heading_lines[current_content_block.key][1] === null) {
      heading_lines[current_content_block.key][1] = total_lines + start_index - 1;
    }
    current_content_block = null;
  }
  if (heading_lines[root_heading_key] && heading_lines[root_heading_key][1] === null) {
    heading_lines[root_heading_key][1] = total_lines + start_index - 1;
  }
  for (const key in heading_lines) {
    result[key] = heading_lines[key];
  }
  return result;
}
function get_longest_words_in_order(line, n = 3) {
  const words = line.split(/\s+/).sort((a, b) => b.length - a.length).slice(0, n);
  return words.sort((a, b) => line.indexOf(a) - line.indexOf(b)).join(" ");
}

// node_modules/obsidian-smart-env/node_modules/smart-sources/adapters/_file.js
var FileSourceContentAdapter = class extends SourceContentAdapter {
  static async init_items(collection) {
    if (collection.fs_items_initialized) return;
    collection._fs = null;
    await collection.fs.init();
    await collection.init_fs();
    for (const file of Object.values(collection.fs.files)) {
      const item = collection.init_file_path(file.path);
      if (item) item.init_file_mtime = file.stat.mtime;
    }
    collection.fs_items_initialized = Date.now();
  }
  /**
   * @name fs
   * @type {Object}
   * @readonly
   * @description
   * Access the file system interface used by this adapter. Typically derived
   * from `this.item.collection.fs`.
   */
  get fs() {
    return this.item.collection.fs;
  }
  /**
   * @name file_path
   * @type {string}
   * @readonly
   * @description
   * The file path on disk corresponding to the source. Used for read/write operations.
   */
  get file_path() {
    return this.item.file_path;
  }
  /**
   * @async
   * @method create
   * @param {string|null} [content=null] Initial content for the new file.
   * @description
   * Create a new file on disk. If content is not provided, attempts to use
   * `this.item.data.content` as fallback.
   */
  async create(content = null) {
    if (!content) content = this.item.data.content || "";
    await this.fs.write(this.file_path, content);
  }
  /**
   * @async
   * @method update
   * @param {string} content The full new content to write to the file.
   * @description
   * Overwrite the entire file content on disk.
   */
  async update(content) {
    await this.fs.write(this.file_path, content);
  }
  /**
   * @async
   * @method read
   * @returns {Promise<string>} The content of the file.
   * @description
   * Read the file content from disk. Updates `last_read` hash and timestamp on the entity’s data.
   * If file is large or special handling is needed, override this method.
   */
  async read() {
    const content = await this.fs.read(this.file_path);
    this.data.last_read = {
      hash: this.create_hash(content || ""),
      at: Date.now()
    };
    return content;
  }
  /**
   * @async
   * @method remove
   * @returns {Promise<void>}
   * @description
   * Delete the file from disk. After removal, the source item should also be deleted or updated accordingly.
   */
  async remove() {
    await this.fs.remove(this.file_path);
  }
  async move_to(move_to_ref) {
    if (!move_to_ref) {
      throw new Error("Invalid entity reference for move_to operation");
    }
    const move_content = await this.read();
    let has_existing = false;
    if (typeof move_to_ref === "string") {
      const existing = this.item.collection.get(move_to_ref);
      if (existing) {
        move_to_ref = existing;
        has_existing = true;
      }
    } else {
      has_existing = true;
    }
    if (has_existing) {
      await move_to_ref.append(move_content);
    } else {
      move_to_ref = await this.item.collection.create(move_to_ref, move_content);
    }
    if (this.item.key !== move_to_ref.key) {
      await this.remove();
      this.item.delete();
    } else {
      console.log(`did not delete ${this.item.key} because it was moved to ${move_to_ref.key}`);
    }
    return move_to_ref;
  }
  /**
   * TRANSFERRED FROM markdown.js (2024-12-13)
   * TODO NEEDS REVIEW/REFACTOR
   */
  async move_to_v1(entity_ref) {
    const new_path = typeof entity_ref === "string" ? entity_ref : entity_ref.key;
    if (!new_path) {
      throw new Error("Invalid entity reference for move_to operation");
    }
    const current_content = await this.read();
    const [target_source_key, ...headings] = new_path.split("#");
    const target_source = this.item.collection.get(target_source_key);
    if (headings.length > 0) {
      const new_headings_content = this.construct_headings(headings);
      const new_content = `${new_headings_content}
${current_content}`;
      await this._update(new_content);
    }
    if (target_source) {
      await this.merge(current_content, { mode: "append_blocks" });
    } else {
      await this.rename_and_import(target_source_key, current_content);
    }
    if (this.item.key !== target_source_key) await this.remove();
  }
  construct_headings(headings) {
    return headings.map((heading, i) => `${"#".repeat(i + 1)} ${heading}`).join("\n");
  }
  async rename_and_import(target_source_key, content) {
    await this.fs.rename(this.file_path, target_source_key);
    const new_source = await this.item.collection.create_or_update({ path: target_source_key, content });
    await new_source.import();
  }
  /**
   * Merge content into the source
   * @param {string} content - The content to merge into the source
   * @param {Object} opts - Options for the merge operation
   * @param {string} opts.mode - The mode to use for the merge operation. Defaults to 'append_blocks' (may also be 'replace_blocks')
   */
  async merge(content, opts = {}) {
    const { mode = "append_blocks" } = opts;
    const blocks_obj = parse_markdown_blocks(content);
    if (typeof blocks_obj !== "object" || Array.isArray(blocks_obj)) {
      console.warn("merge error: Expected an object from parse_markdown_blocks, but received:", blocks_obj);
      throw new Error("merge error: parse_markdown_blocks did not return an object as expected.");
    }
    const { new_blocks, new_with_parent_blocks, changed_blocks, same_blocks } = await this.get_changes(blocks_obj, content);
    for (const block of new_blocks) {
      await this.append(block.content);
    }
    for (const block of new_with_parent_blocks) {
      const parent_block = this.item.block_collection.get(block.parent_key);
      await parent_block.append(block.content);
    }
    for (const block of changed_blocks) {
      const changed_block = this.item.block_collection.get(block.key);
      if (mode === "replace_blocks") {
        await changed_block.update(block.content);
      } else {
        await changed_block.append(block.content);
      }
    }
  }
  async get_changes(blocks_obj, content) {
    const new_blocks = [];
    const new_with_parent_blocks = [];
    const changed_blocks = [];
    const same_blocks = [];
    const existing_blocks = this.source.data.blocks || {};
    for (const [sub_key, line_range] of Object.entries(blocks_obj)) {
      const has_existing = !!existing_blocks[sub_key];
      const block_key = `${this.source.key}${sub_key}`;
      const block_content = get_line_range(content, line_range[0], line_range[1]);
      if (!has_existing) {
        new_blocks.push({
          key: block_key,
          state: "new",
          content: block_content
        });
        continue;
      }
      let has_parent;
      let headings = sub_key.split("#");
      let parent_key;
      while (!has_parent && headings.length > 0) {
        headings.pop();
        parent_key = headings.join("#");
        has_parent = !!existing_blocks[parent_key];
      }
      if (has_parent) {
        new_with_parent_blocks.push({
          key: block_key,
          parent_key: `${this.source.key}${parent_key}`,
          state: "new",
          content: block_content
        });
        continue;
      }
      const block = this.item.block_collection.get(block_key);
      const content_hash = await this.create_hash(block_content);
      if (content_hash !== block.last_read?.hash) {
        changed_blocks.push({
          key: block_key,
          state: "changed",
          content: block_content
        });
        continue;
      }
      same_blocks.push({
        key: block_key,
        state: "same",
        content: block_content
      });
    }
    return {
      new_blocks,
      new_with_parent_blocks,
      changed_blocks,
      same_blocks
    };
  }
  /**
   * Append new content to the source file, placing it at the end of the file.
   * @async
   * @param {string} content - The content to append.
   * @returns {Promise<void>}
   */
  async append(content) {
    const current_content = await this.read();
    const new_content = [
      current_content,
      "",
      content
    ].join("\n").trim();
    await this.update(new_content);
  }
  get size() {
    return this.item.file?.stat?.size || 0;
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-sources/utils/get_markdown_links.js
function get_markdown_links(content) {
  const result = [];
  const markdown_link_re = /\[([^\]]+?)\]\(([^)]+?)\)/g;
  const wikilink_re = /\[\[([^\|\]]+?)(?:\|([^\]]+?))?\]\]/g;
  const normalise_target = (raw) => {
    const trimmed = raw.trim();
    if (/^[a-zA-Z][\w+\-.]*:\/\//.test(trimmed)) return trimmed;
    try {
      return decodeURIComponent(trimmed);
    } catch (_) {
      return trimmed.replace(/%20/gi, " ");
    }
  };
  let m;
  while ((m = markdown_link_re.exec(content)) !== null) {
    const title = m[1];
    const target = normalise_target(m[2]);
    const line_no = content.slice(0, m.index).split("\n").length;
    result.push({ title, target, line: line_no });
  }
  while ((m = wikilink_re.exec(content)) !== null) {
    const target_raw = m[1];
    const title = m[2] || target_raw;
    const target = normalise_target(target_raw);
    const line_no = content.slice(0, m.index).split("\n").length;
    result.push({ title, target, line: line_no });
  }
  return result.sort(
    (a, b) => a.line - b.line || a.target.localeCompare(b.target)
  );
}

// node_modules/obsidian-smart-env/node_modules/smart-sources/utils/parse_frontmatter.js
function parse_value(raw_value) {
  const trimmed = raw_value.trim();
  if (trimmed.startsWith('"') && trimmed.endsWith('"') || trimmed.startsWith("'") && trimmed.endsWith("'")) {
    return trimmed.slice(1, -1);
  }
  const lower = trimmed.toLowerCase();
  if (lower === "true") return true;
  if (lower === "false") return false;
  if (!isNaN(trimmed) && trimmed !== "") {
    return Number(trimmed);
  }
  return trimmed;
}
function parse_yaml_block(yaml_block) {
  const lines = yaml_block.split(/\r?\n/);
  const data = {};
  let i = 0;
  while (i < lines.length) {
    const line = lines[i];
    i++;
    if (!line.trim() || line.trim().startsWith("#")) {
      continue;
    }
    const match = line.match(/^([^:]+)\s*:\s*(.*)$/);
    if (!match) {
      continue;
    }
    const key = match[1].trim();
    let value = match[2].trim();
    if (value === ">" || value === "|") {
      const multiline_lines = [];
      while (i < lines.length) {
        const next_line = lines[i];
        if (!/^\s+/.test(next_line) || next_line.trim().startsWith("#")) {
          break;
        }
        multiline_lines.push(next_line.replace(/^\s+/, ""));
        i++;
      }
      const joined = multiline_lines.join("\n");
      data[key] = parse_value(joined);
    } else if (value === "") {
      const arr = [];
      let array_consumed = false;
      while (i < lines.length) {
        const next_line = lines[i];
        if (!next_line.trim().startsWith("- ")) {
          break;
        }
        const item_value = next_line.trim().slice(2);
        arr.push(parse_value(item_value));
        i++;
        array_consumed = true;
      }
      if (array_consumed) {
        data[key] = arr;
      } else {
        data[key] = "";
      }
    } else {
      data[key] = parse_value(value);
    }
  }
  return data;
}
function parse_frontmatter(content) {
  if (!content.startsWith("---")) {
    return { frontmatter: {}, body: content };
  }
  const lines = content.split(/\r?\n/);
  let end_index = -1;
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].trim() === "---") {
      end_index = i;
      break;
    }
  }
  if (end_index === -1) {
    return { frontmatter: {}, body: content };
  }
  const frontmatter_lines = lines.slice(1, end_index);
  const frontmatter_block = frontmatter_lines.join("\n");
  const frontmatter = parse_yaml_block(frontmatter_block);
  const body_lines = lines.slice(end_index + 1);
  const body = body_lines.join("\n");
  return { frontmatter, body };
}

// node_modules/obsidian-smart-env/node_modules/smart-sources/adapters/markdown_source.js
var MarkdownSourceContentAdapter = class extends FileSourceContentAdapter {
  static extensions = ["md", "txt"];
  /**
   * Import the source file content, parse blocks and links, and update `item.data`.
   * @async
   * @returns {Promise<void>}
   */
  async import() {
    if (!this.can_import) return;
    if (!this.outdated) {
      this.item.blocks.forEach((block) => {
        if (!block.vec) block.queue_embed();
      });
      return;
    }
    const content = await this.read();
    if (!content) {
      return;
    }
    if (!this.item.vec) {
      this.item.data.last_import = null;
    }
    if (this.data.last_import?.hash === this.data.last_read?.hash) {
      if (this.data.blocks) return;
    }
    this.data.blocks = null;
    await this.parse_content(content);
    await this.item.parse_content(content);
    const { mtime, size } = this.item.file.stat;
    this.data.last_import = {
      mtime,
      size,
      at: Date.now(),
      hash: this.data.last_read.hash
    };
    this.item.loaded_at = Date.now();
    this.item.queue_save();
    if (this.item.should_embed) this.item.queue_embed();
  }
  // // WIP: move block parsing here
  // async read() {
  //   const current_last_read_hash = this.data.last_read?.hash;
  //   const content = await super.read();
  //   if(!content) return console.warn(`MarkdownSourceContentAdapter: Skipping missing-file: ${this.file_path}`);
  //   if(current_last_read_hash === this.data.last_read?.hash) return content;
  //   const blocks = parse_markdown_blocks(content);
  //   this.handle_excluded_headings(blocks);
  // }
  // Runs before configured content_parsers (for example, templates uses outlinks)
  async parse_content(content) {
    const outlinks = await this.get_links(content);
    this.data.outlinks = outlinks;
    const metadata = await this.get_metadata(content);
    this.data.metadata = metadata;
  }
  async get_links(content = null) {
    if (!content) content = await this.read();
    if (!content) return;
    return get_markdown_links(content);
  }
  async get_metadata(content = null) {
    if (!content) content = await this.read();
    if (!content) return;
    const { frontmatter } = parse_frontmatter(content);
    return frontmatter;
  }
  // Erroneous reasons to skip import (logs to console)
  get can_import() {
    if (!this.item.file) {
      console.warn(`MarkdownSourceContentAdapter: Skipping missing-file: ${this.file_path}`);
      return false;
    }
    if (this.item.size > (this.settings?.max_import_size || 3e5)) {
      console.warn(`MarkdownSourceContentAdapter: Skipping large file: ${this.file_path}`);
      return false;
    }
    return true;
  }
  /**
   * @deprecated use outdated instead
   */
  get should_import() {
    return this.outdated;
  }
  get outdated() {
    try {
      if (!this.data.last_import) {
        if (this.data.mtime && this.data.size && this.data.hash) {
          this.data.last_import = {
            mtime: this.data.mtime,
            size: this.data.size,
            at: Date.now(),
            hash: this.data.hash
          };
          delete this.data.mtime;
          delete this.data.size;
          delete this.data.hash;
        } else {
          return true;
        }
      }
      if (this.data.last_read.at > this.data.last_import.at) {
        if (this.data.last_import?.hash !== this.data.last_read?.hash) return true;
      }
      if (this.data.last_import.mtime < this.item.mtime) {
        if (!this.data.last_import.size) return true;
        const size_diff = Math.abs(this.data.last_import.size - this.item.size);
        const size_diff_ratio = size_diff / (this.data.last_import.size || 1);
        if (size_diff_ratio > 0.01) return true;
      }
      return false;
    } catch (e) {
      console.warn(`MarkdownSourceContentAdapter: error getting should_import for ${this.file_path}: ${e}`);
      return true;
    }
  }
};

// node_modules/obsidian-smart-env/adapters/smart-sources/obsidian_markdown.js
var import_obsidian2 = require("obsidian");
var ObsidianMarkdownSourceContentAdapter = class extends MarkdownSourceContentAdapter {
  /**
   * Returns the frontmatter metadata from Obsidian's metadataCache.
   * @async
   * @returns {Promise<Object>} Frontmatter data if available, otherwise undefined.
   */
  async get_metadata() {
    const app2 = this.item.env.main.app;
    const { frontmatter } = app2.metadataCache.getFileCache(this.item.file) || {};
    return frontmatter;
  }
  /**
   * Reads the file content. If opts.render_output is true, attempts to use
   * Obsidian's MarkdownRenderer to render the file to HTML, then convert it
   * back to markdown via htmlToMarkdown.
   * @async
   * @param {Object} [opts={}] - Options for reading.
   * @param {boolean} [opts.render_output=false] - If true, render MD -> HTML -> MD.
   * @returns {Promise<string>} The file content (possibly rendered).
   */
  async read(opts = {}) {
    const content = await super.read(opts);
    if (!opts.render_output) {
      return content;
    }
    const app2 = this.item.env.main.app;
    if (!app2 || !import_obsidian2.MarkdownRenderer || !import_obsidian2.htmlToMarkdown) {
      console.warn("Obsidian environment not found; cannot render markdown.");
      return content;
    }
    const container = document.createElement("div");
    await import_obsidian2.MarkdownRenderer.render(app2, content, container, this.item.path, new import_obsidian2.Component());
    let last_html = container.innerHTML;
    const max_wait = 1e4;
    let wait_time = 0;
    let conseq_same = 0;
    let changed = true;
    while (conseq_same < 7) {
      await new Promise((resolve) => setTimeout(resolve, 100));
      changed = last_html !== container.innerHTML;
      last_html = container.innerHTML;
      if (!changed) conseq_same++;
      else conseq_same = 0;
      wait_time += 100;
      if (wait_time > max_wait) {
        console.warn("ObsidianMarkdownSourceContentAdapter: Timeout waiting for markdown to render.");
        break;
      }
    }
    const newMd = (0, import_obsidian2.htmlToMarkdown)(container);
    return newMd;
  }
};

// node_modules/obsidian-smart-env/adapters/smart-sources/excalidraw.js
var ExcalidrawSourceContentAdapter = class extends ObsidianMarkdownSourceContentAdapter {
  static extensions = ["excalidraw.md"];
  is_media = true;
  // Excalidraw files are treated as media for rendering
  async read(opts = {}) {
    const full_content = await super.read(opts);
    const BEGIN_LINE_MATCHER = "# Text Elements";
    const END_LINE_MATCHER = "# Drawing";
    const text_elements_start = full_content.indexOf(BEGIN_LINE_MATCHER);
    const drawing_lines_start = full_content.indexOf(END_LINE_MATCHER);
    if (text_elements_start === -1 || drawing_lines_start === -1) {
      console.warn("Excalidraw file does not contain expected sections. File: " + this.item.key);
      this.item.data.last_read.size = 0;
      return "";
    }
    const text_content = full_content.slice(text_elements_start + BEGIN_LINE_MATCHER.length, drawing_lines_start).trim();
    const stripped_refs = text_content.split("\n").map((line) => {
      if (line.trim() === "%%") return "";
      if (line.trim() === "#") return "";
      return line.replace(/\^[a-z0-9]+$/i, "").trim();
    }).filter(Boolean).join("\n");
    this.item.data.last_read.size = stripped_refs.length;
    return stripped_refs;
  }
  get size() {
    if (this.item.data?.last_read?.size) {
      return this.item.data.last_read.size;
    }
    return this.file?.stat?.size || 0;
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-blocks/smart_block.js
var SmartBlock = class extends SmartEntity {
  /**
   * Provides default values for a SmartBlock instance.
   * @static
   * @readonly
   * @returns {Object} The default values.
   */
  static get defaults() {
    return {
      data: {
        text: null,
        length: 0,
        last_read: {
          hash: null,
          at: 0
        }
      },
      _embed_input: ""
      // Stored temporarily
    };
  }
  get block_adapter() {
    if (!this._block_adapter) {
      this._block_adapter = new this.collection.opts.block_adapters.md(this);
    }
    return this._block_adapter;
  }
  /**
   * Initializes the SmartBlock instance by queuing an embed if embedding is enabled.
   * @returns {void}
   */
  init() {
    if (this.settings.embed_blocks) super.init();
  }
  /**
   * Queues the entity for embedding.
   * @returns {void}
   */
  queue_embed() {
    this._queue_embed = this.should_embed;
    this.source?.queue_embed();
  }
  /**
   * Queues the block for import via the source.
   * @returns {void}
   */
  queue_import() {
    this.source?.queue_import();
  }
  /**
   * Updates the block's data, clearing embeddings if necessary and preparing embed input.
   * @param {Object} data - The new data to merge into the block.
   * @returns {boolean} `true` if data was updated successfully.
   */
  update_data(data) {
    if (this.should_clear_embeddings(data)) {
      this.data.embeddings = {};
    }
    super.update_data(data);
    return true;
  }
  /**
   * Determines whether to clear embeddings based on the new data.
   * @param {Object} data - The new data to evaluate.
   * @returns {boolean} `true` if embeddings should be cleared, `false` otherwise.
   */
  should_clear_embeddings(data) {
    if (this.is_new) return true;
    if (this.embed_model && this.vec?.length !== this.embed_model.model_config.dims) return true;
    return false;
  }
  /**
   * Prepares the embed input for the SmartBlock by reading content and generating a hash.
   * @async
   * @returns {Promise<string|false>} The embed input string or `false` if already embedded.
   */
  async get_embed_input(content = null) {
    if (typeof this._embed_input !== "string" || !this._embed_input.length) {
      if (!content) content = await this.read();
      this._embed_input = this.breadcrumbs + "\n" + content;
    }
    return this._embed_input;
  }
  // CRUD
  /**
   * @method read
   * @description Reads the block content by delegating to the block adapter.
   * @async
   * @returns {Promise<string>} The block content.
   */
  async read() {
    try {
      return await this.block_adapter.read();
    } catch (e) {
      if (e.message.includes("BLOCK NOT FOUND")) {
        return 'BLOCK NOT FOUND (run "Prune" to remove)';
      } else {
        throw e;
      }
    }
  }
  /**
   * @method append
   * @description Appends content to this block by delegating to the block adapter.
   * @async
   * @param {string} content
   * @returns {Promise<void>}
   */
  async append(content) {
    await this.block_adapter.append(content);
    this.queue_save();
  }
  /**
   * @method update
   * @description Updates the block content by delegating to the block adapter.
   * @async
   * @param {string} new_block_content
   * @param {Object} [opts={}]
   * @returns {Promise<void>}
   */
  async update(new_block_content, opts = {}) {
    await this.block_adapter.update(new_block_content, opts);
    this.queue_save();
  }
  /**
   * @method remove
   * @description Removes the block by delegating to the block adapter.
   * @async
   * @returns {Promise<void>}
   */
  async remove() {
    await this.block_adapter.remove();
    this.queue_save();
  }
  /**
   * @method move_to
   * @description Moves the block to another location by delegating to the block adapter.
   * @async
   * @param {string} to_key
   * @returns {Promise<void>}
   */
  async move_to(to_key) {
    await this.block_adapter.move_to(to_key);
    this.queue_save();
  }
  // Getters
  /**
   * Retrieves the breadcrumbs representing the block's path within the source.
   * @readonly
   * @returns {string} The breadcrumbs string.
   */
  get breadcrumbs() {
    return this.key.split("/").join(" > ").split("#").slice(0, -1).join(" > ").replace(".md", "");
  }
  /**
   * Determines if the block is excluded from embedding based on headings.
   * @readonly
   * @returns {boolean} `true` if excluded, `false` otherwise.
   */
  get excluded() {
    const block_headings = this.path.split("#").slice(1);
    if (this.source_collection.excluded_headings.some((heading) => block_headings.includes(heading))) return true;
    return this.source?.excluded;
  }
  /**
   * Retrieves the file path of the SmartSource associated with the block.
   * @readonly
   * @returns {string} The file path.
   */
  get file_path() {
    return this.source?.file_path;
  }
  /**
   * Retrieves the file type of the SmartSource associated with the block.
   * @readonly
   * @returns {string} The file type.
   */
  get file_type() {
    return this.source.file_type;
  }
  /**
   * Retrieves the folder path of the block.
   * @readonly
   * @returns {string} The folder path.
   */
  get folder() {
    return this.path.split("/").slice(0, -1).join("/");
  }
  /**
   * Retrieves the embed link for the block.
   * @readonly
   * @returns {string} The embed link.
   */
  get embed_link() {
    return `![[${this.link}]]`;
  }
  /**
   * Determines if the block has valid line range information.
   * @readonly
   * @returns {boolean} `true` if the block has both start and end lines, `false` otherwise.
   */
  get has_lines() {
    return this.lines && this.lines.length === 2;
  }
  /**
   * Determines if the entity is a block based on its key.
   * @readonly
   * @returns {boolean} `true` if it's a block, `false` otherwise.
   */
  get is_block() {
    return this.key.includes("#");
  }
  /**
   * Determines if the block is gone (i.e., the source file or block data no longer exists).
   * @readonly
   * @returns {boolean} `true` if gone, `false` otherwise.
   */
  get is_gone() {
    if (!this.source?.file) return true;
    if (!this.source?.data?.blocks?.[this.sub_key]) return true;
    return false;
  }
  get last_read() {
    return this.data.last_read;
  }
  /**
   * Retrieves the sub-key of the block.
   * @readonly
   * @returns {string} The sub-key.
   */
  get sub_key() {
    return "#" + this.key.split("#").slice(1).join("#");
  }
  /**
   * Retrieves the lines range of the block.
   * @readonly
   * @returns {Array<number>|undefined} An array containing the start and end lines or `undefined` if not set.
   */
  // get lines() { return this.source?.data?.blocks?.[this.sub_key]; }
  get lines() {
    return this.data.lines;
  }
  /**
   * Retrieves the starting line number of the block.
   * @readonly
   * @returns {number|undefined} The starting line number or `undefined` if not set.
   */
  get line_start() {
    return this.lines?.[0];
  }
  /**
   * Retrieves the ending line number of the block.
   * @readonly
   * @returns {number|undefined} The ending line number or `undefined` if not set.
   */
  get line_end() {
    return this.lines?.[1];
  }
  /**
   * Retrieves the link associated with the block, handling page numbers if present.
   * @readonly
   * @returns {string} The block link.
   */
  get link() {
    if (/^.*page\s*(\d+).*$/i.test(this.sub_key)) {
      const number = this.sub_key.match(/^.*page\s*(\d+).*$/i)[1];
      return `${this.source.path}#page=${number}`;
    } else {
      return this.source?.path || "MISSING SOURCE";
    }
  }
  /**
   * Retrieves the display name of the block.
   * @readonly
   * @returns {string} The display name.
   */
  get name() {
    const source_name = this.source?.name;
    if (!source_name) return "MISSING SOURCE";
    const block_path_parts = this.key.split("#").slice(1);
    if (this.should_show_full_path) return [source_name, ...block_path_parts].join(" > ");
    if (block_path_parts[block_path_parts.length - 1][0] === "{") block_path_parts.pop();
    return [source_name, block_path_parts.pop()].join(" > ");
  }
  // uses data.lines to get next block
  get next_block() {
    if (!this.data.lines) return null;
    const next_line = this.data.lines[1] + 1;
    return this.source.blocks?.find((block) => next_line === block.data?.lines?.[0]);
  }
  /**
   * Retrieves the paths of outlinks from the block.
   * @readonly
   * @returns {Array<string>} An array of outlink paths.
   */
  get outlinks() {
    return this.source.outlinks;
  }
  /**
   * Retrieves the path of the SmartBlock.
   * @readonly
   * @returns {string} The path of the SmartBlock.
   */
  get path() {
    return this.key;
  }
  /**
   * Determines if the block should be embedded based on its coverage and size.
   * @readonly
   * @returns {boolean} `true` if it should be embedded, `false` otherwise.
   */
  get should_embed() {
    try {
      if (this.settings?.min_chars && this.size < this.settings.min_chars) return false;
      const match_line_start = this.line_start + 1;
      const match_line_end = this.line_end;
      const { has_line_start, has_line_end } = Object.entries(this.source?.data?.blocks || {}).reduce((acc, [key, range]) => {
        if (!key.startsWith(this.sub_key + "#")) return acc;
        if (range[0] === match_line_start) acc.has_line_start = key;
        if (range[1] === match_line_end) acc.has_line_end = key;
        return acc;
      }, { has_line_start: null, has_line_end: null });
      if (has_line_start && has_line_end) {
        const start_block = this.collection.get(this.source_key + has_line_start);
        if (start_block?.should_embed) {
          const end_block = this.collection.get(this.source_key + has_line_end);
          if (end_block?.should_embed) return false;
        }
      }
      return true;
    } catch (e) {
      console.error(e, e.stack);
      console.error(`Error getting should_embed for ${this.key}: ` + JSON.stringify(e || {}, null, 2));
    }
  }
  /**
   * Retrieves the size of the SmartBlock.
   * @readonly
   * @returns {number} The size of the SmartBlock.
   */
  get size() {
    return this.data.size;
  }
  /**
   * Retrieves the SmartSource associated with the block.
   * @readonly
   * @returns {SmartSource} The associated SmartSource instance.
   */
  get source() {
    return this.source_collection.get(this.source_key);
  }
  /**
   * Retrieves the SmartSources collection instance.
   * @readonly
   * @returns {SmartSources} The SmartSources collection.
   */
  get source_collection() {
    return this.env.smart_sources;
  }
  get source_key() {
    return this.key.split("#")[0];
  }
  get sub_blocks() {
    return this.source?.blocks?.filter((block) => block.key.startsWith(this.key + "#") && block.line_start > this.line_start && block.line_end <= this.line_end) || [];
  }
  // source dependent
  get excluded_lines() {
    return this.source.excluded_lines;
  }
  get file() {
    return this.source.file;
  }
  get is_media() {
    return this.source.is_media;
  }
  get mtime() {
    return this.source.mtime;
  }
  // DEPRECATED
  /**
   * @deprecated Use `source` instead.
   * @readonly
   * @returns {SmartSource} The associated SmartSource instance.
   */
  get note() {
    return this.source;
  }
  /**
   * @deprecated Use `source.key` instead.
   * @readonly
   * @returns {string} The source key.
   */
  get note_key() {
    return this.key.split("#")[0];
  }
};
var smart_block_default = {
  class: SmartBlock,
  actions: {
    find_connections
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-blocks/smart_blocks.js
var SmartBlocks = class extends SmartEntities {
  /**
   * Initializes the SmartBlocks instance. Currently muted as processing is handled by SmartSources.
   * @returns {void}
   */
  init() {
  }
  get fs() {
    return this.env.smart_sources.fs;
  }
  /**
   * Retrieves the embedding model associated with the SmartSources collection.
   * @readonly
   * @returns {Object|undefined} The embedding model instance or `undefined` if not set.
   */
  get embed_model() {
    return this.source_collection?.embed_model;
  }
  /**
   * Retrieves the embedding model key from the SmartSources collection.
   * @readonly
   * @returns {string|undefined} The embedding model key or `undefined` if not set.
   */
  get embed_model_key() {
    return this.source_collection?.embed_model_key;
  }
  /**
   * Calculates the expected number of blocks based on the SmartSources collection.
   * @readonly
   * @returns {number} The expected count of blocks.
   */
  get expected_blocks_ct() {
    return Object.values(this.source_collection.items).reduce((acc, item) => acc += Object.keys(item.data.blocks || {}).length, 0);
  }
  /**
   * Retrieves the notices system from the environment.
   * @readonly
   * @returns {Object} The notices object.
   */
  get notices() {
    return this.env.smart_connections_plugin?.notices || this.env.main?.notices;
  }
  /**
   * Retrieves the settings configuration for SmartBlocks.
   * @readonly
   * @returns {Object} The settings configuration object.
   */
  get settings_config() {
    return this.process_settings_config({
      "embed_blocks": {
        name: "Utilize Smart Blocks",
        type: "toggle",
        description: "Creates more granular embeddings by splitting sources into smaller chunks. This may improve search results especially for large documents that have well-defined sections.",
        default: true
      },
      ...super.settings_config
    });
  }
  render_settings(container, opts = {}) {
    return this.render_collection_settings(container, opts);
  }
  get data_dir() {
    return "multi";
  }
  /**
   * Retrieves the SmartSources collection instance.
   * @readonly
   * @returns {SmartSources} The SmartSources collection.
   */
  get source_collection() {
    return this.env.smart_sources;
  }
  /**
   * Processes the embed queue. Currently handled by SmartSources, so this method is muted.
   * @async
   * @returns {Promise<void>}
   */
  async process_embed_queue() {
  }
  /**
   * Processes the load queue. Currently muted as processing is handled by SmartSources.
   * @async
   * @returns {Promise<void>}
   */
  async process_load_queue() {
  }
  // TEMP: Methods in sources not implemented in blocks
  /**
   * @async
   * @throws {Error} Throws an error indicating the method is not implemented.
   * @returns {Promise<void>}
   */
  async prune() {
    throw "Not implemented: prune";
  }
  /**
   * @throws {Error} Throws an error indicating the method is not implemented.
   * @returns {void}
   */
  build_links_map() {
    throw "Not implemented: build_links_map";
  }
  /**
   * @async
   * @throws {Error} Throws an error indicating the method is not implemented.
   * @returns {Promise<void>}
   */
  async refresh() {
    throw "Not implemented: refresh";
  }
  /**
   * @async
   * @throws {Error} Throws an error indicating the method is not implemented.
   * @returns {Promise<void>}
   */
  async search() {
    throw "Not implemented: search";
  }
  /**
   * @async
   * @throws {Error} Throws an error indicating the method is not implemented.
   * @returns {Promise<void>}
   */
  async run_refresh() {
    throw "Not implemented: run_refresh";
  }
  /**
   * @async
   * @throws {Error} Throws an error indicating the method is not implemented.
   * @returns {Promise<void>}
   */
  async run_force_refresh() {
    throw "Not implemented: run_force_refresh";
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-blocks/adapters/data/ajson_multi_file.js
var AjsonMultiFileBlocksDataAdapter = class extends AjsonMultiFileCollectionDataAdapter {
  ItemDataAdapter = AjsonMultiFileBlockDataAdapter;
  /**
   * Transforms the item key into a safe filename.
   * Replaces spaces, slashes, and dots with underscores.
   * @returns {string} safe file name
   */
  // get_data_file_name(key) {
  //   return super.get_data_file_name(key.split('#')[0]);
  // }
  get_data_file_name(key) {
    return key.split("#")[0].replace(/[\s\/\.]/g, "_").replace(".md", "");
  }
  /**
   * Process any queued save operations.
   * @async
   * @returns {Promise<void>}
   */
  async process_save_queue() {
    this.collection.show_process_notice("saving_collection");
    const save_queue = Object.values(this.collection.items).filter((item) => item._queue_save);
    console.log(`Saving ${this.collection.collection_key}: ${save_queue.length} items`);
    const time_start = Date.now();
    const save_files = Object.entries(save_queue.reduce((acc, item) => {
      const file_name = this.get_item_data_path(item.key);
      acc[file_name] = acc[file_name] || [];
      acc[file_name].push(item);
      return acc;
    }, {}));
    for (let i = 0; i < save_files.length; i++) {
      const [file_name, items] = save_files[i];
      await this.fs.append(
        file_name,
        items.map((item) => this.get_item_ajson(item)).join("\n") + "\n"
      );
      items.forEach((item) => item._queue_save = false);
    }
    console.log(`Saved ${this.collection.collection_key} in ${Date.now() - time_start}ms`);
    this.collection.clear_process_notice("saving_collection");
  }
  process_load_queue() {
    console.log(`Skipping loading ${this.collection.collection_key}...`);
  }
};
var AjsonMultiFileBlockDataAdapter = class extends AjsonMultiFileItemDataAdapter {
};

// node_modules/obsidian-smart-env/node_modules/smart-blocks/adapters/_adapter.js
var BlockContentAdapter = class {
  /**
   * @constructor
   * @param {Object} item - The SmartBlock instance this adapter operates on.
   * The `item` should at least provide `data` and references to its parent source.
   */
  constructor(item) {
    this.item = item;
  }
  /**
   * @async
   * @method read
   * @abstract
   * @returns {Promise<string>} The content of the block.
   * @throws {Error} If not implemented by subclass.
   */
  async read() {
    throw new Error("Not implemented");
  }
  /**
   * @async
   * @method append
   * @abstract
   * @param {string} content Content to append to the block.
   * @returns {Promise<void>}
   * @throws {Error} If not implemented by subclass.
   */
  async append(content) {
    throw new Error("Not implemented");
  }
  /**
   * @async
   * @method update
   * @abstract
   * @param {string} new_content The new content for the block.
   * @param {Object} [opts={}] Additional update options.
   * @returns {Promise<void>}
   * @throws {Error} If not implemented by subclass.
   */
  async update(new_content, opts = {}) {
    throw new Error("Not implemented");
  }
  /**
   * @async
   * @method remove
   * @abstract
   * @returns {Promise<void>}
   * @throws {Error} If not implemented by subclass.
   */
  async remove() {
    throw new Error("Not implemented");
  }
  /**
   * @async
   * @method move_to
   * @abstract
   * @param {string} to_key The destination key (source or block reference).
   * @returns {Promise<void>}
   * @throws {Error} If not implemented by subclass.
   */
  async move_to(to_key) {
    throw new Error("Not implemented");
  }
  /**
   * @name data
   * @type {Object}
   * @readonly
   * @description Access the block’s data object. Useful for updating metadata like line references or hashes.
   */
  get data() {
    return this.item.data;
  }
  /**
   * @async
   * @method update_last_read
   * @param {string} content The current content of the block.
   * @returns {Promise<void>}
   * @description Update the block’s `last_read` hash and timestamp based on the given content.
   */
  async update_last_read(content) {
    this.data.last_read = {
      hash: this.create_hash(content),
      at: Date.now()
    };
  }
  /**
   * @method create_hash
   * @param {string} content The content to hash.
   * @returns {Promise<string>} The computed hash of the content.
   * @description Hash the block content to detect changes and prevent unnecessary re-embeddings.
   */
  create_hash(content) {
    return murmur_hash_32_alphanumeric(content);
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-sources/utils/get_line_range.js
function get_line_range2(content, start_line, end_line) {
  const lines = content.split("\n");
  return lines.slice(start_line - 1, end_line).join("\n");
}

// node_modules/obsidian-smart-env/node_modules/smart-blocks/adapters/markdown_block.js
var MarkdownBlockContentAdapter = class extends BlockContentAdapter {
  /**
   * Read the content of the block.
   * @async
   * @returns {Promise<string>} The block content as a string.
   * @throws {Error} If the block cannot be found.
   */
  async read() {
    const source_content = await this.item.source?.read();
    if (!source_content) {
      console.warn(`BLOCK NOT FOUND: ${this.item.key} has no source content.`);
      return "";
    }
    const content = this._extract_block(source_content);
    this.update_last_read(content);
    return content;
  }
  /**
   * Append content to the existing block.
   * This method inserts additional lines after the block's end, then re-parses the file to update line references.
   * @async
   * @param {string} content Content to append to the block.
   * @returns {Promise<void>}
   * @throws {Error} If the block cannot be found.
   */
  async append(content) {
    let full_content = await this.item.source.read();
    const { line_start, line_end } = this.item;
    if (!line_start || !line_end) {
      throw new Error(`Cannot append to block ${this.item.key}: invalid line references.`);
    }
    const lines = full_content.split("\n");
    lines.splice(line_end, 0, "", content);
    const updated_content = lines.join("\n");
    await this.item.source._update(updated_content);
    await this._reparse_source();
  }
  /**
   * Update the block with new content, replacing its current lines.
   * @async
   * @param {string} new_content New content for the block.
   * @param {Object} [opts={}] Additional options.
   * @returns {Promise<void>}
   * @throws {Error} If the block cannot be found.
   */
  async update(new_content, opts = {}) {
    let full_content = await this.item.source.read();
    const { line_start, line_end } = this.item;
    if (!line_start || !line_end) {
      throw new Error(`Cannot update block ${this.item.key}: invalid line references.`);
    }
    const lines = full_content.split("\n");
    const updated_lines = [
      ...lines.slice(0, line_start - 1),
      ...new_content.split("\n"),
      ...lines.slice(line_end)
    ];
    const updated_content = updated_lines.join("\n");
    await this.item.source._update(updated_content);
    await this._reparse_source();
  }
  /**
   * Remove the block entirely from the source.
   * @async
   * @returns {Promise<void>}
   * @throws {Error} If the block cannot be found.
   */
  async remove() {
    let full_content = await this.item.source.read();
    const { line_start, line_end } = this.item;
    if (!line_start || !line_end) {
      throw new Error(`Cannot remove block ${this.item.key}: invalid line references.`);
    }
    const lines = full_content.split("\n");
    const updated_lines = [
      ...lines.slice(0, line_start - 1),
      ...lines.slice(line_end)
    ];
    const updated_content = updated_lines.join("\n");
    await this.item.source._update(updated_content);
    await this._reparse_source();
  }
  /**
   * Move the block to a new location (another source or heading).
   * This involves reading the block content, removing it from the current source, and appending it to the target.
   * @async
   * @param {string} to_key The destination path or entity reference.
   * @returns {Promise<void>}
   * @throws {Error} If the block or target is invalid.
   */
  async move_to(to_key) {
    const content = await this.read();
    await this.remove();
    const is_block_ref = to_key.includes("#");
    let target_source_key = is_block_ref ? to_key.split("#")[0] : to_key;
    const target_source = this.item.env.smart_sources.get(target_source_key);
    if (!target_source) {
      await this.item.env.smart_sources.create(target_source_key, content);
      return;
    }
    if (is_block_ref) {
      const target_block = this.item.env.smart_blocks.get(to_key);
      if (target_block) {
        await target_block.append(content);
      } else {
        await target_source.append(content);
      }
    } else {
      await target_source.append(content);
    }
  }
  /**
   * Extract the block content using current line references from a full source content.
   * @private
   * @param {string} source_content Full source file content.
   * @returns {string} Extracted block content.
   * @throws {Error} If the block cannot be found.
   */
  _extract_block(source_content) {
    if (!source_content) {
      console.warn(`BLOCK NOT FOUND: ${this.item.key} has no source content.`);
      return "";
    }
    const { line_start, line_end } = this.item;
    if (!line_start || !line_end) {
      throw new Error(`BLOCK NOT FOUND: ${this.item.key} has invalid line references.`);
    }
    return get_line_range2(source_content, line_start, line_end);
  }
  /**
   * Re-parse the source file after a CRUD operation to update line references for all blocks.
   * @private
   * @async
   * @returns {Promise<void>}
   */
  async _reparse_source() {
    await this.item.source.import();
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-sources/components/settings.js
async function build_html2(collection, opts = {}) {
  const settings_html = Object.entries(collection.settings_config).map(([setting_key, setting_config]) => {
    if (!setting_config.setting) setting_config.setting = setting_key;
    return this.render_setting_html(setting_config);
  }).join("\n");
  const html = `<div class="source-settings">
    ${settings_header_html(collection, opts)}
    ${settings_html}
  </div>`;
  return html;
}
function settings_header_html(collection, opts = {}) {
  const heading_text = collection.collection_key.replace(/_/g, " ").replace(/\b\w/g, (char) => char.toUpperCase());
  const heading_html = collection.collection_key === "smart_sources" ? get_source_heading_html(collection) : get_block_heading_html(collection);
  return `<div class="group-header">
    <h2>${heading_text}</h2>
    ${heading_html}
  </div>`;
}
function get_source_heading_html(collection) {
  const item_count = Object.keys(collection.items).length;
  if (!collection.loaded) {
    return `<span>${item_count} sources (embeddings not currently loaded)</span>`;
  }
  const total_count = collection.total_files;
  const included_count = collection.included_files;
  if (collection.loaded !== included_count) {
    return `<span>${collection.loaded}/${included_count} sources (partially loaded, should refresh/reload)</span>`;
  }
  const embedded_items = Object.values(collection.items).filter((item) => item.vec);
  const embedded_percentage = Math.round(embedded_items.length / item_count * 100);
  const load_time_html = collection.load_time_ms ? `<span>Load time: ${collection.load_time_ms}ms</span>` : "";
  return `
    <span>${embedded_percentage}% embedded</span>
    ${embedded_percentage === 0 ? "<span><b>Should run Re-import to re-embed</b></span>" : ""}
    <span>${included_count} included</span>
    <span>${total_count - included_count} excluded</span>
    ${load_time_html}
  `;
}
function get_block_heading_html(collection) {
  const item_count = Object.keys(collection.items).length;
  if (!collection.loaded) {
    return `<span>${item_count} blocks (embeddings not currently loaded)</span>`;
  }
  if (collection.loaded !== item_count) {
    return `<span>${collection.loaded}/${item_count} (loaded/total)</span>`;
  }
  const items_w_vec = Object.values(collection.items).filter((item) => item.vec).length;
  const embedded_percentage = Math.round(items_w_vec / item_count * 100);
  const load_time_html = collection.load_time_ms ? `<span>Load time: ${collection.load_time_ms}ms</span>` : "";
  return `
    <span>${embedded_percentage}% embedded (${items_w_vec}/${item_count})</span>
    <!--<span>Loaded: ${item_count} blocks (expected ${collection.expected_blocks_ct})</span>-->
    ${load_time_html}
  `;
}
async function render3(collection, opts = {}) {
  const html = await build_html2.call(this, collection, opts);
  const frag = this.create_doc_fragment(html);
  return await post_process3.call(this, collection, frag, opts);
}
async function post_process3(collection, frag, opts = {}) {
  await this.render_setting_components(frag, { scope: collection });
  return frag;
}

// node_modules/obsidian-smart-env/node_modules/smart-model/components/settings.js
async function render4(scope, opts = {}) {
  const html = Object.entries(scope.settings_config).map(([setting_key, setting_config]) => {
    if (!setting_config.setting) setting_config.setting = setting_key;
    return this.render_setting_html(setting_config);
  }).join("\n");
  const frag = this.create_doc_fragment(html);
  return await post_process4.call(this, scope, frag, opts);
}
async function post_process4(scope, frag, opts = {}) {
  await this.render_setting_components(frag, { scope });
  return frag;
}

// node_modules/obsidian-smart-env/node_modules/smart-model/smart_model.js
var SmartModel = class {
  scope_name = "smart_model";
  static defaults = {
    // override in sub-class if needed
  };
  /**
   * Create a SmartModel instance.
   * @param {Object} opts - Configuration options
   * @param {Object} opts.adapters - Map of adapter names to adapter classes
   * @param {Object} opts.settings - Model settings configuration
   * @param {Object} opts.model_config - Model-specific configuration
   * @param {string} opts.model_config.adapter - Name of the adapter to use
   * @param {string} [opts.model_key] - Optional model identifier to override settings
   * @throws {Error} If required options are missing
   */
  constructor(opts = {}) {
    this.opts = opts;
    this.validate_opts(opts);
    this.state = "unloaded";
    this._adapter = null;
  }
  /**
   * Initialize the model by loading the configured adapter.
   * @async
   * @returns {Promise<void>}
   */
  async initialize() {
    this.load_adapter(this.adapter_name);
    await this.load();
  }
  /**
   * Validate required options.
   * @param {Object} opts - Configuration options
   */
  validate_opts(opts) {
    if (!opts.adapters) throw new Error("opts.adapters is required");
    if (!opts.settings) throw new Error("opts.settings is required");
  }
  /**
   * Get the current settings
   * @returns {Object} Current settings
   */
  get settings() {
    if (!this.opts.settings) this.opts.settings = {
      ...this.constructor.defaults
    };
    return this.opts.settings;
  }
  /**
   * Get the current adapter name
   * @returns {string} Current adapter name
   */
  get adapter_name() {
    let adapter_key = this.opts.model_config?.adapter || this.opts.adapter || this.settings.adapter || Object.keys(this.adapters)[0];
    if (!adapter_key || !this.adapters[adapter_key]) {
      console.warn(`Platform "${adapter_key}" not supported`);
      adapter_key = Object.keys(this.adapters)[0];
    }
    return adapter_key;
  }
  /**
   * Get adapter-specific settings.
   * @returns {Object} Settings for current adapter
   */
  get adapter_settings() {
    if (!this.settings[this.adapter_name]) this.settings[this.adapter_name] = {};
    return this.settings[this.adapter_name];
  }
  get adapter_config() {
    const base_config = this.adapters[this.adapter_name]?.defaults || {};
    return {
      ...base_config,
      ...this.adapter_settings,
      ...this.opts.adapter_config
    };
  }
  /**
   * Get available models.
   * @returns {Object} Map of model objects
   */
  get models() {
    return this.adapter.models;
  }
  /**
   * Get default model key.
   * @returns {string} Default model key
   */
  get default_model_key() {
    return this.adapter.constructor.defaults.default_model;
  }
  /**
   * Get the current model key
   * @returns {string} Current model key
   */
  get model_key() {
    return this.opts.model_key || this.adapter_config.model_key || this.settings.model_key || this.default_model_key;
  }
  /**
   * Get the current model configuration
   * @returns {Object} Combined base and custom model configuration
   */
  get model_config() {
    const model_key = this.model_key;
    const base_model_config = this.models[model_key] || {};
    return {
      ...this.adapter_config,
      ...base_model_config,
      ...this.opts.model_config
    };
  }
  get model_settings() {
    if (!this.settings[this.model_key]) this.settings[this.model_key] = {};
    return this.settings[this.model_key];
  }
  /**
   * Load the current adapter and transition to loaded state.
   * @async
   * @returns {Promise<void>}
   */
  async load() {
    this.set_state("loading");
    try {
      if (!this.adapter?.is_loaded) {
        await this.invoke_adapter_method("load");
      }
    } catch (err) {
      this.set_state("unloaded");
      if (!this.reload_model_timeout) {
        this.reload_model_timeout = setTimeout(async () => {
          this.reload_model_timeout = null;
          await this.load();
          this.set_state("loaded");
          this.notices?.show("Loaded model: " + this.model_key);
        }, 6e4);
      }
      throw new Error(`Failed to load model: ${err.message}`);
    }
    this.set_state("loaded");
  }
  /**
   * Unload the current adapter and transition to unloaded state.
   * @async
   * @returns {Promise<void>}
   */
  async unload() {
    if (this.adapter?.is_loaded) {
      this.set_state("unloading");
      await this.invoke_adapter_method("unload");
      this.set_state("unloaded");
    }
  }
  /**
   * Set the model's state.
   * @param {('unloaded'|'loading'|'loaded'|'unloading')} new_state - The new state
   * @throws {Error} If the state is invalid
   */
  set_state(new_state) {
    const valid_states = ["unloaded", "loading", "loaded", "unloading"];
    if (!valid_states.includes(new_state)) {
      throw new Error(`Invalid state: ${new_state}`);
    }
    this.state = new_state;
  }
  get is_loading() {
    return this.state === "loading";
  }
  get is_loaded() {
    return this.state === "loaded";
  }
  get is_unloading() {
    return this.state === "unloading";
  }
  get is_unloaded() {
    return this.state === "unloaded";
  }
  // ADAPTERS
  /**
   * Get the map of available adapters
   * @returns {Object} Map of adapter names to adapter classes
   */
  get adapters() {
    return this.opts.adapters || {};
  }
  /**
   * Load a specific adapter by name.
   * @async
   * @param {string} adapter_name - Name of the adapter to load
   * @throws {Error} If adapter not found or loading fails
   * @returns {Promise<void>}
   */
  async load_adapter(adapter_name) {
    this.set_adapter(adapter_name);
    if (!this._adapter.loaded) {
      this.set_state("loading");
      try {
        await this.invoke_adapter_method("load");
        this.set_state("loaded");
      } catch (err) {
        this.set_state("unloaded");
        throw new Error(`Failed to load adapter: ${err.message}`);
      }
    }
  }
  /**
   * Set an adapter instance by name without loading it.
   * @param {string} adapter_name - Name of the adapter to set
   * @throws {Error} If adapter not found
   */
  set_adapter(adapter_name) {
    const AdapterClass = this.adapters[adapter_name];
    if (!AdapterClass) {
      throw new Error(`Adapter "${adapter_name}" not found.`);
    }
    if (this._adapter?.constructor.name.toLowerCase() === adapter_name.toLowerCase()) {
      return;
    }
    this._adapter = new AdapterClass(this);
  }
  /**
   * Get the current active adapter instance
   * @returns {Object} The active adapter instance
   * @throws {Error} If adapter not found
   */
  get adapter() {
    const adapter_name = this.adapter_name;
    if (!adapter_name) {
      throw new Error(`Adapter not set for model.`);
    }
    if (!this._adapter) {
      this.load_adapter(adapter_name);
    }
    return this._adapter;
  }
  /**
   * Ensure the adapter is ready to execute a method.
   * @param {string} method - Name of the method to check
   * @throws {Error} If adapter not loaded or method not implemented
   */
  ensure_adapter_ready(method) {
    if (!this.adapter) {
      throw new Error("No adapter loaded.");
    }
    if (typeof this.adapter[method] !== "function") {
      throw new Error(`Adapter does not implement method: ${method}`);
    }
  }
  /**
   * Invoke a method on the current adapter.
   * @async
   * @param {string} method - Name of the method to call
   * @param {...any} args - Arguments to pass to the method
   * @returns {Promise<any>} Result from the adapter method
   * @throws {Error} If adapter not ready or method fails
   */
  async invoke_adapter_method(method, ...args) {
    this.ensure_adapter_ready(method);
    return await this.adapter[method](...args);
  }
  /**
   * Get platforms as dropdown options.
   * @returns {Array<Object>} Array of {value, name} option objects
   */
  get_platforms_as_options() {
    return Object.entries(this.adapters).map(([key, AdapterClass]) => ({ value: key, name: AdapterClass.defaults.description || key }));
  }
  // SETTINGS
  /**
   * Get the settings configuration schema
   * @returns {Object} Settings configuration object
   */
  get settings_config() {
    return this.process_settings_config({
      adapter: {
        name: "Model Platform",
        type: "dropdown",
        description: "Select a model platform to use with Smart Model.",
        options_callback: "get_platforms_as_options",
        is_scope: true,
        // trigger re-render of settings when changed
        callback: "adapter_changed",
        default: "default"
      }
    });
  }
  /**
   * Process settings configuration with conditionals and prefixes.
   * @param {Object} _settings_config - Raw settings configuration
   * @param {string} [prefix] - Optional prefix for setting keys
   * @returns {Object} Processed settings configuration
   */
  process_settings_config(_settings_config, prefix = null) {
    return Object.entries(_settings_config).reduce((acc, [key, val]) => {
      const new_key = (prefix ? prefix + "." : "") + this.process_setting_key(key);
      acc[new_key] = val;
      return acc;
    }, {});
  }
  /**
   * Process an individual setting key.
   * Example: replace placeholders with actual adapter names.
   * @param {string} key - The setting key with placeholders.
   * @returns {string} Processed setting key.
   */
  process_setting_key(key) {
    return key.replace(/\[ADAPTER\]/g, this.adapter_name);
  }
  re_render_settings() {
    if (typeof this.opts.re_render_settings === "function") this.opts.re_render_settings();
    else console.warn("re_render_settings is not a function (must be passed in model opts)");
  }
  /**
   * Reload model.
   */
  reload_model() {
    if (typeof this.opts.reload_model === "function") this.opts.reload_model();
    else console.warn("reload_model is not a function (must be passed in model opts)");
  }
  adapter_changed() {
    this.reload_model();
    this.re_render_settings();
  }
  model_changed() {
    this.reload_model();
    this.re_render_settings();
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-embed-model/smart_embed_model.js
var SmartEmbedModel = class extends SmartModel {
  scope_name = "smart_embed_model";
  static defaults = {
    adapter: "transformers"
  };
  /**
   * Create a SmartEmbedModel instance
   * @param {Object} opts - Configuration options
   * @param {Object} [opts.adapters] - Map of available adapter implementations
   * @param {boolean} [opts.use_gpu] - Whether to enable GPU acceleration
   * @param {number} [opts.gpu_batch_size] - Batch size when using GPU
   * @param {number} [opts.batch_size] - Default batch size for processing
   * @param {Object} [opts.model_config] - Model-specific configuration
   * @param {string} [opts.model_config.adapter] - Override adapter type
   * @param {number} [opts.model_config.dims] - Embedding dimensions
   * @param {number} [opts.model_config.max_tokens] - Maximum tokens to process
   * @param {Object} [opts.settings] - User settings
   * @param {string} [opts.settings.api_key] - API key for remote models
   * @param {number} [opts.settings.min_chars] - Minimum text length to embed
   */
  constructor(opts = {}) {
    super(opts);
  }
  /**
   * Count tokens in an input string
   * @param {string} input - Text to tokenize
   * @returns {Promise<Object>} Token count result
   * @property {number} tokens - Number of tokens in input
   * 
   * @example
   * ```javascript
   * const result = await model.count_tokens("Hello world");
   * console.log(result.tokens); // 2
   * ```
   */
  async count_tokens(input) {
    return await this.invoke_adapter_method("count_tokens", input);
  }
  /**
   * Generate embeddings for a single input
   * @param {string|Object} input - Text or object with embed_input property
   * @returns {Promise<Object>} Embedding result
   * @property {number[]} vec - Embedding vector
   * @property {number} tokens - Token count
   * 
   * @example
   * ```javascript
   * const result = await model.embed("Hello world");
   * console.log(result.vec); // [0.1, 0.2, ...]
   * ```
   */
  async embed(input) {
    if (typeof input === "string") input = { embed_input: input };
    return (await this.embed_batch([input]))[0];
  }
  /**
   * Generate embeddings for multiple inputs in batch
   * @param {Array<string|Object>} inputs - Array of texts or objects with embed_input
   * @returns {Promise<Array<Object>>} Array of embedding results
   * @property {number[]} vec - Embedding vector for each input
   * @property {number} tokens - Token count for each input
   * 
   * @example
   * ```javascript
   * const results = await model.embed_batch([
   *   { embed_input: "First text" },
   *   { embed_input: "Second text" }
   * ]);
   * ```
   */
  async embed_batch(inputs) {
    return await this.invoke_adapter_method("embed_batch", inputs);
  }
  /**
   * Get the current batch size based on GPU settings
   * @returns {number} Current batch size for processing
   */
  get batch_size() {
    return this.adapter.batch_size || 1;
  }
  /**
   * Get settings configuration schema
   * @returns {Object} Settings configuration object
   */
  get settings_config() {
    const _settings_config = {
      adapter: {
        name: "Embedding model platform",
        type: "dropdown",
        description: "Select an embedding model platform. The default 'transformers' utilizes built-in local models.",
        options_callback: "get_platforms_as_options",
        callback: "adapter_changed",
        default: this.constructor.defaults.adapter
      },
      ...this.adapter.settings_config || {}
    };
    return this.process_settings_config(_settings_config);
  }
  process_setting_key(key) {
    return key.replace(/\[ADAPTER\]/g, this.adapter_name);
  }
  /**
   * Get available embedding model options
   * @returns {Array<Object>} Array of model options with value and name
   */
  get_embedding_model_options() {
    return Object.entries(this.models).map(([key, model]) => ({ value: key, name: key }));
  }
  // /**
  //  * Get embedding model options including 'None' option
  //  * @returns {Array<Object>} Array of model options with value and name
  //  */
  // get_block_embedding_model_options() {
  //   const options = this.get_embedding_model_options();
  //   options.unshift({ value: 'None', name: 'None' });
  //   return options;
  // }
};

// node_modules/obsidian-smart-env/node_modules/smart-model/adapters/_adapter.js
var SmartModelAdapter = class {
  /**
   * Create a SmartModelAdapter instance.
   * @param {SmartModel} model - The parent SmartModel instance
   */
  constructor(model) {
    this.model = model;
    this.state = "unloaded";
  }
  /**
   * Load the adapter.
   * @async
   * @returns {Promise<void>}
   */
  async load() {
    this.set_state("loaded");
  }
  /**
   * Unload the adapter.
   * @returns {void}
   */
  unload() {
    this.set_state("unloaded");
  }
  /**
   * Get all settings.
   * @returns {Object} All settings
   */
  get settings() {
    return this.model.settings;
  }
  /**
   * Get the current model key.
   * @returns {string} Current model identifier
   */
  get model_key() {
    return this.model.model_key;
  }
  /**
   * Get the current model configuration.
   * @returns {Object} Model configuration
   */
  get model_config() {
    return this.model.model_config;
  }
  /**
   * Get model-specific settings.
   * @returns {Object} Settings for current model
   */
  get model_settings() {
    return this.model.model_settings;
  }
  /**
   * Get adapter-specific configuration.
   * @returns {Object} Adapter configuration
   */
  get adapter_config() {
    return this.model.adapter_config;
  }
  /**
   * Get adapter-specific settings.
   * @returns {Object} Adapter settings
   */
  get adapter_settings() {
    return this.model.adapter_settings;
  }
  /**
   * Get the models.
   * @returns {Object} Map of model objects
   */
  get models() {
    if (typeof this.adapter_config.models === "object" && Object.keys(this.adapter_config.models || {}).length > 0) return this.adapter_config.models;
    else {
      return {};
    }
  }
  /**
   * Get available models from the API.
   * @abstract
   * @param {boolean} [refresh=false] - Whether to refresh cached models
   * @returns {Promise<Object>} Map of model objects
   */
  async get_models(refresh = false) {
    throw new Error("get_models not implemented");
  }
  /**
   * Validate the parameters for get_models.
   * @returns {boolean|Array<Object>} True if parameters are valid, otherwise an array of error objects
   */
  validate_get_models_params() {
    return true;
  }
  /**
   * Get available models as dropdown options synchronously.
   * @returns {Array<Object>} Array of model options.
   */
  get_models_as_options() {
    const models = this.models;
    const params_valid = this.validate_get_models_params();
    if (params_valid !== true) return params_valid;
    if (!Object.keys(models || {}).length) {
      this.get_models(true);
      return [{ value: "", name: "No models currently available" }];
    }
    return Object.entries(models).map(([id, model]) => ({ value: id, name: model.name || id })).sort((a, b) => a.name.localeCompare(b.name));
  }
  /**
   * Set the adapter's state.
   * @deprecated should be handled in SmartModel (only handle once)
   * @param {('unloaded'|'loading'|'loaded'|'unloading')} new_state - The new state
   * @throws {Error} If the state is invalid
   */
  set_state(new_state) {
    const valid_states = ["unloaded", "loading", "loaded", "unloading"];
    if (!valid_states.includes(new_state)) {
      throw new Error(`Invalid state: ${new_state}`);
    }
    this.state = new_state;
  }
  // Replace individual state getters/setters with a unified state management
  get is_loading() {
    return this.state === "loading";
  }
  get is_loaded() {
    return this.state === "loaded";
  }
  get is_unloading() {
    return this.state === "unloading";
  }
  get is_unloaded() {
    return this.state === "unloaded";
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-embed-model/adapters/_adapter.js
var SmartEmbedAdapter = class extends SmartModelAdapter {
  /**
   * @override in sub-class with adapter-specific default configurations
   * @property {string} id - The adapter identifier
   * @property {string} description - Human-readable description
   * @property {string} type - Adapter type ("API")
   * @property {string} endpoint - API endpoint
   * @property {string} adapter - Adapter identifier
   * @property {string} default_model - Default model to use
   */
  static defaults = {};
  /**
   * Create adapter instance
   * @param {SmartEmbedModel} model - Parent model instance
   */
  constructor(model) {
    super(model);
    this.smart_embed = model;
  }
  /**
   * Count tokens in input text
   * @abstract
   * @param {string} input - Text to tokenize
   * @returns {Promise<Object>} Token count result
   * @property {number} tokens - Number of tokens in input
   * @throws {Error} If not implemented by subclass
   */
  async count_tokens(input) {
    throw new Error("count_tokens method not implemented");
  }
  /**
   * Generate embeddings for single input
   * @abstract
   * @param {string|Object} input - Text to embed
   * @returns {Promise<Object>} Embedding result
   * @property {number[]} vec - Embedding vector
   * @property {number} tokens - Number of tokens in input
   * @throws {Error} If not implemented by subclass
   */
  async embed(input) {
    throw new Error("embed method not implemented");
  }
  /**
   * Generate embeddings for multiple inputs
   * @abstract
   * @param {Array<string|Object>} inputs - Texts to embed
   * @returns {Promise<Array<Object>>} Array of embedding results
   * @property {number[]} vec - Embedding vector for each input
   * @property {number} tokens - Number of tokens in each input
   * @throws {Error} If not implemented by subclass
   */
  async embed_batch(inputs) {
    throw new Error("embed_batch method not implemented");
  }
  get settings_config() {
    return {
      "[ADAPTER].model_key": {
        name: "Embedding model",
        type: "dropdown",
        description: "Select an embedding model.",
        options_callback: "adapter.get_models_as_options",
        callback: "model_changed",
        default: this.constructor.defaults.default_model
      }
    };
  }
  get dims() {
    return this.model_config.dims;
  }
  get max_tokens() {
    return this.model_config.max_tokens;
  }
  // get batch_size() { return this.model_config.batch_size; }
  get use_gpu() {
    if (typeof this._use_gpu === "undefined") {
      if (typeof this.model.opts.use_gpu !== "undefined") this._use_gpu = this.model.opts.use_gpu;
      else this._use_gpu = typeof navigator !== "undefined" && !!navigator?.gpu && this.model_settings.gpu_batch_size !== 0;
    }
    return this._use_gpu;
  }
  set use_gpu(value) {
    this._use_gpu = value;
  }
  get batch_size() {
    if (this.use_gpu && this.model_config?.gpu_batch_size) return this.model_config.gpu_batch_size;
    return this.model.opts.batch_size || this.model_config.batch_size || 1;
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-http-request/smart_http_request.js
var SmartHttpRequest = class {
  /**
   * @param {object} opts - Options for the SmartHttpRequest class
   * @param {SmartHttpRequestAdapter} opts.adapter - The adapter constructor to use for making HTTP requests
   * @param {Obsidian.requestUrl} opts.obsidian_request_adapter - For use with Obsidian adapter
   */
  constructor(opts = {}) {
    this.opts = opts;
    if (!opts.adapter) throw new Error("HttpRequestAdapter is required");
    this.adapter = new opts.adapter(this);
  }
  /**
   * Returns a well-formed response object
   * @param {object} request_params - Parameters for the HTTP request
   * @param {string} request_params.url - The URL to make the request to
   * @param {string} [request_params.method='GET'] - The HTTP method to use
   * @param {object} [request_params.headers] - Headers to include in the request
   * @param {*} [request_params.body] - The body of the request (for POST, PUT, etc.)
   * @returns {SmartHttpResponseAdapter} instance of the SmartHttpResponseAdapter class
   * @example
   * const response = await smart_http_request.request({
   *   url: 'https://api.example.com/data',
   *   method: 'GET',
   *   headers: { 'Content-Type': 'application/json' }
   * });
   * console.log(await response.json());
   */
  async request(request_params) {
    return await this.adapter.request(request_params);
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-http-request/adapters/_adapter.js
var SmartHttpRequestAdapter = class {
  constructor(main) {
    this.main = main;
  }
  async request(request_params) {
    throw new Error("request not implemented");
  }
};
var SmartHttpResponseAdapter = class {
  constructor(response) {
    this.response = response;
  }
  async headers() {
    throw new Error("headers not implemented");
  }
  async json() {
    throw new Error("json not implemented");
  }
  async status() {
    throw new Error("status not implemented");
  }
  async text() {
    throw new Error("text not implemented");
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-http-request/adapters/obsidian.js
var SmartHttpObsidianRequestAdapter = class extends SmartHttpRequestAdapter {
  async request(request_params) {
    let response;
    try {
      if (!this.main.opts.obsidian_request_url) {
        throw new Error("obsidian_request_url is required in SmartHttp constructor opts");
      }
      response = await this.main.opts.obsidian_request_url({ ...request_params, throw: false });
      if (response.status === 400) throw new Error("Obsidian request failed");
      return new SmartHttpObsidianResponseAdapter(response);
    } catch (error) {
      console.error("Error in SmartHttpObsidianRequestAdapter.request():");
      console.error(JSON.stringify(request_params, null, 2));
      console.error(response);
      console.error(error);
      return null;
    }
  }
};
var SmartHttpObsidianResponseAdapter = class extends SmartHttpResponseAdapter {
  async status() {
    return this.response.status;
  }
  async json() {
    return await this.response.json;
  }
  async text() {
    return await this.response.text;
  }
  async headers() {
    return this.response.headers;
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-http-request/adapters/fetch.js
var SmartHttpRequestFetchAdapter = class extends SmartHttpRequestAdapter {
  async request(request_params) {
    const { url, ...opts } = request_params;
    const resp = await fetch(url, opts);
    return new SmartHttpResponseFetchAdapter(resp);
  }
};
var SmartHttpResponseFetchAdapter = class extends SmartHttpResponseAdapter {
  async headers() {
    return this.response.headers;
  }
  async json() {
    if (!this._json) {
      this._json = await this.response.json();
    }
    return this._json;
  }
  async status() {
    return this.response.status;
  }
  async text() {
    if (!this._text) {
      this._text = await this.response.text();
    }
    return this._text;
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-embed-model/adapters/_api.js
var SmartEmbedModelApiAdapter = class extends SmartEmbedAdapter {
  /**
   * Get the request adapter class.
   * @returns {SmartEmbedModelRequestAdapter} The request adapter class
   */
  get req_adapter() {
    return SmartEmbedModelRequestAdapter;
  }
  /**
   * Get the response adapter class.
   * @returns {SmartEmbedModelResponseAdapter} The response adapter class
   */
  get res_adapter() {
    return SmartEmbedModelResponseAdapter;
  }
  /** @returns {string} API endpoint URL */
  get endpoint() {
    return this.model_config.endpoint;
  }
  /**
   * Get HTTP request adapter instance
   * @returns {SmartHttpRequest} HTTP request handler
   */
  get http_adapter() {
    if (!this._http_adapter) {
      if (this.model.opts.http_adapter)
        this._http_adapter = this.model.opts.http_adapter;
      else
        this._http_adapter = new SmartHttpRequest({
          adapter: SmartHttpRequestFetchAdapter
        });
    }
    return this._http_adapter;
  }
  /**
   * Get API key for authentication
   * @returns {string} API key
   */
  get api_key() {
    return this.adapter_settings.api_key || this.settings.api_key || this.model_config.api_key;
  }
  /**
   * Count tokens in input text
   * @abstract
   * @param {string} input - Text to tokenize
   * @returns {Promise<Object>} Token count result
   * @throws {Error} If not implemented by subclass
   */
  async count_tokens(input) {
    throw new Error("count_tokens not implemented");
  }
  /**
   * Estimate token count for input text
   * Uses character-based estimation (3.7 chars per token)
   * @param {string|Object} input - Input to estimate tokens for
   * @returns {number} Estimated token count
   */
  estimate_tokens(input) {
    if (typeof input === "object") input = JSON.stringify(input);
    return Math.ceil(input.length / 3.7);
  }
  /**
   * Process a batch of inputs for embedding
   * @param {Array<Object>} inputs - Array of input objects
   * @returns {Promise<Array<Object>>} Processed inputs with embeddings
   * @throws {Error} If API key is not set
   */
  async embed_batch(inputs) {
    if (!this.api_key) throw new Error("API key not set");
    inputs = inputs.filter((item) => item.embed_input?.length > 0);
    if (inputs.length === 0) {
      console.log("Empty batch (or all items have empty embed_input)");
      return [];
    }
    const embed_inputs = await Promise.all(
      inputs.map((item) => this.prepare_embed_input(item.embed_input))
    );
    const _req = new this.req_adapter(this, embed_inputs);
    const request_params = _req.to_platform();
    const resp = await this.request(request_params);
    if (!resp) {
      console.error("No response received for embedding request.");
      return [];
    }
    const _res = new this.res_adapter(this, resp);
    const embeddings = _res.to_openai();
    if (!embeddings) {
      console.error("Failed to parse embeddings.");
      return [];
    }
    return inputs.map((item, i) => {
      item.vec = embeddings[i].vec;
      item.tokens = embeddings[i].tokens;
      return item;
    });
  }
  /**
   * Prepare input text for embedding
   * @abstract
   * @param {string} embed_input - Raw input text
   * @returns {Promise<string>} Processed input text
   * @throws {Error} If not implemented by subclass
   */
  async prepare_embed_input(embed_input) {
    throw new Error("prepare_embed_input not implemented");
  }
  /**
   * Prepare request headers
   * @returns {Object} Headers object with authorization
   */
  prepare_request_headers() {
    let headers = {
      "Content-Type": "application/json"
    };
    if (this.api_key) {
      headers["Authorization"] = `Bearer ${this.api_key}`;
    }
    if (this.smart_embed.opts.headers) {
      headers = { ...headers, ...this.smart_embed.opts.headers };
    }
    return headers;
  }
  /**
   * Make API request with retry logic
   * @param {Object} req - Request configuration
   * @param {number} [retries=0] - Number of retries attempted
   * @returns {Promise<Object>} API response
   */
  async request(req, retries = 0) {
    try {
      req.throw = false;
      const resp = await this.http_adapter.request({
        url: this.endpoint,
        ...req
      });
      const resp_json = await this.get_resp_json(resp);
      return resp_json;
    } catch (error) {
      return await this.handle_request_err(error, req, retries);
    }
  }
  /**
   * Handle API request errors with retry logic
   * @param {Error|Object} error - Error object
   * @param {Object} req - Original request
   * @param {number} retries - Number of retries attempted
   * @returns {Promise<Object|null>} Retry response or null
   */
  async handle_request_err(error, req, retries) {
    if (error.status === 429 && retries < 3) {
      const backoff = Math.pow(retries + 1, 2);
      console.log(`Retrying request (429) in ${backoff} seconds...`);
      await new Promise((r) => setTimeout(r, 1e3 * backoff));
      return await this.request(req, retries + 1);
    }
    console.error(error);
    return null;
  }
  /**
   * Parse response body as JSON
   * @param {Response} resp - Response object
   * @returns {Promise<Object>} Parsed JSON
   */
  async get_resp_json(resp) {
    return typeof resp.json === "function" ? await resp.json() : await resp.json;
  }
  /**
   * Validate API key by making test request
   * @returns {Promise<boolean>} True if API key is valid
   */
  async validate_api_key() {
    const resp = await this.embed_batch([{ embed_input: "test" }]);
    return Array.isArray(resp) && resp.length > 0 && resp[0].vec !== null;
  }
};
var SmartEmbedModelRequestAdapter = class {
  /**
   * @constructor
   * @param {SmartEmbedModelApiAdapter} adapter - The SmartEmbedModelApiAdapter instance
   * @param {Array<string>} embed_inputs - The array of input texts
   */
  constructor(adapter, embed_inputs) {
    this.adapter = adapter;
    this.embed_inputs = embed_inputs;
  }
  /**
   * Get request headers
   * @returns {Object} Headers object
   */
  get_headers() {
    return this.adapter.prepare_request_headers();
  }
  /**
   * Convert request to platform-specific format
   * @returns {Object} Platform-specific request parameters
   */
  to_platform() {
    return {
      method: "POST",
      headers: this.get_headers(),
      body: JSON.stringify(this.prepare_request_body())
    };
  }
  /**
   * Prepare request body for API call
   * @abstract
   * @returns {Object} Request body object
   * @throws {Error} If not implemented by subclass
   */
  prepare_request_body() {
    throw new Error("prepare_request_body not implemented");
  }
};
var SmartEmbedModelResponseAdapter = class {
  /**
   * @constructor
   * @param {SmartEmbedModelApiAdapter} adapter - The SmartEmbedModelApiAdapter instance
   * @param {Object} response - The response object
   */
  constructor(adapter, response) {
    this.adapter = adapter;
    this.response = response;
  }
  /**
   * Convert response to standard format
   * @returns {Array<Object>} Array of embedding results
   */
  to_openai() {
    return this.parse_response();
  }
  /**
   * Parse API response
   * @abstract
   * @returns {Array<Object>} Parsed embedding results
   * @throws {Error} If not implemented by subclass
   */
  parse_response() {
    throw new Error("parse_response not implemented");
  }
};

// node_modules/obsidian-smart-env/node_modules/js-tiktoken/dist/chunk-ZDNLBERF.js
var import_base64_js = __toESM(require_base64_js(), 1);
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function bytePairMerge(piece, ranks) {
  let parts = Array.from(
    { length: piece.length },
    (_, i) => ({ start: i, end: i + 1 })
  );
  while (parts.length > 1) {
    let minRank = null;
    for (let i = 0; i < parts.length - 1; i++) {
      const slice = piece.slice(parts[i].start, parts[i + 1].end);
      const rank = ranks.get(slice.join(","));
      if (rank == null)
        continue;
      if (minRank == null || rank < minRank[0]) {
        minRank = [rank, i];
      }
    }
    if (minRank != null) {
      const i = minRank[1];
      parts[i] = { start: parts[i].start, end: parts[i + 1].end };
      parts.splice(i + 1, 1);
    } else {
      break;
    }
  }
  return parts;
}
function bytePairEncode(piece, ranks) {
  if (piece.length === 1)
    return [ranks.get(piece.join(","))];
  return bytePairMerge(piece, ranks).map((p) => ranks.get(piece.slice(p.start, p.end).join(","))).filter((x) => x != null);
}
function escapeRegex(str) {
  return str.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
var _Tiktoken = class {
  /** @internal */
  specialTokens;
  /** @internal */
  inverseSpecialTokens;
  /** @internal */
  patStr;
  /** @internal */
  textEncoder = new TextEncoder();
  /** @internal */
  textDecoder = new TextDecoder("utf-8");
  /** @internal */
  rankMap = /* @__PURE__ */ new Map();
  /** @internal */
  textMap = /* @__PURE__ */ new Map();
  constructor(ranks, extendedSpecialTokens) {
    this.patStr = ranks.pat_str;
    const uncompressed = ranks.bpe_ranks.split("\n").filter(Boolean).reduce((memo, x) => {
      const [_, offsetStr, ...tokens] = x.split(" ");
      const offset = Number.parseInt(offsetStr, 10);
      tokens.forEach((token, i) => memo[token] = offset + i);
      return memo;
    }, {});
    for (const [token, rank] of Object.entries(uncompressed)) {
      const bytes = import_base64_js.default.toByteArray(token);
      this.rankMap.set(bytes.join(","), rank);
      this.textMap.set(rank, bytes);
    }
    this.specialTokens = { ...ranks.special_tokens, ...extendedSpecialTokens };
    this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((memo, [text, rank]) => {
      memo[rank] = this.textEncoder.encode(text);
      return memo;
    }, {});
  }
  encode(text, allowedSpecial = [], disallowedSpecial = "all") {
    const regexes = new RegExp(this.patStr, "ug");
    const specialRegex = _Tiktoken.specialTokenRegex(
      Object.keys(this.specialTokens)
    );
    const ret = [];
    const allowedSpecialSet = new Set(
      allowedSpecial === "all" ? Object.keys(this.specialTokens) : allowedSpecial
    );
    const disallowedSpecialSet = new Set(
      disallowedSpecial === "all" ? Object.keys(this.specialTokens).filter(
        (x) => !allowedSpecialSet.has(x)
      ) : disallowedSpecial
    );
    if (disallowedSpecialSet.size > 0) {
      const disallowedSpecialRegex = _Tiktoken.specialTokenRegex([
        ...disallowedSpecialSet
      ]);
      const specialMatch = text.match(disallowedSpecialRegex);
      if (specialMatch != null) {
        throw new Error(
          `The text contains a special token that is not allowed: ${specialMatch[0]}`
        );
      }
    }
    let start = 0;
    while (true) {
      let nextSpecial = null;
      let startFind = start;
      while (true) {
        specialRegex.lastIndex = startFind;
        nextSpecial = specialRegex.exec(text);
        if (nextSpecial == null || allowedSpecialSet.has(nextSpecial[0]))
          break;
        startFind = nextSpecial.index + 1;
      }
      const end = nextSpecial?.index ?? text.length;
      for (const match of text.substring(start, end).matchAll(regexes)) {
        const piece = this.textEncoder.encode(match[0]);
        const token2 = this.rankMap.get(piece.join(","));
        if (token2 != null) {
          ret.push(token2);
          continue;
        }
        ret.push(...bytePairEncode(piece, this.rankMap));
      }
      if (nextSpecial == null)
        break;
      let token = this.specialTokens[nextSpecial[0]];
      ret.push(token);
      start = nextSpecial.index + nextSpecial[0].length;
    }
    return ret;
  }
  decode(tokens) {
    const res = [];
    let length = 0;
    for (let i2 = 0; i2 < tokens.length; ++i2) {
      const token = tokens[i2];
      const bytes = this.textMap.get(token) ?? this.inverseSpecialTokens[token];
      if (bytes != null) {
        res.push(bytes);
        length += bytes.length;
      }
    }
    const mergedArray = new Uint8Array(length);
    let i = 0;
    for (const bytes of res) {
      mergedArray.set(bytes, i);
      i += bytes.length;
    }
    return this.textDecoder.decode(mergedArray);
  }
};
var Tiktoken = _Tiktoken;
__publicField(Tiktoken, "specialTokenRegex", (tokens) => {
  return new RegExp(tokens.map((i) => escapeRegex(i)).join("|"), "g");
});

// node_modules/obsidian-smart-env/node_modules/smart-embed-model/utils/fetch_cache.js
async function fetch_json_cached(url, cache_key = url) {
  const is_browser = typeof window !== "undefined" && typeof window.document !== "undefined";
  if (is_browser) {
    const cached_text = window.localStorage.getItem(cache_key);
    if (cached_text) return JSON.parse(cached_text);
    const remote2 = await do_fetch(url);
    window.localStorage.setItem(cache_key, JSON.stringify(remote2));
    return remote2;
  }
  const fs = await import("node:fs/promises");
  const path = await import("node:path");
  const os = await import("node:os");
  const cache_dir = path.join(os.homedir(), ".cache", "smart-embed-model");
  const cache_file = path.join(cache_dir, cache_key);
  try {
    const txt = await fs.readFile(cache_file, "utf8");
    return JSON.parse(txt);
  } catch {
  }
  const remote = await do_fetch(url);
  await fs.mkdir(cache_dir, { recursive: true });
  await fs.writeFile(cache_file, JSON.stringify(remote), "utf8");
  return remote;
}
async function do_fetch(url) {
  const resp = await fetch(url);
  if (!resp.ok) throw new Error(`failed to download ${url} \u2013 ${resp.status}`);
  return await resp.json();
}

// node_modules/obsidian-smart-env/node_modules/smart-embed-model/adapters/openai.js
var CL100K_URL = "https://raw.githubusercontent.com/brianpetro/jsbrains/refs/heads/main/smart-embed-model/cl100k_base.json";
var SmartEmbedOpenAIAdapter = class extends SmartEmbedModelApiAdapter {
  static defaults = {
    adapter: "openai",
    description: "OpenAI (API)",
    default_model: "text-embedding-3-small",
    endpoint: "https://api.openai.com/v1/embeddings"
  };
  /**
   * Create OpenAI adapter instance
   * @param {SmartEmbedModel} smart_embed - Parent model instance
   */
  constructor(smart_embed) {
    super(smart_embed);
    this.enc = null;
  }
  /**
   * Initialize tokenizer
   * @returns {Promise<void>}
   */
  async load() {
    const cl100k_base = await fetch_json_cached(CL100K_URL, "cl100k_base.json");
    this.enc = new Tiktoken(cl100k_base);
  }
  /**
   * Count tokens in input text using OpenAI's tokenizer
   * @param {string} input - Text to tokenize
   * @returns {Promise<Object>} Token count result
   */
  async count_tokens(input) {
    if (!this.enc) await this.load();
    return { tokens: this.enc.encode(input).length };
  }
  /**
   * Prepare input text for embedding
   * Handles token limit truncation
   * @param {string} embed_input - Raw input text
   * @returns {Promise<string|null>} Processed input text
   */
  async prepare_embed_input(embed_input) {
    if (typeof embed_input !== "string") {
      throw new TypeError("embed_input must be a string");
    }
    if (embed_input.length === 0) {
      console.log("Warning: prepare_embed_input received an empty string");
      return null;
    }
    const { tokens } = await this.count_tokens(embed_input);
    if (tokens <= this.max_tokens) {
      return embed_input;
    }
    return await this.trim_input_to_max_tokens(embed_input, tokens);
  }
  /**
   * Trim input text to fit token limit
   * @private
   * @param {string} embed_input - Input text to trim
   * @param {number} tokens_ct - Current token count
   * @returns {Promise<string|null>} Trimmed input text
   */
  async trim_input_to_max_tokens(embed_input, tokens_ct) {
    const reduce_ratio = (tokens_ct - this.max_tokens) / tokens_ct;
    const new_length = Math.floor(embed_input.length * (1 - reduce_ratio));
    let trimmed_input = embed_input.slice(0, new_length);
    const last_space_index = trimmed_input.lastIndexOf(" ");
    if (last_space_index > 0) {
      trimmed_input = trimmed_input.slice(0, last_space_index);
    }
    const prepared_input = await this.prepare_embed_input(trimmed_input);
    if (prepared_input === null) {
      console.log(
        "Warning: prepare_embed_input resulted in an empty string after trimming"
      );
      return null;
    }
    return prepared_input;
  }
  /**
   * Get the request adapter class.
   * @returns {SmartEmbedOpenAIRequestAdapter} The request adapter class
   */
  get req_adapter() {
    return SmartEmbedOpenAIRequestAdapter;
  }
  /**
   * Get the response adapter class.
   * @returns {SmartEmbedOpenAIResponseAdapter} The response adapter class
   */
  get res_adapter() {
    return SmartEmbedOpenAIResponseAdapter;
  }
  /** @returns {number} Maximum tokens per input */
  get max_tokens() {
    return this.model_config.max_tokens || 8191;
  }
  /** @returns {Object} Settings configuration for OpenAI adapter */
  get settings_config() {
    return {
      ...super.settings_config,
      "[ADAPTER].api_key": {
        name: "OpenAI API key for embeddings",
        type: "password",
        description: "Required for OpenAI embedding models.",
        placeholder: "Enter OpenAI API key"
      }
    };
  }
  /**
   * Get available models (hardcoded list)
   * @returns {Promise<Object>} Map of model objects
   */
  get_models() {
    return Promise.resolve(this.models);
  }
  get models() {
    return {
      "text-embedding-3-small": {
        "id": "text-embedding-3-small",
        "batch_size": 50,
        "dims": 1536,
        "max_tokens": 8191,
        "name": "OpenAI Text-3 Small",
        "description": "API, 8,191 tokens, 1,536 dim",
        "endpoint": "https://api.openai.com/v1/embeddings",
        "adapter": "openai"
      },
      "text-embedding-3-large": {
        "id": "text-embedding-3-large",
        "batch_size": 50,
        "dims": 3072,
        "max_tokens": 8191,
        "name": "OpenAI Text-3 Large",
        "description": "API, 8,191 tokens, 3,072 dim",
        "endpoint": "https://api.openai.com/v1/embeddings",
        "adapter": "openai"
      },
      "text-embedding-3-small-512": {
        "id": "text-embedding-3-small",
        "batch_size": 50,
        "dims": 512,
        "max_tokens": 8191,
        "name": "OpenAI Text-3 Small - 512",
        "description": "API, 8,191 tokens, 512 dim",
        "endpoint": "https://api.openai.com/v1/embeddings",
        "adapter": "openai"
      },
      "text-embedding-3-large-256": {
        "id": "text-embedding-3-large",
        "batch_size": 50,
        "dims": 256,
        "max_tokens": 8191,
        "name": "OpenAI Text-3 Large - 256",
        "description": "API, 8,191 tokens, 256 dim",
        "endpoint": "https://api.openai.com/v1/embeddings",
        "adapter": "openai"
      },
      "text-embedding-ada-002": {
        "id": "text-embedding-ada-002",
        "batch_size": 50,
        "dims": 1536,
        "max_tokens": 8191,
        "name": "OpenAI Ada",
        "description": "API, 8,191 tokens, 1,536 dim",
        "endpoint": "https://api.openai.com/v1/embeddings",
        "adapter": "openai"
      }
    };
  }
};
var SmartEmbedOpenAIRequestAdapter = class extends SmartEmbedModelRequestAdapter {
  /**
   * Prepare request body for OpenAI API
   * @returns {Object} Request body for API
   */
  prepare_request_body() {
    const body = {
      model: this.adapter.model_config.id,
      input: this.embed_inputs
    };
    if (this.adapter.model_key.startsWith("text-embedding-3")) {
      body.dimensions = this.adapter.model_config.dims;
    }
    return body;
  }
};
var SmartEmbedOpenAIResponseAdapter = class extends SmartEmbedModelResponseAdapter {
  /**
   * Parse OpenAI API response
   * @returns {Array<Object>} Parsed embedding results
   */
  parse_response() {
    const resp = this.response;
    if (!resp || !resp.data || !resp.usage) {
      console.error("Invalid response format", resp);
      return [];
    }
    const avg_tokens = resp.usage.total_tokens / resp.data.length;
    return resp.data.map((item) => ({
      vec: item.embedding,
      tokens: avg_tokens
      // OpenAI doesn't provide tokens per item in batch requests
    }));
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-embed-model/adapters/_message.js
var SmartEmbedMessageAdapter = class extends SmartEmbedAdapter {
  /**
   * Create message adapter instance
   * @param {SmartEmbedModel} model - Parent model instance
   */
  constructor(model) {
    super(model);
    this.message_queue = {};
    this.message_id = 0;
    this.connector = null;
    this.message_prefix = `msg_${Math.random().toString(36).substr(2, 9)}_`;
  }
  /**
   * Send message and wait for response
   * @protected
   * @param {string} method - Method name to call
   * @param {Object} params - Method parameters
   * @returns {Promise<any>} Response data
   */
  async _send_message(method, params) {
    return new Promise((resolve, reject) => {
      const id = `${this.message_prefix}${this.message_id++}`;
      this.message_queue[id] = { resolve, reject };
      this._post_message({ method, params, id });
    });
  }
  /**
   * Handle response message from worker/iframe
   * @protected
   * @param {string} id - Message ID
   * @param {*} result - Response result
   * @param {Error} [error] - Response error
   */
  _handle_message_result(id, result, error) {
    if (!id.startsWith(this.message_prefix)) return;
    if (result?.model_loaded) {
      console.log("model loaded");
      this.model.model_loaded = true;
    }
    if (this.message_queue[id]) {
      if (error) {
        this.message_queue[id].reject(new Error(error));
      } else {
        this.message_queue[id].resolve(result);
      }
      delete this.message_queue[id];
    }
  }
  /**
   * Count tokens in input text
   * @param {string} input - Text to tokenize
   * @returns {Promise<Object>} Token count result
   */
  async count_tokens(input) {
    return this._send_message("count_tokens", { input });
  }
  /**
   * Generate embeddings for multiple inputs
   * @param {Array<Object>} inputs - Array of input objects
   * @returns {Promise<Array<Object>>} Processed inputs with embeddings
   */
  async embed_batch(inputs) {
    inputs = inputs.filter((item) => item.embed_input?.length > 0);
    if (!inputs.length) return [];
    const embed_inputs = inputs.map((item) => ({ embed_input: item.embed_input }));
    const result = await this._send_message("embed_batch", { inputs: embed_inputs });
    return inputs.map((item, i) => {
      item.vec = result[i].vec;
      item.tokens = result[i].tokens;
      return item;
    });
  }
  /**
   * Post message to worker/iframe
   * @abstract
   * @protected
   * @param {Object} message_data - Message to send
   * @throws {Error} If not implemented by subclass
   */
  _post_message(message_data) {
    throw new Error("_post_message must be implemented by subclass");
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-embed-model/adapters/iframe.js
var SmartEmbedIframeAdapter = class extends SmartEmbedMessageAdapter {
  /**
   * Create iframe adapter instance
   * @param {SmartEmbedModel} model - Parent model instance
   */
  constructor(model) {
    super(model);
    this.iframe = null;
    this.origin = window.location.origin;
    this.iframe_id = `smart_embed_iframe`;
  }
  /**
   * Initialize iframe and load model
   * @returns {Promise<void>}
   */
  async load() {
    const existing_iframe = document.getElementById(this.iframe_id);
    if (existing_iframe) {
      existing_iframe.remove();
    }
    this.iframe = document.createElement("iframe");
    this.iframe.style.display = "none";
    this.iframe.id = this.iframe_id;
    document.body.appendChild(this.iframe);
    window.addEventListener("message", this._handle_message.bind(this));
    this.iframe.srcdoc = `
          <html>
            <body>
              <script type="module">
                ${this.connector}
                // Set up a message listener in the iframe
                window.addEventListener('message', async (event) => {
                    if (event.origin !== '${this.origin}' || event.data.iframe_id !== '${this.iframe_id}') return console.log('message ignored (listener)', event);
                    // Process the message and send the response back
                    const response = await process_message(event.data);
                    window.parent.postMessage({ ...response, iframe_id: '${this.iframe_id}' }, '${this.origin}');
                });
              </script>
            </body>
          </html>
        `;
    await new Promise((resolve) => this.iframe.onload = resolve);
    const load_opts = {
      // ...this.model.opts,
      model_key: this.model.model_key,
      adapters: null,
      // cannot clone classes
      settings: null,
      batch_size: this.batch_size,
      use_gpu: this.use_gpu
    };
    await this._send_message("load", load_opts);
    return new Promise((resolve) => {
      const check_model_loaded = () => {
        if (this.model.model_loaded) {
          resolve();
        } else {
          setTimeout(check_model_loaded, 100);
        }
      };
      check_model_loaded();
    });
  }
  /**
   * Post message to iframe
   * @protected
   * @param {Object} message_data - Message to send
   */
  _post_message(message_data) {
    this.iframe.contentWindow.postMessage({ ...message_data, iframe_id: this.iframe_id }, this.origin);
  }
  /**
   * Handle message from iframe
   * @private
   * @param {MessageEvent} event - Message event
   */
  _handle_message(event) {
    if (event.origin !== this.origin || event.data.iframe_id !== this.iframe_id) return;
    const { id, result, error } = event.data;
    this._handle_message_result(id, result, error);
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-embed-model/connectors/transformers_iframe.js
var transformers_connector = 'var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);\n  return value;\n};\n\n// ../smart-model/smart_model.js\nvar SmartModel = class {\n  /**\n   * Create a SmartModel instance.\n   * @param {Object} opts - Configuration options\n   * @param {Object} opts.adapters - Map of adapter names to adapter classes\n   * @param {Object} opts.settings - Model settings configuration\n   * @param {Object} opts.model_config - Model-specific configuration\n   * @param {string} opts.model_config.adapter - Name of the adapter to use\n   * @param {string} [opts.model_key] - Optional model identifier to override settings\n   * @throws {Error} If required options are missing\n   */\n  constructor(opts = {}) {\n    __publicField(this, "scope_name", "smart_model");\n    this.opts = opts;\n    this.validate_opts(opts);\n    this.state = "unloaded";\n    this._adapter = null;\n  }\n  /**\n   * Initialize the model by loading the configured adapter.\n   * @async\n   * @returns {Promise<void>}\n   */\n  async initialize() {\n    this.load_adapter(this.adapter_name);\n    await this.load();\n  }\n  /**\n   * Validate required options.\n   * @param {Object} opts - Configuration options\n   */\n  validate_opts(opts) {\n    if (!opts.adapters)\n      throw new Error("opts.adapters is required");\n    if (!opts.settings)\n      throw new Error("opts.settings is required");\n  }\n  /**\n   * Get the current settings\n   * @returns {Object} Current settings\n   */\n  get settings() {\n    if (!this.opts.settings)\n      this.opts.settings = {\n        ...this.constructor.defaults\n      };\n    return this.opts.settings;\n  }\n  /**\n   * Get the current adapter name\n   * @returns {string} Current adapter name\n   */\n  get adapter_name() {\n    let adapter_key = this.opts.model_config?.adapter || this.opts.adapter || this.settings.adapter || Object.keys(this.adapters)[0];\n    if (!adapter_key || !this.adapters[adapter_key]) {\n      console.warn(`Platform "${adapter_key}" not supported`);\n      adapter_key = Object.keys(this.adapters)[0];\n    }\n    return adapter_key;\n  }\n  /**\n   * Get adapter-specific settings.\n   * @returns {Object} Settings for current adapter\n   */\n  get adapter_settings() {\n    if (!this.settings[this.adapter_name])\n      this.settings[this.adapter_name] = {};\n    return this.settings[this.adapter_name];\n  }\n  get adapter_config() {\n    const base_config = this.adapters[this.adapter_name]?.defaults || {};\n    return {\n      ...base_config,\n      ...this.adapter_settings,\n      ...this.opts.adapter_config\n    };\n  }\n  /**\n   * Get available models.\n   * @returns {Object} Map of model objects\n   */\n  get models() {\n    return this.adapter.models;\n  }\n  /**\n   * Get default model key.\n   * @returns {string} Default model key\n   */\n  get default_model_key() {\n    return this.adapter.constructor.defaults.default_model;\n  }\n  /**\n   * Get the current model key\n   * @returns {string} Current model key\n   */\n  get model_key() {\n    return this.opts.model_key || this.adapter_config.model_key || this.settings.model_key || this.default_model_key;\n  }\n  /**\n   * Get the current model configuration\n   * @returns {Object} Combined base and custom model configuration\n   */\n  get model_config() {\n    const model_key = this.model_key;\n    const base_model_config = this.models[model_key] || {};\n    return {\n      ...this.adapter_config,\n      ...base_model_config,\n      ...this.opts.model_config\n    };\n  }\n  get model_settings() {\n    if (!this.settings[this.model_key])\n      this.settings[this.model_key] = {};\n    return this.settings[this.model_key];\n  }\n  /**\n   * Load the current adapter and transition to loaded state.\n   * @async\n   * @returns {Promise<void>}\n   */\n  async load() {\n    this.set_state("loading");\n    try {\n      if (!this.adapter?.is_loaded) {\n        await this.invoke_adapter_method("load");\n      }\n    } catch (err) {\n      this.set_state("unloaded");\n      if (!this.reload_model_timeout) {\n        this.reload_model_timeout = setTimeout(async () => {\n          this.reload_model_timeout = null;\n          await this.load();\n          this.set_state("loaded");\n          this.notices?.show("Loaded model: " + this.model_key);\n        }, 6e4);\n      }\n      throw new Error(`Failed to load model: ${err.message}`);\n    }\n    this.set_state("loaded");\n  }\n  /**\n   * Unload the current adapter and transition to unloaded state.\n   * @async\n   * @returns {Promise<void>}\n   */\n  async unload() {\n    if (this.adapter?.is_loaded) {\n      this.set_state("unloading");\n      await this.invoke_adapter_method("unload");\n      this.set_state("unloaded");\n    }\n  }\n  /**\n   * Set the model\'s state.\n   * @param {(\'unloaded\'|\'loading\'|\'loaded\'|\'unloading\')} new_state - The new state\n   * @throws {Error} If the state is invalid\n   */\n  set_state(new_state) {\n    const valid_states = ["unloaded", "loading", "loaded", "unloading"];\n    if (!valid_states.includes(new_state)) {\n      throw new Error(`Invalid state: ${new_state}`);\n    }\n    this.state = new_state;\n  }\n  get is_loading() {\n    return this.state === "loading";\n  }\n  get is_loaded() {\n    return this.state === "loaded";\n  }\n  get is_unloading() {\n    return this.state === "unloading";\n  }\n  get is_unloaded() {\n    return this.state === "unloaded";\n  }\n  // ADAPTERS\n  /**\n   * Get the map of available adapters\n   * @returns {Object} Map of adapter names to adapter classes\n   */\n  get adapters() {\n    return this.opts.adapters || {};\n  }\n  /**\n   * Load a specific adapter by name.\n   * @async\n   * @param {string} adapter_name - Name of the adapter to load\n   * @throws {Error} If adapter not found or loading fails\n   * @returns {Promise<void>}\n   */\n  async load_adapter(adapter_name) {\n    this.set_adapter(adapter_name);\n    if (!this._adapter.loaded) {\n      this.set_state("loading");\n      try {\n        await this.invoke_adapter_method("load");\n        this.set_state("loaded");\n      } catch (err) {\n        this.set_state("unloaded");\n        throw new Error(`Failed to load adapter: ${err.message}`);\n      }\n    }\n  }\n  /**\n   * Set an adapter instance by name without loading it.\n   * @param {string} adapter_name - Name of the adapter to set\n   * @throws {Error} If adapter not found\n   */\n  set_adapter(adapter_name) {\n    const AdapterClass = this.adapters[adapter_name];\n    if (!AdapterClass) {\n      throw new Error(`Adapter "${adapter_name}" not found.`);\n    }\n    if (this._adapter?.constructor.name.toLowerCase() === adapter_name.toLowerCase()) {\n      return;\n    }\n    this._adapter = new AdapterClass(this);\n  }\n  /**\n   * Get the current active adapter instance\n   * @returns {Object} The active adapter instance\n   * @throws {Error} If adapter not found\n   */\n  get adapter() {\n    const adapter_name = this.adapter_name;\n    if (!adapter_name) {\n      throw new Error(`Adapter not set for model.`);\n    }\n    if (!this._adapter) {\n      this.load_adapter(adapter_name);\n    }\n    return this._adapter;\n  }\n  /**\n   * Ensure the adapter is ready to execute a method.\n   * @param {string} method - Name of the method to check\n   * @throws {Error} If adapter not loaded or method not implemented\n   */\n  ensure_adapter_ready(method) {\n    if (!this.adapter) {\n      throw new Error("No adapter loaded.");\n    }\n    if (typeof this.adapter[method] !== "function") {\n      throw new Error(`Adapter does not implement method: ${method}`);\n    }\n  }\n  /**\n   * Invoke a method on the current adapter.\n   * @async\n   * @param {string} method - Name of the method to call\n   * @param {...any} args - Arguments to pass to the method\n   * @returns {Promise<any>} Result from the adapter method\n   * @throws {Error} If adapter not ready or method fails\n   */\n  async invoke_adapter_method(method, ...args) {\n    this.ensure_adapter_ready(method);\n    return await this.adapter[method](...args);\n  }\n  /**\n   * Get platforms as dropdown options.\n   * @returns {Array<Object>} Array of {value, name} option objects\n   */\n  get_platforms_as_options() {\n    return Object.entries(this.adapters).map(([key, AdapterClass]) => ({ value: key, name: AdapterClass.defaults.description || key }));\n  }\n  // SETTINGS\n  /**\n   * Get the settings configuration schema\n   * @returns {Object} Settings configuration object\n   */\n  get settings_config() {\n    return this.process_settings_config({\n      adapter: {\n        name: "Model Platform",\n        type: "dropdown",\n        description: "Select a model platform to use with Smart Model.",\n        options_callback: "get_platforms_as_options",\n        is_scope: true,\n        // trigger re-render of settings when changed\n        callback: "adapter_changed",\n        default: "default"\n      }\n    });\n  }\n  /**\n   * Process settings configuration with conditionals and prefixes.\n   * @param {Object} _settings_config - Raw settings configuration\n   * @param {string} [prefix] - Optional prefix for setting keys\n   * @returns {Object} Processed settings configuration\n   */\n  process_settings_config(_settings_config, prefix = null) {\n    return Object.entries(_settings_config).reduce((acc, [key, val]) => {\n      const new_key = (prefix ? prefix + "." : "") + this.process_setting_key(key);\n      acc[new_key] = val;\n      return acc;\n    }, {});\n  }\n  /**\n   * Process an individual setting key.\n   * Example: replace placeholders with actual adapter names.\n   * @param {string} key - The setting key with placeholders.\n   * @returns {string} Processed setting key.\n   */\n  process_setting_key(key) {\n    return key.replace(/\\[ADAPTER\\]/g, this.adapter_name);\n  }\n  re_render_settings() {\n    if (typeof this.opts.re_render_settings === "function")\n      this.opts.re_render_settings();\n    else\n      console.warn("re_render_settings is not a function (must be passed in model opts)");\n  }\n  /**\n   * Reload model.\n   */\n  reload_model() {\n    if (typeof this.opts.reload_model === "function")\n      this.opts.reload_model();\n    else\n      console.warn("reload_model is not a function (must be passed in model opts)");\n  }\n  adapter_changed() {\n    this.reload_model();\n    this.re_render_settings();\n  }\n  model_changed() {\n    this.reload_model();\n    this.re_render_settings();\n  }\n};\n__publicField(SmartModel, "defaults", {\n  // override in sub-class if needed\n});\n\n// smart_embed_model.js\nvar SmartEmbedModel = class extends SmartModel {\n  /**\n   * Create a SmartEmbedModel instance\n   * @param {Object} opts - Configuration options\n   * @param {Object} [opts.adapters] - Map of available adapter implementations\n   * @param {boolean} [opts.use_gpu] - Whether to enable GPU acceleration\n   * @param {number} [opts.gpu_batch_size] - Batch size when using GPU\n   * @param {number} [opts.batch_size] - Default batch size for processing\n   * @param {Object} [opts.model_config] - Model-specific configuration\n   * @param {string} [opts.model_config.adapter] - Override adapter type\n   * @param {number} [opts.model_config.dims] - Embedding dimensions\n   * @param {number} [opts.model_config.max_tokens] - Maximum tokens to process\n   * @param {Object} [opts.settings] - User settings\n   * @param {string} [opts.settings.api_key] - API key for remote models\n   * @param {number} [opts.settings.min_chars] - Minimum text length to embed\n   */\n  constructor(opts = {}) {\n    super(opts);\n    __publicField(this, "scope_name", "smart_embed_model");\n  }\n  /**\n   * Count tokens in an input string\n   * @param {string} input - Text to tokenize\n   * @returns {Promise<Object>} Token count result\n   * @property {number} tokens - Number of tokens in input\n   * \n   * @example\n   * ```javascript\n   * const result = await model.count_tokens("Hello world");\n   * console.log(result.tokens); // 2\n   * ```\n   */\n  async count_tokens(input) {\n    return await this.invoke_adapter_method("count_tokens", input);\n  }\n  /**\n   * Generate embeddings for a single input\n   * @param {string|Object} input - Text or object with embed_input property\n   * @returns {Promise<Object>} Embedding result\n   * @property {number[]} vec - Embedding vector\n   * @property {number} tokens - Token count\n   * \n   * @example\n   * ```javascript\n   * const result = await model.embed("Hello world");\n   * console.log(result.vec); // [0.1, 0.2, ...]\n   * ```\n   */\n  async embed(input) {\n    if (typeof input === "string")\n      input = { embed_input: input };\n    return (await this.embed_batch([input]))[0];\n  }\n  /**\n   * Generate embeddings for multiple inputs in batch\n   * @param {Array<string|Object>} inputs - Array of texts or objects with embed_input\n   * @returns {Promise<Array<Object>>} Array of embedding results\n   * @property {number[]} vec - Embedding vector for each input\n   * @property {number} tokens - Token count for each input\n   * \n   * @example\n   * ```javascript\n   * const results = await model.embed_batch([\n   *   { embed_input: "First text" },\n   *   { embed_input: "Second text" }\n   * ]);\n   * ```\n   */\n  async embed_batch(inputs) {\n    return await this.invoke_adapter_method("embed_batch", inputs);\n  }\n  /**\n   * Get the current batch size based on GPU settings\n   * @returns {number} Current batch size for processing\n   */\n  get batch_size() {\n    return this.adapter.batch_size || 1;\n  }\n  /**\n   * Get settings configuration schema\n   * @returns {Object} Settings configuration object\n   */\n  get settings_config() {\n    const _settings_config = {\n      adapter: {\n        name: "Embedding model platform",\n        type: "dropdown",\n        description: "Select an embedding model platform. The default \'transformers\' utilizes built-in local models.",\n        options_callback: "get_platforms_as_options",\n        callback: "adapter_changed",\n        default: this.constructor.defaults.adapter\n      },\n      ...this.adapter.settings_config || {}\n    };\n    return this.process_settings_config(_settings_config);\n  }\n  process_setting_key(key) {\n    return key.replace(/\\[ADAPTER\\]/g, this.adapter_name);\n  }\n  /**\n   * Get available embedding model options\n   * @returns {Array<Object>} Array of model options with value and name\n   */\n  get_embedding_model_options() {\n    return Object.entries(this.models).map(([key, model2]) => ({ value: key, name: key }));\n  }\n  // /**\n  //  * Get embedding model options including \'None\' option\n  //  * @returns {Array<Object>} Array of model options with value and name\n  //  */\n  // get_block_embedding_model_options() {\n  //   const options = this.get_embedding_model_options();\n  //   options.unshift({ value: \'None\', name: \'None\' });\n  //   return options;\n  // }\n};\n__publicField(SmartEmbedModel, "defaults", {\n  adapter: "transformers"\n});\n\n// ../smart-model/adapters/_adapter.js\nvar SmartModelAdapter = class {\n  /**\n   * Create a SmartModelAdapter instance.\n   * @param {SmartModel} model - The parent SmartModel instance\n   */\n  constructor(model2) {\n    this.model = model2;\n    this.state = "unloaded";\n  }\n  /**\n   * Load the adapter.\n   * @async\n   * @returns {Promise<void>}\n   */\n  async load() {\n    this.set_state("loaded");\n  }\n  /**\n   * Unload the adapter.\n   * @returns {void}\n   */\n  unload() {\n    this.set_state("unloaded");\n  }\n  /**\n   * Get all settings.\n   * @returns {Object} All settings\n   */\n  get settings() {\n    return this.model.settings;\n  }\n  /**\n   * Get the current model key.\n   * @returns {string} Current model identifier\n   */\n  get model_key() {\n    return this.model.model_key;\n  }\n  /**\n   * Get the current model configuration.\n   * @returns {Object} Model configuration\n   */\n  get model_config() {\n    return this.model.model_config;\n  }\n  /**\n   * Get model-specific settings.\n   * @returns {Object} Settings for current model\n   */\n  get model_settings() {\n    return this.model.model_settings;\n  }\n  /**\n   * Get adapter-specific configuration.\n   * @returns {Object} Adapter configuration\n   */\n  get adapter_config() {\n    return this.model.adapter_config;\n  }\n  /**\n   * Get adapter-specific settings.\n   * @returns {Object} Adapter settings\n   */\n  get adapter_settings() {\n    return this.model.adapter_settings;\n  }\n  /**\n   * Get the models.\n   * @returns {Object} Map of model objects\n   */\n  get models() {\n    if (typeof this.adapter_config.models === "object" && Object.keys(this.adapter_config.models || {}).length > 0)\n      return this.adapter_config.models;\n    else {\n      return {};\n    }\n  }\n  /**\n   * Get available models from the API.\n   * @abstract\n   * @param {boolean} [refresh=false] - Whether to refresh cached models\n   * @returns {Promise<Object>} Map of model objects\n   */\n  async get_models(refresh = false) {\n    throw new Error("get_models not implemented");\n  }\n  /**\n   * Validate the parameters for get_models.\n   * @returns {boolean|Array<Object>} True if parameters are valid, otherwise an array of error objects\n   */\n  validate_get_models_params() {\n    return true;\n  }\n  /**\n   * Get available models as dropdown options synchronously.\n   * @returns {Array<Object>} Array of model options.\n   */\n  get_models_as_options() {\n    const models = this.models;\n    const params_valid = this.validate_get_models_params();\n    if (params_valid !== true)\n      return params_valid;\n    if (!Object.keys(models || {}).length) {\n      this.get_models(true);\n      return [{ value: "", name: "No models currently available" }];\n    }\n    return Object.entries(models).map(([id, model2]) => ({ value: id, name: model2.name || id })).sort((a, b) => a.name.localeCompare(b.name));\n  }\n  /**\n   * Set the adapter\'s state.\n   * @deprecated should be handled in SmartModel (only handle once)\n   * @param {(\'unloaded\'|\'loading\'|\'loaded\'|\'unloading\')} new_state - The new state\n   * @throws {Error} If the state is invalid\n   */\n  set_state(new_state) {\n    const valid_states = ["unloaded", "loading", "loaded", "unloading"];\n    if (!valid_states.includes(new_state)) {\n      throw new Error(`Invalid state: ${new_state}`);\n    }\n    this.state = new_state;\n  }\n  // Replace individual state getters/setters with a unified state management\n  get is_loading() {\n    return this.state === "loading";\n  }\n  get is_loaded() {\n    return this.state === "loaded";\n  }\n  get is_unloading() {\n    return this.state === "unloading";\n  }\n  get is_unloaded() {\n    return this.state === "unloaded";\n  }\n};\n\n// adapters/_adapter.js\nvar SmartEmbedAdapter = class extends SmartModelAdapter {\n  /**\n   * Create adapter instance\n   * @param {SmartEmbedModel} model - Parent model instance\n   */\n  constructor(model2) {\n    super(model2);\n    this.smart_embed = model2;\n  }\n  /**\n   * Count tokens in input text\n   * @abstract\n   * @param {string} input - Text to tokenize\n   * @returns {Promise<Object>} Token count result\n   * @property {number} tokens - Number of tokens in input\n   * @throws {Error} If not implemented by subclass\n   */\n  async count_tokens(input) {\n    throw new Error("count_tokens method not implemented");\n  }\n  /**\n   * Generate embeddings for single input\n   * @abstract\n   * @param {string|Object} input - Text to embed\n   * @returns {Promise<Object>} Embedding result\n   * @property {number[]} vec - Embedding vector\n   * @property {number} tokens - Number of tokens in input\n   * @throws {Error} If not implemented by subclass\n   */\n  async embed(input) {\n    throw new Error("embed method not implemented");\n  }\n  /**\n   * Generate embeddings for multiple inputs\n   * @abstract\n   * @param {Array<string|Object>} inputs - Texts to embed\n   * @returns {Promise<Array<Object>>} Array of embedding results\n   * @property {number[]} vec - Embedding vector for each input\n   * @property {number} tokens - Number of tokens in each input\n   * @throws {Error} If not implemented by subclass\n   */\n  async embed_batch(inputs) {\n    throw new Error("embed_batch method not implemented");\n  }\n  get settings_config() {\n    return {\n      "[ADAPTER].model_key": {\n        name: "Embedding model",\n        type: "dropdown",\n        description: "Select an embedding model.",\n        options_callback: "adapter.get_models_as_options",\n        callback: "model_changed",\n        default: this.constructor.defaults.default_model\n      }\n    };\n  }\n  get dims() {\n    return this.model_config.dims;\n  }\n  get max_tokens() {\n    return this.model_config.max_tokens;\n  }\n  // get batch_size() { return this.model_config.batch_size; }\n  get use_gpu() {\n    if (typeof this._use_gpu === "undefined") {\n      if (typeof this.model.opts.use_gpu !== "undefined")\n        this._use_gpu = this.model.opts.use_gpu;\n      else\n        this._use_gpu = typeof navigator !== "undefined" && !!navigator?.gpu && this.model_settings.gpu_batch_size !== 0;\n    }\n    return this._use_gpu;\n  }\n  set use_gpu(value) {\n    this._use_gpu = value;\n  }\n  get batch_size() {\n    if (this.use_gpu && this.model_config?.gpu_batch_size)\n      return this.model_config.gpu_batch_size;\n    return this.model.opts.batch_size || this.model_config.batch_size || 1;\n  }\n};\n/**\n * @override in sub-class with adapter-specific default configurations\n * @property {string} id - The adapter identifier\n * @property {string} description - Human-readable description\n * @property {string} type - Adapter type ("API")\n * @property {string} endpoint - API endpoint\n * @property {string} adapter - Adapter identifier\n * @property {string} default_model - Default model to use\n */\n__publicField(SmartEmbedAdapter, "defaults", {});\n\n// adapters/transformers.js\nvar transformers_defaults = {\n  adapter: "transformers",\n  description: "Transformers (Local, built-in)",\n  default_model: "TaylorAI/bge-micro-v2"\n};\nvar SmartEmbedTransformersAdapter = class extends SmartEmbedAdapter {\n  /**\n   * Create transformers adapter instance\n   * @param {SmartEmbedModel} model - Parent model instance\n   */\n  constructor(model2) {\n    super(model2);\n    this.pipeline = null;\n    this.tokenizer = null;\n  }\n  /**\n   * Load model and tokenizer\n   * @returns {Promise<void>}\n   */\n  async load() {\n    await this.load_transformers();\n    this.loaded = true;\n    this.set_state("loaded");\n  }\n  /**\n   * Unload model and free resources\n   * @returns {Promise<void>}\n   */\n  async unload() {\n    if (this.pipeline) {\n      if (this.pipeline.destroy)\n        this.pipeline.destroy();\n      this.pipeline = null;\n    }\n    if (this.tokenizer) {\n      this.tokenizer = null;\n    }\n    this.loaded = false;\n    this.set_state("unloaded");\n  }\n  /**\n   * Initialize transformers pipeline and tokenizer\n   * @private\n   * @returns {Promise<void>}\n   */\n  async load_transformers() {\n    const { pipeline, env, AutoTokenizer } = await import("@huggingface/transformers");\n    env.allowLocalModels = false;\n    const pipeline_opts = {\n      quantized: true\n    };\n    if (this.use_gpu) {\n      console.log("[Transformers] Using GPU");\n      pipeline_opts.device = "webgpu";\n      pipeline_opts.dtype = "fp32";\n    } else {\n      console.log("[Transformers] Using CPU");\n      env.backends.onnx.wasm.numThreads = 8;\n    }\n    this.pipeline = await pipeline("feature-extraction", this.model_key, pipeline_opts);\n    this.tokenizer = await AutoTokenizer.from_pretrained(this.model_key);\n  }\n  /**\n   * Count tokens in input text\n   * @param {string} input - Text to tokenize\n   * @returns {Promise<Object>} Token count result\n   */\n  async count_tokens(input) {\n    if (!this.tokenizer)\n      await this.load();\n    const { input_ids } = await this.tokenizer(input);\n    return { tokens: input_ids.data.length };\n  }\n  /**\n   * Generate embeddings for multiple inputs\n   * @param {Array<Object>} inputs - Array of input objects\n   * @returns {Promise<Array<Object>>} Processed inputs with embeddings\n   */\n  async embed_batch(inputs) {\n    if (!this.pipeline)\n      await this.load();\n    const filtered_inputs = inputs.filter((item) => item.embed_input?.length > 0);\n    if (!filtered_inputs.length)\n      return [];\n    if (filtered_inputs.length > this.batch_size) {\n      console.log(`Processing ${filtered_inputs.length} inputs in batches of ${this.batch_size}`);\n      const results = [];\n      for (let i = 0; i < filtered_inputs.length; i += this.batch_size) {\n        const batch = filtered_inputs.slice(i, i + this.batch_size);\n        const batch_results = await this._process_batch(batch);\n        results.push(...batch_results);\n      }\n      return results;\n    }\n    return await this._process_batch(filtered_inputs);\n  }\n  /**\n   * Process a single batch of inputs\n   * @private\n   * @param {Array<Object>} batch_inputs - Batch of inputs to process\n   * @returns {Promise<Array<Object>>} Processed batch results\n   */\n  async _process_batch(batch_inputs) {\n    const tokens = await Promise.all(batch_inputs.map((item) => this.count_tokens(item.embed_input)));\n    const embed_inputs = await Promise.all(batch_inputs.map(async (item, i) => {\n      if (tokens[i].tokens < this.max_tokens)\n        return item.embed_input;\n      let token_ct = tokens[i].tokens;\n      let truncated_input = item.embed_input;\n      while (token_ct > this.max_tokens) {\n        const pct = this.max_tokens / token_ct;\n        const max_chars = Math.floor(truncated_input.length * pct * 0.9);\n        truncated_input = truncated_input.substring(0, max_chars) + "...";\n        token_ct = (await this.count_tokens(truncated_input)).tokens;\n      }\n      tokens[i].tokens = token_ct;\n      return truncated_input;\n    }));\n    try {\n      const resp = await this.pipeline(embed_inputs, { pooling: "mean", normalize: true });\n      return batch_inputs.map((item, i) => {\n        item.vec = Array.from(resp[i].data).map((val) => Math.round(val * 1e8) / 1e8);\n        item.tokens = tokens[i].tokens;\n        return item;\n      });\n    } catch (err) {\n      console.error("error_processing_batch", err);\n      this.pipeline?.dispose();\n      this.pipeline = null;\n      await this.load();\n      return Promise.all(batch_inputs.map(async (item) => {\n        try {\n          const result = await this.pipeline(item.embed_input, { pooling: "mean", normalize: true });\n          item.vec = Array.from(result[0].data).map((val) => Math.round(val * 1e8) / 1e8);\n          item.tokens = (await this.count_tokens(item.embed_input)).tokens;\n          return item;\n        } catch (single_err) {\n          console.error("error_processing_single_item", single_err);\n          return {\n            ...item,\n            vec: [],\n            tokens: 0,\n            error: single_err.message\n          };\n        }\n      }));\n    }\n  }\n  /** @returns {Object} Settings configuration for transformers adapter */\n  get settings_config() {\n    return transformers_settings_config;\n  }\n  /**\n   * Get available models (hardcoded list)\n   * @returns {Promise<Object>} Map of model objects\n   */\n  get_models() {\n    return Promise.resolve(this.models);\n  }\n  get models() {\n    return transformers_models;\n  }\n};\n__publicField(SmartEmbedTransformersAdapter, "defaults", transformers_defaults);\nvar transformers_models = {\n  "TaylorAI/bge-micro-v2": {\n    "id": "TaylorAI/bge-micro-v2",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 512,\n    "name": "BGE-micro-v2",\n    "description": "Local, 512 tokens, 384 dim (recommended)",\n    "adapter": "transformers"\n  },\n  "Snowflake/snowflake-arctic-embed-xs": {\n    "id": "Snowflake/snowflake-arctic-embed-xs",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 512,\n    "name": "Snowflake Arctic Embed XS",\n    "description": "Local, 512 tokens, 384 dim",\n    "adapter": "transformers"\n  },\n  "Snowflake/snowflake-arctic-embed-s": {\n    "id": "Snowflake/snowflake-arctic-embed-s",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 512,\n    "name": "Snowflake Arctic Embed Small",\n    "description": "Local, 512 tokens, 384 dim",\n    "adapter": "transformers"\n  },\n  "Snowflake/snowflake-arctic-embed-m": {\n    "id": "Snowflake/snowflake-arctic-embed-m",\n    "batch_size": 1,\n    "dims": 768,\n    "max_tokens": 512,\n    "name": "Snowflake Arctic Embed Medium",\n    "description": "Local, 512 tokens, 768 dim",\n    "adapter": "transformers"\n  },\n  "TaylorAI/gte-tiny": {\n    "id": "TaylorAI/gte-tiny",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 512,\n    "name": "GTE-tiny",\n    "description": "Local, 512 tokens, 384 dim",\n    "adapter": "transformers"\n  },\n  "Mihaiii/Ivysaur": {\n    "id": "Mihaiii/Ivysaur",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 512,\n    "name": "Ivysaur",\n    "description": "Local, 512 tokens, 384 dim",\n    "adapter": "transformers"\n  },\n  "andersonbcdefg/bge-small-4096": {\n    "id": "andersonbcdefg/bge-small-4096",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 4096,\n    "name": "BGE-small-4K",\n    "description": "Local, 4,096 tokens, 384 dim",\n    "adapter": "transformers"\n  },\n  // Too slow and persistent crashes\n  // "jinaai/jina-embeddings-v2-base-de": {\n  //   "id": "jinaai/jina-embeddings-v2-base-de",\n  //   "batch_size": 1,\n  //   "dims": 768,\n  //   "max_tokens": 4096,\n  //   "name": "jina-embeddings-v2-base-de",\n  //   "description": "Local, 4,096 tokens, 768 dim, German",\n  //   "adapter": "transformers"\n  // },\n  "Xenova/jina-embeddings-v2-base-zh": {\n    "id": "Xenova/jina-embeddings-v2-base-zh",\n    "batch_size": 1,\n    "dims": 768,\n    "max_tokens": 8192,\n    "name": "Jina-v2-base-zh-8K",\n    "description": "Local, 8,192 tokens, 768 dim, Chinese/English bilingual",\n    "adapter": "transformers"\n  },\n  "Xenova/jina-embeddings-v2-small-en": {\n    "id": "Xenova/jina-embeddings-v2-small-en",\n    "batch_size": 1,\n    "dims": 512,\n    "max_tokens": 8192,\n    "name": "Jina-v2-small-en",\n    "description": "Local, 8,192 tokens, 512 dim",\n    "adapter": "transformers"\n  },\n  "nomic-ai/nomic-embed-text-v1.5": {\n    "id": "nomic-ai/nomic-embed-text-v1.5",\n    "batch_size": 1,\n    "dims": 768,\n    "max_tokens": 2048,\n    "name": "Nomic-embed-text-v1.5",\n    "description": "Local, 8,192 tokens, 768 dim",\n    "adapter": "transformers"\n  },\n  "Xenova/bge-small-en-v1.5": {\n    "id": "Xenova/bge-small-en-v1.5",\n    "batch_size": 1,\n    "dims": 384,\n    "max_tokens": 512,\n    "name": "BGE-small",\n    "description": "Local, 512 tokens, 384 dim",\n    "adapter": "transformers"\n  },\n  "nomic-ai/nomic-embed-text-v1": {\n    "id": "nomic-ai/nomic-embed-text-v1",\n    "batch_size": 1,\n    "dims": 768,\n    "max_tokens": 2048,\n    "name": "Nomic-embed-text",\n    "description": "Local, 2,048 tokens, 768 dim",\n    "adapter": "transformers"\n  }\n};\nvar transformers_settings_config = {\n  "[ADAPTER].gpu_batch_size": {\n    name: "GPU batch size",\n    type: "number",\n    description: "Number of embeddings to process per batch on GPU. Use 0 to disable GPU.",\n    placeholder: "Enter number ex. 10"\n  },\n  "[ADAPTER].legacy_transformers": {\n    name: "Legacy transformers (no GPU)",\n    type: "toggle",\n    description: "Use legacy transformers (v2) instead of v3. This may resolve issues if the local embedding isn\'t working.",\n    callback: "embed_model_changed",\n    default: true\n  }\n};\n\n// build/transformers_iframe_script.js\nvar model = null;\nasync function process_message(data) {\n  const { method, params, id, iframe_id } = data;\n  try {\n    let result;\n    switch (method) {\n      case "init":\n        console.log("init");\n        break;\n      case "load":\n        console.log("load", params);\n        model = new SmartEmbedModel({\n          ...params,\n          adapters: { transformers: SmartEmbedTransformersAdapter },\n          adapter: "transformers",\n          settings: {}\n        });\n        await model.load();\n        result = { model_loaded: true };\n        break;\n      case "embed_batch":\n        if (!model)\n          throw new Error("Model not loaded");\n        result = await model.embed_batch(params.inputs);\n        break;\n      case "count_tokens":\n        if (!model)\n          throw new Error("Model not loaded");\n        result = await model.count_tokens(params);\n        break;\n      default:\n        throw new Error(`Unknown method: ${method}`);\n    }\n    return { id, result, iframe_id };\n  } catch (error) {\n    console.error("Error processing message:", error);\n    return { id, error: error.message, iframe_id };\n  }\n}\nprocess_message({ method: "init" });\n';

// node_modules/obsidian-smart-env/node_modules/smart-embed-model/adapters/transformers.js
var transformers_defaults = {
  adapter: "transformers",
  description: "Transformers (Local, built-in)",
  default_model: "TaylorAI/bge-micro-v2"
};
var transformers_models = {
  "TaylorAI/bge-micro-v2": {
    "id": "TaylorAI/bge-micro-v2",
    "batch_size": 1,
    "dims": 384,
    "max_tokens": 512,
    "name": "BGE-micro-v2",
    "description": "Local, 512 tokens, 384 dim (recommended)",
    "adapter": "transformers"
  },
  "Snowflake/snowflake-arctic-embed-xs": {
    "id": "Snowflake/snowflake-arctic-embed-xs",
    "batch_size": 1,
    "dims": 384,
    "max_tokens": 512,
    "name": "Snowflake Arctic Embed XS",
    "description": "Local, 512 tokens, 384 dim",
    "adapter": "transformers"
  },
  "Snowflake/snowflake-arctic-embed-s": {
    "id": "Snowflake/snowflake-arctic-embed-s",
    "batch_size": 1,
    "dims": 384,
    "max_tokens": 512,
    "name": "Snowflake Arctic Embed Small",
    "description": "Local, 512 tokens, 384 dim",
    "adapter": "transformers"
  },
  "Snowflake/snowflake-arctic-embed-m": {
    "id": "Snowflake/snowflake-arctic-embed-m",
    "batch_size": 1,
    "dims": 768,
    "max_tokens": 512,
    "name": "Snowflake Arctic Embed Medium",
    "description": "Local, 512 tokens, 768 dim",
    "adapter": "transformers"
  },
  "TaylorAI/gte-tiny": {
    "id": "TaylorAI/gte-tiny",
    "batch_size": 1,
    "dims": 384,
    "max_tokens": 512,
    "name": "GTE-tiny",
    "description": "Local, 512 tokens, 384 dim",
    "adapter": "transformers"
  },
  "Mihaiii/Ivysaur": {
    "id": "Mihaiii/Ivysaur",
    "batch_size": 1,
    "dims": 384,
    "max_tokens": 512,
    "name": "Ivysaur",
    "description": "Local, 512 tokens, 384 dim",
    "adapter": "transformers"
  },
  "andersonbcdefg/bge-small-4096": {
    "id": "andersonbcdefg/bge-small-4096",
    "batch_size": 1,
    "dims": 384,
    "max_tokens": 4096,
    "name": "BGE-small-4K",
    "description": "Local, 4,096 tokens, 384 dim",
    "adapter": "transformers"
  },
  // Too slow and persistent crashes
  // "jinaai/jina-embeddings-v2-base-de": {
  //   "id": "jinaai/jina-embeddings-v2-base-de",
  //   "batch_size": 1,
  //   "dims": 768,
  //   "max_tokens": 4096,
  //   "name": "jina-embeddings-v2-base-de",
  //   "description": "Local, 4,096 tokens, 768 dim, German",
  //   "adapter": "transformers"
  // },
  "Xenova/jina-embeddings-v2-base-zh": {
    "id": "Xenova/jina-embeddings-v2-base-zh",
    "batch_size": 1,
    "dims": 768,
    "max_tokens": 8192,
    "name": "Jina-v2-base-zh-8K",
    "description": "Local, 8,192 tokens, 768 dim, Chinese/English bilingual",
    "adapter": "transformers"
  },
  "Xenova/jina-embeddings-v2-small-en": {
    "id": "Xenova/jina-embeddings-v2-small-en",
    "batch_size": 1,
    "dims": 512,
    "max_tokens": 8192,
    "name": "Jina-v2-small-en",
    "description": "Local, 8,192 tokens, 512 dim",
    "adapter": "transformers"
  },
  "nomic-ai/nomic-embed-text-v1.5": {
    "id": "nomic-ai/nomic-embed-text-v1.5",
    "batch_size": 1,
    "dims": 768,
    "max_tokens": 2048,
    "name": "Nomic-embed-text-v1.5",
    "description": "Local, 8,192 tokens, 768 dim",
    "adapter": "transformers"
  },
  "Xenova/bge-small-en-v1.5": {
    "id": "Xenova/bge-small-en-v1.5",
    "batch_size": 1,
    "dims": 384,
    "max_tokens": 512,
    "name": "BGE-small",
    "description": "Local, 512 tokens, 384 dim",
    "adapter": "transformers"
  },
  "nomic-ai/nomic-embed-text-v1": {
    "id": "nomic-ai/nomic-embed-text-v1",
    "batch_size": 1,
    "dims": 768,
    "max_tokens": 2048,
    "name": "Nomic-embed-text",
    "description": "Local, 2,048 tokens, 768 dim",
    "adapter": "transformers"
  }
};
var transformers_settings_config = {
  "[ADAPTER].gpu_batch_size": {
    name: "GPU batch size",
    type: "number",
    description: "Number of embeddings to process per batch on GPU. Use 0 to disable GPU.",
    placeholder: "Enter number ex. 10"
  },
  "[ADAPTER].legacy_transformers": {
    name: "Legacy transformers (no GPU)",
    type: "toggle",
    description: "Use legacy transformers (v2) instead of v3. This may resolve issues if the local embedding isn't working.",
    callback: "embed_model_changed",
    default: true
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-embed-model/adapters/transformers_iframe.js
var SmartEmbedTransformersIframeAdapter = class extends SmartEmbedIframeAdapter {
  static defaults = transformers_defaults;
  /**
   * Create transformers iframe adapter instance
   * @param {SmartEmbedModel} model - Parent model instance
   */
  constructor(model) {
    super(model);
    this.connector = transformers_connector;
    if (this.adapter_settings.legacy_transformers || !this.use_gpu) {
      this.connector = this.connector.replace("@huggingface/transformers", "https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2");
      this.use_gpu = false;
    } else this.connector = this.connector.replace("@huggingface/transformers", "https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.5.1");
  }
  /** @returns {Object} Settings configuration for transformers adapter */
  get settings_config() {
    return {
      ...super.settings_config,
      ...transformers_settings_config
    };
  }
  /**
   * Get available models (hardcoded list)
   * @returns {Promise<Object>} Map of model objects
   */
  get_models() {
    return Promise.resolve(this.models);
  }
  get models() {
    return transformers_models;
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-embed-model/adapters/ollama.js
var SmartEmbedOllamaAdapter = class extends SmartEmbedModelApiAdapter {
  static defaults = {
    description: "Ollama (Local)",
    type: "API",
    host: "http://localhost:11434",
    endpoint: "/api/embed",
    models_endpoint: "/api/tags",
    api_key: "na",
    // Not required for local instance
    streaming: false,
    // Ollama's embed API does not support streaming
    max_tokens: 512,
    // Example default, adjust based on model capabilities
    signup_url: null,
    // Not applicable for local instance
    batch_size: 30,
    models: {},
    model_key: "nomic-embed-text"
  };
  get endpoint() {
    return `${this.model_config.host}${this.model_config.endpoint}`;
  }
  get models_endpoint() {
    return `${this.model_config.host}${this.model_config.models_endpoint}`;
  }
  async load() {
    await this.get_models();
    await super.load();
  }
  /**
   * Estimate token count for input text.
   * Ollama does not expose a tokenizer so we use a character based heuristic.
   * @param {string} input - Text to tokenize
   * @returns {Promise<Object>} Token count result
   */
  async count_tokens(input) {
    return { tokens: this.estimate_tokens(input) };
  }
  /**
   * Prepare input text and ensure it fits within `max_tokens`.
   * @param {string} embed_input - Raw input text
   * @returns {Promise<string|null>} Processed input text
   */
  async prepare_embed_input(embed_input) {
    if (typeof embed_input !== "string") throw new TypeError("embed_input must be a string");
    if (embed_input.length === 0) return null;
    const { tokens } = await this.count_tokens(embed_input);
    if (tokens <= this.max_tokens) return embed_input;
    return await this.trim_input_to_max_tokens(embed_input, tokens);
  }
  /**
   * Trim input text to satisfy `max_tokens`.
   * @private
   * @param {string} embed_input - Input text
   * @param {number} tokens_ct - Existing token count
   * @returns {Promise<string|null>} Trimmed text
   */
  async trim_input_to_max_tokens(embed_input, tokens_ct) {
    const reduce_ratio = (tokens_ct - this.max_tokens) / tokens_ct;
    const new_length = Math.floor(embed_input.length * (1 - reduce_ratio));
    let trimmed_input = embed_input.slice(0, new_length);
    const last_space_index = trimmed_input.lastIndexOf(" ");
    if (last_space_index > 0) trimmed_input = trimmed_input.slice(0, last_space_index);
    const prepared = await this.prepare_embed_input(trimmed_input);
    if (prepared === null) return null;
    return prepared;
  }
  /** @returns {number} Maximum tokens for an input */
  get max_tokens() {
    return this.model_config.max_tokens || this.constructor.defaults.max_tokens;
  }
  /**
   * Get the request adapter class.
   * @returns {SmartEmbedModelOllamaRequestAdapter} The request adapter class
   */
  get req_adapter() {
    return SmartEmbedModelOllamaRequestAdapter;
  }
  /**
   * Get the response adapter class.
   * @returns {SmartEmbedModelOllamaResponseAdapter} The response adapter class
   */
  get res_adapter() {
    return SmartEmbedModelOllamaResponseAdapter;
  }
  /**
   * Get available models from local Ollama instance.
   * @param {boolean} [refresh=false] - Whether to refresh cached models
   * @returns {Promise<Object>} Map of model objects
   */
  async get_models(refresh = false) {
    if (!this.model_data || refresh) {
      const list_resp = await this.http_adapter.request({
        url: this.models_endpoint,
        method: "GET"
      });
      if (list_resp.ok === false) {
        throw new Error(`Failed to fetch models list: ${list_resp.statusText}`);
      }
      const list_data = await list_resp.json();
      const models_raw = [];
      for (const m of filter_embedding_models(list_data.models || [])) {
        const detail_resp = await this.http_adapter.request({
          url: "http://localhost:11434/api/show",
          method: "POST",
          body: JSON.stringify({ model: m.name })
        });
        models_raw.push({ ...await detail_resp.json(), name: m.name });
      }
      const model_data = this.parse_model_data(models_raw);
      this.model_data = model_data;
      this.model.re_render_settings();
      return model_data;
    }
    return this.model_data;
  }
  /**
   * Get available models as dropdown options synchronously.
   * @returns {Array<Object>} Array of model options.
   */
  get_models_as_options() {
    const models = this.model_data;
    if (!Object.keys(models || {}).length) {
      this.get_models(true);
      return [{ value: "", name: "No models currently available" }];
    }
    return Object.values(models).map((model) => ({ value: model.id, name: model.name || model.id })).sort((a, b) => a.name.localeCompare(b.name));
  }
  /**
   * Parse model data from Ollama API response.
   * @param {Object} model_data - Raw model data from Ollama
   * @returns {Object} Map of model objects with capabilities and limits
   */
  parse_model_data(model_data) {
    if (!Array.isArray(model_data)) {
      this.model_data = {};
      console.error("Invalid model data format from Ollama:", model_data);
      return {};
    }
    if (model_data.length === 0) {
      this.model_data = { "no_models_available": {
        id: "no_models_available",
        name: "No models currently available"
      } };
      return this.model_data;
    }
    this.model_data = model_data.reduce((acc, model) => {
      const info = model.model_info || {};
      const ctx = Object.entries(info).find(([k]) => k.includes("context_length"))?.[1];
      const dims = Object.entries(info).find(([k]) => k.includes("embedding_length"))?.[1];
      acc[model.name] = {
        model_name: model.name,
        id: model.name,
        multimodal: false,
        max_tokens: ctx || this.max_tokens,
        dims,
        description: model.description || `Model: ${model.name}`
      };
      return acc;
    }, {});
    this._models = this.model_data;
    return this.model_data;
  }
  /**
   * Get the models.
   * @returns {Object} Map of model objects
   */
  get models() {
    if (typeof this._models === "object" && Object.keys(this._models || {}).length > 0) return this._models;
    else {
      return {};
    }
  }
  /**
   * Override settings config to remove API key setting since not needed for local instance.
   * @returns {Object} Settings configuration object
   */
  get settings_config() {
    const config = super.settings_config;
    delete config["[ADAPTER].api_key"];
    config["[ADAPTER].host"] = {
      name: "Ollama host",
      type: "text",
      description: "Enter the host for your Ollama instance",
      default: this.constructor.defaults.host
    };
    return config;
  }
};
var SmartEmbedModelOllamaRequestAdapter = class extends SmartEmbedModelRequestAdapter {
  /**
   * Convert request to Ollama's embed API format.
   * @returns {Object} Request parameters in Ollama's format
   */
  to_platform() {
    const ollama_body = {
      model: this.adapter.model_config.model_key,
      input: this.embed_inputs
    };
    return {
      url: this.adapter.endpoint,
      method: "POST",
      headers: this.get_headers(),
      body: JSON.stringify(ollama_body)
    };
  }
  /**
   * Prepare request headers for Ollama API.
   * @returns {Object} Headers object
   */
  get_headers() {
    return {
      "Content-Type": "application/json"
    };
  }
};
var SmartEmbedModelOllamaResponseAdapter = class extends SmartEmbedModelResponseAdapter {
  /**
   * Convert Ollama's response to a standardized OpenAI-like format.
   * @returns {Array<Object>} Array of embedding results
   */
  to_openai() {
    const resp = this.response;
    if (!resp || !resp.embeddings) {
      console.error("Invalid response format from Ollama:", resp);
      return [];
    }
    const tokens = Math.ceil(resp.prompt_eval_count / this.adapter.batch_size);
    const embeddings = resp.embeddings.map((vec) => ({
      vec,
      tokens
    }));
    return embeddings;
  }
  /**
   * Parse the response object.
   * @returns {Array<Object>} Parsed embedding results
   */
  parse_response() {
    return this.to_openai();
  }
};
var is_embedding_model = (mod) => {
  return ["embed", "embedding", "bge"].some((keyword) => mod.name.toLowerCase().includes(keyword));
};
var filter_embedding_models = (models) => {
  if (!Array.isArray(models)) {
    throw new TypeError("models must be an array");
  }
  return models.filter(is_embedding_model);
};

// node_modules/obsidian-smart-env/node_modules/smart-chat-model/smart_chat_model.js
var SmartChatModel = class extends SmartModel {
  scope_name = "smart_chat_model";
  static defaults = {
    adapter: "openai"
  };
  /**
   * Create a SmartChatModel instance.
   * @param {Object} opts - Configuration options
   * @param {string} opts.adapter - Adapter to use
   * @param {Object} opts.adapters - Map of adapter names to adapter classes
   * @param {Object} opts.settings - Model settings configuration
   */
  constructor(opts = {}) {
    super(opts);
  }
  /**
   * Get available models.
   * @returns {Object} Map of model objects
   */
  get models() {
    return this.adapter.models;
  }
  get can_stream() {
    return this.adapter.constructor.defaults.streaming;
  }
  get can_use_tools() {
    return this.adapter.constructor.defaults.can_use_tools;
  }
  /**
   * Complete a chat request.
   * @param {Object} req - Request parameters
   * @returns {Promise<Object>} Completion result
   */
  async complete(req) {
    return await this.invoke_adapter_method("complete", req);
  }
  /**
   * Stream chat responses.
   * @param {Object} req - Request parameters
   * @param {Object} handlers - Event handlers for streaming
   * @param {Function} handlers.chunk - Handler for chunks: receives response object
   * @param {Function} handlers.error - Handler for errors: receives error object
   * @param {Function} handlers.done - Handler for completion: receives final response object
   * @returns {Promise<string>} Complete response text
   */
  async stream(req, handlers = {}) {
    return await this.invoke_adapter_method("stream", req, handlers);
  }
  /**
   * Stop active stream.
   */
  stop_stream() {
    this.invoke_adapter_method("stop_stream");
  }
  /**
   * Count tokens in input text.
   * @param {string|Object} input - Text to count tokens for
   * @returns {Promise<number>} Token count
   */
  async count_tokens(input) {
    return await this.invoke_adapter_method("count_tokens", input);
  }
  /**
   * Test if API key is valid.
   * @returns {Promise<boolean>} True if API key is valid
   */
  async test_api_key() {
    await this.invoke_adapter_method("test_api_key");
    this.re_render_settings();
  }
  /**
   * Get default model key.
   * @returns {string} Default model key
   */
  get default_model_key() {
    return this.adapter.constructor.defaults.default_model;
  }
  /**
   * Get current settings.
   * @returns {Object} Settings object
   */
  get settings() {
    return this.opts.settings;
  }
  /**
   * Get settings configuration.
   * @returns {Object} Settings configuration object
   */
  get settings_config() {
    const _settings_config = {
      adapter: {
        name: "Chat Model Platform",
        type: "dropdown",
        description: "Select a platform/provider for chat models.",
        options_callback: "get_platforms_as_options",
        is_scope: true,
        // trigger re-render of settings when changed
        callback: "adapter_changed"
      },
      // Merge adapter-specific settings
      ...this.adapter.settings_config || {}
    };
    return this.process_settings_config(_settings_config);
  }
  /**
   * Process setting key.
   * @param {string} key - Setting key
   * @returns {string} Processed key
   */
  process_setting_key(key) {
    return key.replace(/\[CHAT_ADAPTER\]/g, this.adapter_name);
  }
  /**
   * Validate the adapter configuration.
   * @returns {Object} Validation result with 'valid' and 'message'.
   */
  validate_config() {
    return this.adapter.validate_config();
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-chat-model/streamer.js
var SmartStreamer = class {
  constructor(url, options = {}) {
    const {
      method = "GET",
      headers = {},
      body = null,
      withCredentials = false
    } = options;
    this.url = url;
    this.method = method;
    this.headers = headers;
    this.body = body;
    this.withCredentials = withCredentials;
    this.listeners = {};
    this.readyState = this.CONNECTING;
    this.progress = 0;
    this.chunk = "";
    this.last_event_id = "";
    this.xhr = null;
    this.FIELD_SEPARATOR = ":";
    this.INITIALIZING = -1;
    this.CONNECTING = 0;
    this.OPEN = 1;
    this.CLOSED = 2;
    this.chunk_accumulator = "";
    this.chunk_splitting_regex = options.chunk_splitting_regex || /(\r\n|\n|\r)/g;
  }
  /**
   * Adds an event listener for the specified event type.
   *
   * @param {string} type - The type of the event.
   * @param {Function} listener - The listener function to be called when the event is triggered.
   */
  addEventListener(type, listener) {
    if (!this.listeners[type]) this.listeners[type] = [];
    if (!this.listeners[type].includes(listener)) this.listeners[type].push(listener);
  }
  /**
   * Removes an event listener from the SmartStreamer instance.
   *
   * @param {string} type - The type of event to remove the listener from.
   * @param {Function} listener - The listener function to remove.
   */
  removeEventListener(type, listener) {
    if (!this.listeners[type]) return;
    this.listeners[type] = this.listeners[type].filter((callback) => callback !== listener);
    if (this.listeners[type].length === 0) delete this.listeners[type];
  }
  /**
   * Dispatches an event to the appropriate event handlers.
   *
   * @param {Event} event - The event to be dispatched.
   * @returns {boolean} - Returns true if the event was successfully dispatched, false otherwise.
   */
  dispatchEvent(event) {
    if (!event) return true;
    event.source = this;
    const onHandler = "on" + event.type;
    if (Object.prototype.hasOwnProperty.call(this, onHandler)) {
      this[onHandler].call(this, event);
      if (event.defaultPrevented) return false;
    }
    if (this.listeners[event.type]) {
      this.listeners[event.type].forEach((callback) => {
        callback(event);
        return !event.defaultPrevented;
      });
    }
    return true;
  }
  /**
   * Initiates the streaming process.
   */
  stream() {
    this.#setReadyState(this.CONNECTING);
    this.xhr = new XMLHttpRequest();
    this.xhr.addEventListener("progress", this.#onStreamProgress.bind(this));
    this.xhr.addEventListener("load", this.#onStreamLoaded.bind(this));
    this.xhr.addEventListener("readystatechange", this.#checkStreamClosed.bind(this));
    this.xhr.addEventListener("error", this.#onStreamFailure.bind(this));
    this.xhr.addEventListener("abort", this.#onStreamAbort.bind(this));
    this.xhr.open(this.method, this.url);
    for (const header in this.headers) {
      this.xhr.setRequestHeader(header, this.headers[header]);
    }
    if (this.last_event_id) this.xhr.setRequestHeader("Last-Event-ID", this.last_event_id);
    this.xhr.withCredentials = this.withCredentials;
    this.xhr.send(this.body);
  }
  /**
   * Ends the streamer connection.
   * Aborts the current XHR request and sets the ready state to CLOSED.
   */
  end() {
    if (this.readyState === this.CLOSED) return;
    this.xhr.abort();
    this.xhr = null;
    this.#setReadyState(this.CLOSED);
  }
  // private methods
  #setReadyState(state) {
    const event = new CustomEvent("readyStateChange");
    event.readyState = state;
    this.readyState = state;
    this.dispatchEvent(event);
  }
  #onStreamFailure(e) {
    const event = new CustomEvent("error");
    event.data = e.currentTarget.response;
    this.dispatchEvent(event);
    this.end();
  }
  #onStreamAbort(e) {
    const event = new CustomEvent("abort");
    this.end();
  }
  #onStreamProgress(e) {
    if (!this.xhr) return;
    if (this.xhr.status !== 200) {
      this.#onStreamFailure(e);
      return;
    }
    if (this.readyState === this.CONNECTING) {
      this.dispatchEvent(new CustomEvent("open"));
      this.#setReadyState(this.OPEN);
    }
    const data = this.xhr.responseText.substring(this.progress);
    this.progress += data.length;
    const parts = data.split(this.chunk_splitting_regex);
    parts.forEach((part, index) => {
      if (part.trim().length === 0) {
        if (this.chunk) {
          this.dispatchEvent(this.#parseEventChunk(this.chunk.trim()));
          this.chunk = "";
        }
      } else {
        this.chunk += part;
        if (index === parts.length - 1 && this.xhr.readyState === XMLHttpRequest.DONE) {
          this.dispatchEvent(this.#parseEventChunk(this.chunk.trim()));
          this.chunk = "";
        }
      }
    });
  }
  #onStreamLoaded(e) {
    this.#onStreamProgress(e);
    this.dispatchEvent(this.#parseEventChunk(this.chunk));
    this.chunk = "";
  }
  #parseEventChunk(chunk) {
    if (!chunk) return console.log("no chunk");
    const event = new CustomEvent("message");
    event.data = chunk;
    event.last_event_id = this.last_event_id;
    return event;
  }
  #checkStreamClosed() {
    if (!this.xhr) return;
    if (this.xhr.readyState === XMLHttpRequest.DONE) this.#setReadyState(this.CLOSED);
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-chat-model/adapters/_adapter.js
var SmartChatModelAdapter = class extends SmartModelAdapter {
  /**
   * @override in sub-class with adapter-specific default configurations
   * @property {string} id - The adapter identifier
   * @property {string} description - Human-readable description
   * @property {string} type - Adapter type ("API")
   * @property {string} endpoint - API endpoint
   * @property {boolean} streaming - Whether streaming is supported
   * @property {string} adapter - Adapter identifier
   * @property {string} models_endpoint - Endpoint for retrieving models
   * @property {string} default_model - Default model to use
   * @property {string} signup_url - URL for API key signup
   */
  static defaults = {};
  /**
   * Create a SmartChatModelAdapter instance.
   * @param {SmartChatModel} model - The parent SmartChatModel instance
   */
  constructor(model) {
    super(model);
    this.smart_chat = model;
    this.main = model;
  }
  /**
   * Complete a chat request.
   * @abstract
   * @param {Object} req - Request parameters
   * @returns {Promise<Object>} Completion result
   */
  async complete(req) {
    throw new Error("complete not implemented");
  }
  /**
   * Count tokens in input text.
   * @abstract
   * @param {string|Object} input - Text to count tokens for
   * @returns {Promise<number>} Token count
   */
  async count_tokens(input) {
    throw new Error("count_tokens not implemented");
  }
  /**
   * Stream chat responses.
   * @abstract
   * @param {Object} req - Request parameters
   * @param {Object} handlers - Event handlers for streaming
   * @returns {Promise<string>} Complete response text
   */
  async stream(req, handlers = {}) {
    throw new Error("stream not implemented");
  }
  /**
   * Test if API key is valid.
   * @abstract
   * @returns {Promise<boolean>} True if API key is valid
   */
  async test_api_key() {
    throw new Error("test_api_key not implemented");
  }
  /**
   * Refresh available models.
   */
  refresh_models() {
    console.log("refresh_models");
    this.get_models(true);
  }
  /**
   * Get settings configuration.
   * @returns {Object} Settings configuration object
   */
  get settings_config() {
    return {
      "[CHAT_ADAPTER].model_key": {
        name: "Chat Model",
        type: "dropdown",
        description: "Select a chat model.",
        options_callback: "adapter.get_models_as_options",
        callback: "reload_model",
        default: this.constructor.defaults.default_model
      },
      "[CHAT_ADAPTER].refresh_models": {
        name: "Refresh Models",
        type: "button",
        description: "Refresh the list of available models.",
        callback: "adapter.refresh_models"
      }
    };
  }
  /**
   * Validate the adapter configuration.
   * @abstract
   * @returns {Object} { valid: boolean, message: string }
   */
  validate_config() {
    throw new Error("validate_config not implemented");
  }
  get can_use_tools() {
    return this.model_config?.can_use_tools || false;
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-chat-model/adapters/_api.js
var SmartChatModelApiAdapter = class extends SmartChatModelAdapter {
  /**
   * Get the request adapter class.
   * @returns {SmartChatModelRequestAdapter} The request adapter class
   */
  get req_adapter() {
    return SmartChatModelRequestAdapter;
  }
  /**
   * Get the response adapter class.
   * @returns {SmartChatModelResponseAdapter} The response adapter class
   */
  get res_adapter() {
    return SmartChatModelResponseAdapter;
  }
  /**
   * Get or initialize the HTTP adapter.
   * @returns {SmartHttpRequest} The HTTP adapter instance
   */
  get http_adapter() {
    if (!this._http_adapter) {
      if (this.model.opts.http_adapter) this._http_adapter = this.model.opts.http_adapter;
      else this._http_adapter = new SmartHttpRequest({ adapter: SmartHttpRequestFetchAdapter });
    }
    return this._http_adapter;
  }
  /**
   * Get the settings configuration for the API adapter.
   * @returns {Object} Settings configuration object with API key and other settings
   */
  get settings_config() {
    return {
      ...super.settings_config,
      "[CHAT_ADAPTER].api_key": {
        name: "API Key",
        type: "password",
        description: "Enter your API key for the chat model platform.",
        callback: "test_api_key",
        is_scope: true
        // trigger re-render of settings when changed (reload models dropdown)
      }
    };
  }
  /**
   * Count tokens in the input text.
   * @abstract
   * @param {string|Object} input - Text or message object to count tokens for
   * @returns {Promise<number>} Number of tokens in the input
   */
  async count_tokens(input) {
    throw new Error("count_tokens not implemented");
  }
  /**
   * Get the parameters for requesting available models.
   * @returns {Object} Request parameters for models endpoint
   */
  get models_request_params() {
    return {
      url: this.models_endpoint,
      method: this.models_endpoint_method,
      headers: {
        "Authorization": `Bearer ${this.api_key}`
      }
    };
  }
  /**
   * Validate parameters required for getting models.
   * @returns {true|Array<Object>} True if valid, array of error objects if invalid
   */
  validate_get_models_params() {
    if (!this.adapter_config.models_endpoint) {
      const err_msg = `${this.model.adapter_name} models endpoint required to retrieve models`;
      console.warn(err_msg);
      return [{ value: "", name: err_msg }];
    }
    if (!this.api_key) {
      const err_msg = `${this.model.adapter_name} API key required to retrieve models`;
      console.warn(err_msg);
      return [{ value: "", name: err_msg }];
    }
    return true;
  }
  /**
   * Get available models from the API.
   * @param {boolean} [refresh=false] - Whether to refresh cached models
   * @returns {Promise<Object>} Map of model objects
   */
  async get_models(refresh = false) {
    if (!refresh && this.adapter_config?.models && typeof this.adapter_config.models === "object" && Object.keys(this.adapter_config.models).length > 0) return this.adapter_config.models;
    try {
      const response = await this.http_adapter.request(this.models_request_params);
      const model_data = this.parse_model_data(await response.json());
      this.adapter_settings.models = model_data;
      this.model.re_render_settings();
      return model_data;
    } catch (error) {
      console.error("Failed to fetch model data:", error);
      return { "_": { id: `Failed to fetch models from ${this.model.adapter_name}` } };
    }
  }
  /**
   * Parses the raw model data from OpenAI API and transforms it into a more usable format.
   * @param {Object} model_data - The raw model data received from OpenAI API.
   * @returns {Array<Object>} An array of parsed model objects with the following properties:
   *   @property {string} model_name - The name/ID of the model as returned by the API.
   *   @property {string} id - The id used to identify the model (usually same as model_name).
   *   @property {boolean} multimodal - Indicates if the model supports multimodal inputs.
   *   @property {number} [max_input_tokens] - The maximum number of input tokens the model can process.
   *   @property {string} [description] - A description of the model's context and output capabilities.
   */
  parse_model_data(model_data) {
    throw new Error("parse_model_data not implemented");
  }
  /**
   * Complete a chat request.
   * @param {Object} req - Request parameters
   * @returns {Promise<Object>} Completion response in OpenAI format
   */
  async complete(req) {
    const _req = new this.req_adapter(this, {
      ...req,
      stream: false
    });
    const request_params = _req.to_platform();
    const http_resp = await this.http_adapter.request(request_params);
    if (!http_resp) return null;
    const _res = new this.res_adapter(this, await http_resp.json());
    try {
      return _res.to_openai();
    } catch (error) {
      console.error("Error in SmartChatModelApiAdapter.complete():", error);
      console.error(http_resp);
      return null;
    }
  }
  // STREAMING
  /**
  * Stream chat responses.
  * @param {Object} req - Request parameters
  * @param {Object} handlers - Event handlers for streaming
  * @param {Function} handlers.chunk - Handler for response objects
  * @param {Function} handlers.error - Handler for errors
  * @param {Function} handlers.done - Handler for completion
  * @returns {Promise<Object>} Complete response object
  */
  async stream(req, handlers = {}) {
    const _req = new this.req_adapter(this, req);
    const request_params = _req.to_platform(true);
    if (this.streaming_chunk_splitting_regex) request_params.chunk_splitting_regex = this.streaming_chunk_splitting_regex;
    return await new Promise((resolve, reject) => {
      try {
        this.active_stream = new SmartStreamer(this.endpoint_streaming, request_params);
        const resp_adapter = new this.res_adapter(this);
        this.active_stream.addEventListener("message", async (e) => {
          if (this.is_end_of_stream(e)) {
            await resp_adapter.handle_chunk(e.data);
            this.stop_stream();
            const final_resp = resp_adapter.to_openai();
            handlers.done && await handlers.done(final_resp);
            resolve(final_resp);
            return;
          }
          try {
            resp_adapter.handle_chunk(e.data);
            handlers.chunk && await handlers.chunk(resp_adapter.to_openai());
          } catch (error) {
            console.error("Error processing stream chunk:", error);
            handlers.error && handlers.error(e.data);
            this.stop_stream();
            reject(error);
          }
        });
        this.active_stream.addEventListener("error", (e) => {
          console.error("Stream error:", e);
          handlers.error && handlers.error("*API Error. See console logs for details.*");
          this.stop_stream();
          reject(e);
        });
        this.active_stream.stream();
      } catch (err) {
        console.error("Failed to start stream:", err);
        handlers.error && handlers.error("*API Error. See console logs for details.*");
        this.stop_stream();
        reject(err);
      }
    });
  }
  /**
   * Check if a stream event indicates end of stream.
   * @param {Event} event - Stream event
   * @returns {boolean} True if end of stream
   */
  is_end_of_stream(event) {
    return event.data === "data: [DONE]";
  }
  /**
   * Stop active stream.
   */
  stop_stream() {
    if (this.active_stream) {
      this.active_stream.end();
      this.active_stream = null;
    }
  }
  /**
   * Validate Anthropic adapter configuration.
   * @returns {Object} { valid: boolean, message: string }
   */
  validate_config() {
    if (!this.adapter_config.model_key || this.adapter_config.model_key === "undefined") return { valid: false, message: "No model selected." };
    if (!this.api_key) {
      return { valid: false, message: "API key is missing." };
    }
    if (!this.can_use_tools) {
      return { valid: false, message: "Selected model does not support tools." };
    }
    return { valid: true, message: "Configuration is valid." };
  }
  /**
   * Get the API key.
   * @returns {string} The API key.
   */
  get api_key() {
    return this.main.opts.api_key || this.adapter_config?.api_key;
  }
  /**
  
     * Get the number of choices.
     * @returns {number} The number of choices.
     */
  get choices() {
    return this.adapter_config.choices;
  }
  get models_endpoint() {
    return this.adapter_config.models_endpoint;
  }
  get models_endpoint_method() {
    return "POST";
  }
  /**
   * Get the endpoint URL.
   * @returns {string} The endpoint URL.
   */
  get endpoint() {
    return this.adapter_config.endpoint;
  }
  /**
   * Get the streaming endpoint URL.
   * @returns {string} The streaming endpoint URL.
   */
  get endpoint_streaming() {
    return this.adapter_config.endpoint_streaming || this.endpoint;
  }
  /**
   * Get the maximum output tokens.
   * @returns {number} The maximum output tokens.
   */
  get max_output_tokens() {
    return this.adapter_config.max_output_tokens || 3e3;
  }
  /**
   * Get the temperature.
   * @returns {number} The temperature.
   */
  get temperature() {
    return this.adapter_config.temperature;
  }
};
var SmartChatModelRequestAdapter = class {
  /**
   * @constructor
   * @param {SmartChatModelAdapter} adapter - The SmartChatModelAdapter instance
   * @param {Object} req - The incoming request object
   */
  constructor(adapter, req = {}) {
    this.adapter = adapter;
    this._req = req;
  }
  /**
   * Get the messages array from the request
   * @returns {Array<Object>} Array of message objects
   */
  get messages() {
    return this._req.messages || [];
  }
  /**
   * Get the model identifier
   * @returns {string} Model ID
   */
  get model() {
    return this._req.model || this.adapter.model_config.id;
  }
  /**
   * Get the temperature setting
   * @returns {number} Temperature value
   */
  get temperature() {
    return this._req.temperature;
  }
  /**
   * Get the maximum tokens setting
   * @returns {number} Max tokens value
   */
  get max_tokens() {
    return this._req.max_tokens || this.adapter.model_config.max_output_tokens;
  }
  /**
   * Get the streaming flag
   * @returns {boolean} Whether to stream responses
   */
  get stream() {
    return this._req.stream;
  }
  /**
   * Get the tools array
   * @returns {Array<Object>|null} Array of tool objects or null
   */
  get tools() {
    return this._req.tools || null;
  }
  /**
   * Get the tool choice setting
   * @returns {string|Object|null} Tool choice configuration
   */
  get tool_choice() {
    return this._req.tool_choice || null;
  }
  get frequency_penalty() {
    return this._req.frequency_penalty;
  }
  get presence_penalty() {
    return this._req.presence_penalty;
  }
  get top_p() {
    return this._req.top_p;
  }
  /**
   * Get request headers
   * @returns {Object} Headers object
   */
  get_headers() {
    const headers = {
      "Content-Type": "application/json",
      ...this.adapter.adapter_config.headers || {}
    };
    if (this.adapter.adapter_config.api_key_header !== "none") {
      if (this.adapter.adapter_config.api_key_header) {
        headers[this.adapter.adapter_config.api_key_header] = this.adapter.api_key;
      } else if (this.adapter.api_key) {
        headers["Authorization"] = `Bearer ${this.adapter.api_key}`;
      }
    }
    return headers;
  }
  /**
   * Convert request to platform-specific format
   * @returns {Object} Platform-specific request parameters
   */
  to_platform(streaming = false) {
    return this.to_openai(streaming);
  }
  /**
   * Convert request to OpenAI format
   * @returns {Object} Request parameters in OpenAI format
   */
  to_openai(streaming = false) {
    const body = {
      messages: this._transform_messages_to_openai(),
      model: this.model,
      max_tokens: this.max_tokens,
      temperature: this.temperature,
      stream: streaming,
      ...this.tools && { tools: this._transform_tools_to_openai() }
    };
    if (body.tools?.length > 0 && this.tool_choice && this.tool_choice !== "none") {
      body.tool_choice = this.tool_choice;
    }
    if (this.model?.startsWith("o1-")) {
      body.messages = body.messages.filter((m) => m.role !== "system");
      delete body.temperature;
    }
    if (typeof this._req.top_p === "number") body.top_p = this._req.top_p;
    if (typeof this._req.presence_penalty === "number") body.presence_penalty = this._req.presence_penalty;
    if (typeof this._req.frequency_penalty === "number") body.frequency_penalty = this._req.frequency_penalty;
    return {
      url: this.adapter.endpoint,
      method: "POST",
      headers: this.get_headers(),
      body: JSON.stringify(body)
    };
  }
  /**
   * Transform messages to OpenAI format
   * @returns {Array<Object>} Transformed messages array
   * @private
   */
  _transform_messages_to_openai() {
    return this.messages.map((message) => this._transform_single_message_to_openai(message));
  }
  /**
   * Transform a single message to OpenAI format
   * @param {Object} message - Message object to transform
   * @returns {Object} Transformed message object
   * @private
   */
  _transform_single_message_to_openai(message) {
    const transformed = {
      role: this._get_openai_role(message.role),
      content: this._get_openai_content(message)
    };
    if (message.name) transformed.name = message.name;
    if (message.tool_calls) transformed.tool_calls = this._transform_tool_calls_to_openai(message.tool_calls);
    if (message.image_url) transformed.image_url = message.image_url;
    if (message.tool_call_id) transformed.tool_call_id = message.tool_call_id;
    return transformed;
  }
  /**
   * Get the OpenAI role for a given role.
   * @param {string} role - The role to transform.
   * @returns {string} The transformed role.
   * @private
   */
  _get_openai_role(role) {
    return role;
  }
  /**
   * Get the OpenAI content for a given content.
   * @param {string} content - The content to transform.
   * @returns {string} The transformed content.
   * @private
   */
  _get_openai_content(message) {
    return message.content;
  }
  /**
   * Transform tool calls to OpenAI format.
   * @param {Array} tool_calls - Array of tool call objects.
   * @returns {Array} Transformed tool calls array.
   * @private
   */
  _transform_tool_calls_to_openai(tool_calls) {
    return tool_calls.map((tool_call) => ({
      id: tool_call.id,
      type: tool_call.type,
      function: {
        name: tool_call.function.name,
        arguments: tool_call.function.arguments
      }
    }));
  }
  /**
   * Transform tools to OpenAI format.
   * @returns {Array} Transformed tools array.
   * @private
   */
  _transform_tools_to_openai() {
    return this.tools.map((tool2) => ({
      type: tool2.type,
      function: {
        name: tool2.function.name,
        description: tool2.function.description,
        parameters: tool2.function.parameters
      }
    }));
  }
};
var SmartChatModelResponseAdapter = class {
  // must be getter to prevent erroneous assignment
  static get platform_res() {
    return {
      id: "",
      object: "chat.completion",
      created: 0,
      model: "",
      choices: [],
      usage: {}
    };
  }
  /**
   * @constructor
   * @param {SmartChatModelAdapter} adapter - The SmartChatModelAdapter instance
   * @param {Object} res - The response object
   */
  constructor(adapter, res) {
    this.adapter = adapter;
    this._res = res || this.constructor.platform_res;
  }
  /**
   * Get response ID
   * @returns {string|null} Response ID
   */
  get id() {
    return this._res.id || null;
  }
  /**
   * Get response object type
   * @returns {string|null} Object type
   */
  get object() {
    return this._res.object || null;
  }
  /**
   * Get creation timestamp
   * @returns {number|null} Creation timestamp
   */
  get created() {
    return this._res.created || null;
  }
  /**
   * Get response choices
   * @returns {Array<Object>} Array of choice objects
   */
  get choices() {
    return this._res.choices || [];
  }
  /**
   * Get first tool call if present
   * @returns {Object|null} Tool call object
   */
  get tool_call() {
    return this.message.tool_calls?.[0] || null;
  }
  /**
   * Get tool name from first tool call
   * @returns {string|null} Tool name
   */
  get tool_name() {
    return this.tool_call?.tool_name || null;
  }
  /**
   * Get tool call parameters
   * @returns {Object|null} Tool parameters
   */
  get tool_call_content() {
    return this.tool_call?.parameters || null;
  }
  /**
   * Get token usage statistics
   * @returns {Object|null} Usage statistics
   */
  get usage() {
    return this._res.usage || null;
  }
  get error() {
    return this._res.error || null;
  }
  /**
   * Convert response to OpenAI format
   * @returns {Object} Response in OpenAI format
   */
  to_openai() {
    const res = {
      id: this.id,
      object: this.object,
      created: this.created,
      choices: this._transform_choices_to_openai(),
      usage: this._transform_usage_to_openai(),
      raw: this._res
    };
    if (this.error) res.error = this.error;
    return res;
  }
  /**
   * Parse chunk adds delta to content as expected output format
   */
  handle_chunk(chunk) {
    if (chunk === "data: [DONE]") return;
    chunk = JSON.parse(chunk.split("data: ")[1] || "{}");
    if (Object.keys(chunk).length === 0) return;
    if (!this._res.choices[0]) {
      this._res.choices.push({
        message: {
          index: 0,
          role: "assistant",
          content: ""
        }
      });
    }
    if (!this._res.id) {
      this._res.id = chunk.id;
    }
    if (chunk.choices?.[0]?.delta?.content) {
      this._res.choices[0].message.content += chunk.choices[0].delta.content;
    }
    if (chunk.choices?.[0]?.delta?.tool_calls) {
      if (!this._res.choices[0].message.tool_calls) {
        this._res.choices[0].message.tool_calls = [{
          id: "",
          type: "function",
          function: {
            name: "",
            arguments: ""
          }
        }];
      }
      if (chunk.choices[0].delta.tool_calls[0].id) {
        this._res.choices[0].message.tool_calls[0].id += chunk.choices[0].delta.tool_calls[0].id;
      }
      if (chunk.choices[0].delta.tool_calls[0].function.name) {
        this._res.choices[0].message.tool_calls[0].function.name += chunk.choices[0].delta.tool_calls[0].function.name;
      }
      if (chunk.choices[0].delta.tool_calls[0].function.arguments) {
        this._res.choices[0].message.tool_calls[0].function.arguments += chunk.choices[0].delta.tool_calls[0].function.arguments;
      }
    }
  }
  /**
   * Transform choices to OpenAI format.
   * @returns {Array} Transformed choices array.
   * @private
   */
  _transform_choices_to_openai() {
    return this.choices.map((choice) => ({
      index: choice.index,
      message: this._transform_message_to_openai(choice.message),
      finish_reason: this._get_openai_finish_reason(choice.finish_reason)
    }));
  }
  /**
   * Transform a single message to OpenAI format.
   * @param {Object} message - The message object to transform.
   * @returns {Object} Transformed message object.
   * @private
   */
  _transform_message_to_openai(message = {}) {
    const transformed = {
      role: this._get_openai_role(message.role),
      content: this._get_openai_content(message)
    };
    if (message.name) transformed.name = message.name;
    if (message.tool_calls) transformed.tool_calls = this._transform_tool_calls_to_openai(message.tool_calls);
    if (message.image_url) transformed.image_url = message.image_url;
    return transformed;
  }
  /**
   * Get the OpenAI role for a given role.
   * @param {string} role - The role to transform.
   * @returns {string} The transformed role.
   * @private
   */
  _get_openai_role(role) {
    return role;
  }
  /**
   * Get the OpenAI content for a given content.
   * @param {string} content - The content to transform.
   * @returns {string} The transformed content.
   * @private
   */
  _get_openai_content(message) {
    return message.content;
  }
  /**
   * Get the OpenAI finish reason for a given finish reason.
   * @param {string} finish_reason - The finish reason to transform.
   * @returns {string} The transformed finish reason.
   * @private
   */
  _get_openai_finish_reason(finish_reason) {
    return finish_reason;
  }
  /**
   * Transform usage to OpenAI format.
   * @returns {Object} Transformed usage object.
   * @private
   */
  _transform_usage_to_openai() {
    return this.usage;
  }
  /**
   * Transform tool calls to OpenAI format.
   * @param {Array} tool_calls - Array of tool call objects.
   * @returns {Array} Transformed tool calls array.
   * @private
   */
  _transform_tool_calls_to_openai(tool_calls) {
    return tool_calls.map((tool_call) => ({
      id: tool_call.id,
      type: tool_call.type,
      function: {
        name: tool_call.function.name,
        arguments: tool_call.function.arguments
      }
    }));
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-chat-model/adapters/anthropic.js
var SmartChatModelAnthropicAdapter = class extends SmartChatModelApiAdapter {
  static key = "anthropic";
  static defaults = {
    description: "Anthropic Claude",
    type: "API",
    endpoint: "https://api.anthropic.com/v1/messages",
    // streaming: false,
    streaming: true,
    api_key_header: "x-api-key",
    headers: {
      "anthropic-version": "2023-06-01",
      "anthropic-beta": "tools-2024-04-04",
      "anthropic-dangerous-direct-browser-access": true
    },
    adapter: "Anthropic",
    models_endpoint: false,
    default_model: "claude-3-5-sonnet-latest",
    signup_url: "https://console.anthropic.com/login?returnTo=%2Fsettings%2Fkeys",
    can_use_tools: true
  };
  /**
   * Get request adapter class
   * @returns {typeof SmartChatModelAnthropicRequestAdapter} Request adapter class
   */
  get req_adapter() {
    return SmartChatModelAnthropicRequestAdapter;
  }
  /**
   * Get response adapter class
   * @returns {typeof SmartChatModelAnthropicResponseAdapter} Response adapter class
   */
  res_adapter = SmartChatModelAnthropicResponseAdapter;
  /**
   * Validate parameters for getting models
   * @returns {boolean} Always true since models are hardcoded
   */
  validate_get_models_params() {
    return true;
  }
  /**
   * Get available models (hardcoded list)
   * @returns {Promise<Object>} Map of model objects
   */
  get_models() {
    return Promise.resolve(this.models);
  }
  is_end_of_stream(event) {
    return event.data.includes("message_stop");
  }
  /**
   * Get hardcoded list of available models
   * @returns {Object} Map of model objects with capabilities and limits
   */
  get models() {
    return {
      // ── Claude 4 family ──────────────────────────────────────────────────────
      "claude-opus-4-20250514": {
        name: "Claude Opus 4 (2025-05-14)",
        id: "claude-opus-4-20250514",
        model_name: "claude-opus-4-20250514",
        description: "Anthropic's Claude Opus 4 (2025-05-14)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      "claude-sonnet-4-20250514": {
        name: "Claude Sonnet 4 (2025-05-14)",
        id: "claude-sonnet-4-20250514",
        model_name: "claude-sonnet-4-20250514",
        description: "Anthropic's Claude Sonnet 4 (2025-05-14)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      // ── Claude 3.7 family ───────────────────────────────────────────────────
      "claude-3-7-sonnet-latest": {
        name: "Claude 3.7 Sonnet (Latest)",
        id: "claude-3-7-sonnet-latest",
        model_name: "claude-3-7-sonnet-latest",
        description: "Anthropic's Claude Sonnet 3.7 (Latest)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      "claude-3-7-sonnet-20250219": {
        name: "Claude 3.7 Sonnet (2025-02-19)",
        id: "claude-3-7-sonnet-20250219",
        model_name: "claude-3-7-sonnet-20250219",
        description: "Anthropic's Claude Sonnet 3.7 (2025-02-19)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      // ── Claude 3.5 family ───────────────────────────────────────────────────
      "claude-3-5-sonnet-latest": {
        name: "Claude 3.5 Sonnet (Latest)",
        id: "claude-3-5-sonnet-latest",
        model_name: "claude-3.5-sonnet-latest",
        description: "Anthropic's Claude Sonnet 3.5 (Latest)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      "claude-3-5-sonnet-20241022": {
        name: "Claude 3.5 Sonnet (2024-10-22)",
        id: "claude-3-5-sonnet-20241022",
        model_name: "claude-3-5-sonnet-20241022",
        description: "Anthropic's Claude Sonnet 3.5 (2024-10-22)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      "claude-3.5-sonnet-20240620": {
        // kept original id typo for backward compatibility
        name: "Claude 3.5 Sonnet (2024-06-20)",
        id: "claude-3.5-sonnet-20240620",
        model_name: "claude-3.5-sonnet-20240620",
        description: "Anthropic's Claude Sonnet 3.5 (2024-06-20)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      "claude-3-5-haiku-latest": {
        name: "Claude 3.5 Haiku (Latest)",
        id: "claude-3-5-haiku-latest",
        model_name: "claude-3.5-haiku-latest",
        description: "Anthropic's Claude Haiku 3.5 (Latest)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3
      },
      "claude-3-5-haiku-20241022": {
        name: "Claude 3.5 Haiku (2024-10-22)",
        id: "claude-3-5-haiku-20241022",
        model_name: "claude-3-5-haiku-20241022",
        description: "Anthropic's Claude Haiku 3.5 (2024-10-22)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3
      },
      // ── Claude 3 family ─────────────────────────────────────────────────────
      "claude-3-opus-latest": {
        name: "Claude 3 Opus (Latest)",
        id: "claude-3-opus-latest",
        model_name: "claude-3-opus-latest",
        description: "Anthropic's Claude Opus 3 (Latest)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      "claude-3-opus-20240229": {
        name: "Claude 3 Opus (2024-02-29)",
        id: "claude-3-opus-20240229",
        model_name: "claude-3-opus-20240229",
        description: "Anthropic's Claude Opus 3 (2024-02-29)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      "claude-3-sonnet-20240229": {
        name: "Claude 3 Sonnet (2024-02-29)",
        id: "claude-3-sonnet-20240229",
        model_name: "claude-3-sonnet-20240229",
        description: "Anthropic's Claude Sonnet 3 (2024-02-29)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      "claude-3-haiku-20240307": {
        name: "Claude 3 Haiku (2024-03-07)",
        id: "claude-3-haiku-20240307",
        model_name: "claude-3-haiku-20240307",
        description: "Anthropic's Claude Haiku 3 (2024-03-07)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      }
    };
  }
};
var SmartChatModelAnthropicRequestAdapter = class extends SmartChatModelRequestAdapter {
  /**
   * Convert request to Anthropic format
   * @returns {Object} Request parameters in Anthropic format
   */
  to_platform(streaming = false) {
    return this.to_anthropic(streaming);
  }
  /**
   * Convert request to Anthropic format
   * @returns {Object} Request parameters in Anthropic format
   */
  to_anthropic(streaming = false) {
    this.anthropic_body = {
      model: this.model,
      max_tokens: this.max_tokens,
      temperature: this.temperature,
      stream: streaming
    };
    this.anthropic_body.messages = this._transform_messages_to_anthropic();
    if (this.tools) {
      this.anthropic_body.tools = this._transform_tools_to_anthropic();
    }
    if (this.tool_choice) {
      if (this.tool_choice === "auto") {
        this.anthropic_body.tool_choice = { type: "auto" };
      } else if (typeof this.tool_choice === "object" && this.tool_choice.function) {
        this.anthropic_body.tool_choice = { type: "tool", name: this.tool_choice.function.name };
      }
    }
    return {
      url: this.adapter.endpoint,
      method: "POST",
      headers: this.get_headers(),
      body: JSON.stringify(this.anthropic_body)
    };
  }
  /**
   * Transform messages to Anthropic format
   * @returns {Array<Object>} Messages in Anthropic format
   * @private
   */
  _transform_messages_to_anthropic() {
    let anthropic_messages = [];
    for (const message of this.messages) {
      if (message.role === "system") {
        if (!this.anthropic_body.system) this.anthropic_body.system = "";
        else this.anthropic_body.system += "\n\n";
        this.anthropic_body.system += Array.isArray(message.content) ? message.content.map((part) => part.text).join("\n") : message.content;
      } else if (message.role === "tool") {
        const msg = {
          role: "user",
          content: [
            {
              type: "tool_result",
              tool_use_id: message.tool_call_id,
              content: message.content
            }
          ]
        };
        anthropic_messages.push(msg);
      } else {
        const msg = {
          role: this._get_anthropic_role(message.role),
          content: this._get_anthropic_content(message.content)
        };
        if (message.tool_calls?.length > 0) msg.content = this._transform_tool_calls_to_content(message.tool_calls);
        anthropic_messages.push(msg);
      }
    }
    return anthropic_messages;
  }
  /**
   * Transform tool calls to Anthropic format
   * @param {Array<Object>} tool_calls - Tool calls
   * @returns {Array<Object>} Tool calls in Anthropic format
   * @private
   */
  _transform_tool_calls_to_content(tool_calls) {
    return tool_calls.map((tool_call) => ({
      type: "tool_use",
      id: tool_call.id,
      name: tool_call.function.name,
      input: JSON.parse(tool_call.function.arguments)
    }));
  }
  /**
   * Transform role to Anthropic format
   * @param {string} role - Original role
   * @returns {string} Role in Anthropic format
   * @private
   */
  _get_anthropic_role(role) {
    const role_map = {
      function: "assistant",
      // Anthropic doesn't have a function role, so we'll treat it as assistant
      tool: "user"
    };
    return role_map[role] || role;
  }
  /**
   * Transform content to Anthropic format
   * @param {string|Array} content - Original content
   * @returns {string|Array} Content in Anthropic format
   * @private
   */
  _get_anthropic_content(content) {
    if (Array.isArray(content)) {
      return content.map((item) => {
        if (item.type === "text") return { type: "text", text: item.text };
        if (item.type === "image_url") {
          return {
            type: "image",
            source: {
              type: "base64",
              media_type: item.image_url.url.split(";")[0].split(":")[1],
              data: item.image_url.url.split(",")[1]
            }
          };
        }
        if (item.type === "file" && item.file?.filename?.toLowerCase().endsWith(".pdf")) {
          if (item.file?.file_data) {
            return {
              type: "document",
              source: {
                type: "base64",
                media_type: "application/pdf",
                data: item.file.file_data.split(",")[1]
              }
            };
          }
        }
        return item;
      });
    }
    return content;
  }
  /**
   * Transform tools to Anthropic format
   * @returns {Array<Object>} Tools in Anthropic format
   * @private
   */
  _transform_tools_to_anthropic() {
    if (!this.tools) return void 0;
    return this.tools.map((tool2) => ({
      name: tool2.function.name,
      description: tool2.function.description,
      input_schema: tool2.function.parameters
    }));
  }
};
var SmartChatModelAnthropicResponseAdapter = class extends SmartChatModelResponseAdapter {
  static get platform_res() {
    return {
      content: [],
      id: "",
      model: "",
      role: "assistant",
      stop_reason: null,
      stop_sequence: null,
      type: "message",
      usage: {
        input_tokens: 0,
        output_tokens: 0
      }
    };
  }
  /**
   * Convert response to OpenAI format
   * @returns {Object} Response in OpenAI format
   */
  to_openai() {
    return {
      id: this._res.id,
      object: "chat.completion",
      created: Date.now(),
      choices: [
        {
          index: 0,
          message: this._transform_message_to_openai(),
          finish_reason: this._get_openai_finish_reason(this._res.stop_reason)
        }
      ],
      usage: this._transform_usage_to_openai()
    };
  }
  /**
   * Transform message to OpenAI format
   * @returns {Object} Message in OpenAI format
   * @private
   */
  _transform_message_to_openai() {
    const message = {
      role: "assistant",
      content: "",
      tool_calls: []
    };
    if (Array.isArray(this._res.content)) {
      for (const content of this._res.content) {
        if (content.type === "text") {
          message.content += (message.content ? "\n\n" : "") + content.text;
        } else if (content.type === "tool_use") {
          message.tool_calls.push({
            id: content.id,
            type: "function",
            function: {
              name: content.name,
              arguments: JSON.stringify(content.input)
            }
          });
        }
      }
    } else {
      message.content = this._res.content;
    }
    if (message.tool_calls.length === 0) {
      delete message.tool_calls;
    }
    return message;
  }
  /**
   * Transform finish reason to OpenAI format
   * @param {string} stop_reason - Original finish reason
   * @returns {string} Finish reason in OpenAI format
   * @private
   */
  _get_openai_finish_reason(stop_reason) {
    const reason_map = {
      "end_turn": "stop",
      "max_tokens": "length",
      "tool_use": "function_call"
    };
    return reason_map[stop_reason] || stop_reason;
  }
  /**
   * Transform usage statistics to OpenAI format
   * @returns {Object} Usage statistics in OpenAI format
   * @private
   */
  _transform_usage_to_openai() {
    if (!this._res.usage) {
      return {
        prompt_tokens: 0,
        completion_tokens: 0,
        total_tokens: 0
      };
    }
    return {
      prompt_tokens: this._res.usage.input_tokens || 0,
      completion_tokens: this._res.usage.output_tokens || 0,
      total_tokens: (this._res.usage.input_tokens || 0) + (this._res.usage.output_tokens || 0)
    };
  }
  handle_chunk(chunk) {
    if (!chunk.startsWith("data: ")) return;
    chunk = JSON.parse(chunk.slice(6));
    if (!this._res.content.length) {
      this._res.content = [
        {
          type: "text",
          text: ""
        }
      ];
    }
    if (chunk.message?.id) {
      this._res.id = chunk.message.id;
    }
    if (chunk.message?.model) {
      this._res.model = chunk.message.model;
    }
    if (chunk.message?.role) {
      this._res.role = chunk.message.role;
    }
    if (chunk.delta?.type === "text_delta") {
      this._res.content[0].text += chunk.delta.text;
    }
    if (chunk.delta?.stop_reason) {
      this._res.stop_reason = chunk.delta.stop_reason;
    }
    if (chunk.usage) {
      this._res.usage = {
        ...this._res.usage,
        ...chunk.usage
      };
    }
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-chat-model/adapters/openai.js
var EXCLUDED_PREFIXES = [
  "text-",
  "davinci",
  "babbage",
  "ada",
  "curie",
  "dall-e",
  "whisper",
  "omni",
  "tts",
  "gpt-4o-mini-tts",
  "computer-use",
  "codex",
  "gpt-4o-transcribe",
  "gpt-4o-mini-transcribe",
  "gpt-4o-mini-realtime",
  "gpt-4o-realtime",
  "o4-mini-deep-research",
  "o3-deep-research",
  "gpt-image"
];
var SmartChatModelOpenaiAdapter = class extends SmartChatModelApiAdapter {
  static key = "openai";
  static defaults = {
    description: "OpenAI",
    type: "API",
    endpoint: "https://api.openai.com/v1/chat/completions",
    streaming: true,
    models_endpoint: "https://api.openai.com/v1/models",
    default_model: "gpt-4.1-mini",
    signup_url: "https://platform.openai.com/api-keys",
    can_use_tools: true
  };
  res_adapter = SmartChatModelOpenaiResponseAdapter;
  /**
   * Parse model data from OpenAI API response.
   * Filters for GPT models and adds context window information.
   * @param {Object} model_data - Raw model data from OpenAI
   * @returns {Object} Map of model objects with capabilities and limits
   */
  parse_model_data(model_data) {
    return model_data.data.filter((model) => !EXCLUDED_PREFIXES.some((m) => model.id.startsWith(m)) && !model.id.includes("-instruct")).reduce((acc, model) => {
      const out = {
        model_name: model.id,
        id: model.id,
        multimodal: true,
        can_use_tools: true,
        max_input_tokens: get_max_input_tokens(model.id)
      };
      acc[model.id] = out;
      return acc;
    }, {});
  }
  /**
   * Override the HTTP method for fetching models.
   */
  models_endpoint_method = "GET";
  /**
   * Test the API key by attempting to fetch models.
   * @returns {Promise<boolean>} True if API key is valid
   */
  async test_api_key() {
    const models = await this.get_models();
    return models.length > 0;
  }
  /**
   * Get settings configuration for OpenAI adapter.
   * Adds image resolution setting for multimodal models.
   * @returns {Object} Settings configuration object
   */
  get settings_config() {
    const config = super.settings_config;
    if (this.adapter?.model_config?.multimodal) {
      config["[CHAT_ADAPTER].image_resolution"] = {
        name: "Image Resolution",
        type: "dropdown",
        description: "Select the image resolution for the chat model.",
        option_1: "low",
        option_2: "high",
        default: "low"
      };
    }
    config["[CHAT_ADAPTER].open_ai_note"] = {
      name: "Note about using OpenAI",
      type: "html",
      value: "<b>OpenAI models:</b> Some models require extra verification steps in your OpenAI account for them to appear in the model list."
    };
    return config;
  }
};
function get_max_input_tokens(model_id) {
  if (model_id.startsWith("gpt-4.1")) {
    return 1e6;
  }
  if (model_id.startsWith("o")) {
    return 2e5;
  }
  if (model_id.startsWith("gpt-4o") || model_id.startsWith("gpt-4.5") || model_id.startsWith("gpt-4-turbo")) {
    return 128e3;
  }
  if (model_id.startsWith("gpt-4")) {
    return 8192;
  }
  if (model_id.startsWith("gpt-3")) {
    return 16385;
  }
  return 8e3;
}
var SmartChatModelOpenaiResponseAdapter = class extends SmartChatModelResponseAdapter {
};

// node_modules/obsidian-smart-env/node_modules/smart-chat-model/adapters/azure.js
var SmartChatModelAzureAdapter = class extends SmartChatModelOpenaiAdapter {
  static key = "azure";
  static defaults = {
    description: "Azure OpenAI",
    type: "API",
    adapter: "AzureOpenAI",
    streaming: true,
    api_key_header: "api-key",
    azure_resource_name: "",
    azure_deployment_name: "",
    azure_api_version: "2024-10-01-preview",
    default_model: "gpt-35-turbo",
    signup_url: "https://learn.microsoft.com/azure/cognitive-services/openai/quickstart?tabs=command-line",
    models_endpoint: "https://{azure_resource_name}.openai.azure.com/openai/deployments?api-version={azure_api_version}",
    can_use_tools: true
  };
  /**
   * Override the settings configuration to include Azure-specific fields.
   */
  get settings_config() {
    return {
      ...super.settings_config,
      "[CHAT_ADAPTER].azure_resource_name": {
        name: "Azure Resource Name",
        type: "text",
        description: "The name of your Azure OpenAI resource (e.g. 'my-azure-openai').",
        default: ""
      },
      "[CHAT_ADAPTER].azure_deployment_name": {
        name: "Azure Deployment Name",
        type: "text",
        description: "The name of your specific model deployment (e.g. 'gpt35-deployment').",
        default: ""
      },
      "[CHAT_ADAPTER].azure_api_version": {
        name: "Azure API Version",
        type: "text",
        description: "The API version for Azure OpenAI (e.g. '2024-10-01-preview').",
        default: "2024-10-01-preview"
      }
    };
  }
  /**
   * Build the endpoint dynamically based on Azure settings.
   * Example:
   *  https://<RESOURCE>.openai.azure.com/openai/deployments/<DEPLOYMENT>/chat/completions?api-version=2023-05-15
   */
  get endpoint() {
    const { azure_resource_name, azure_deployment_name, azure_api_version } = this.adapter_config;
    return `https://${azure_resource_name}.openai.azure.com/openai/deployments/${azure_deployment_name}/chat/completions?api-version=${azure_api_version}`;
  }
  /**
   * For streaming, we can reuse the same endpoint. 
   * The request body includes `stream: true` which the base class uses.
   */
  get endpoint_streaming() {
    return this.endpoint;
  }
  /**
   * The models endpoint for retrieving a list of your deployments.
   * E.g.:
   *   https://<RESOURCE>.openai.azure.com/openai/deployments?api-version=2023-05-15
   */
  get models_endpoint() {
    const { azure_resource_name, azure_api_version } = this.adapter_config;
    return `https://${azure_resource_name}.openai.azure.com/openai/deployments?api-version=${azure_api_version}`;
  }
  /**
   * Azure returns a list of deployments in the shape:
   * {
   *   "object": "list",
   *   "data": [
   *     {
   *       "id": "mydeployment",
   *       "model": "gpt-35-turbo",
   *       "status": "succeeded",
   *       "createdAt": ...
   *       "updatedAt": ...
   *       ...
   *     },
   *     ...
   *   ]
   * }
   * We'll parse them into a dictionary keyed by deployment ID.
   */
  parse_model_data(model_data) {
    if (model_data.object !== "list" || !Array.isArray(model_data.data)) {
      return { "_": { id: "No deployments found." } };
    }
    const parsed = {};
    for (const d of model_data.data) {
      parsed[d.id] = {
        model_name: d.id,
        id: d.id,
        raw: d,
        // You can add more details if you want:
        description: `Model: ${d.model}, Status: ${d.status}`,
        // Hard to guess tokens; omit or guess:
        max_input_tokens: 4e3
      };
    }
    return parsed;
  }
  /**
   * Validate the Azure configuration fields.
   */
  validate_config() {
    const { azure_resource_name, azure_deployment_name, azure_api_version } = this.adapter_config;
    if (!azure_resource_name) {
      return { valid: false, message: "Azure resource name is missing." };
    }
    if (!azure_deployment_name) {
      return { valid: false, message: "Azure deployment name is missing." };
    }
    if (!azure_api_version) {
      return { valid: false, message: "Azure API version is missing." };
    }
    if (!this.api_key) {
      return { valid: false, message: "Azure OpenAI API key is missing." };
    }
    return { valid: true, message: "Configuration is valid." };
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-chat-model/adapters/google.js
var SmartChatModelGeminiAdapter = class extends SmartChatModelApiAdapter {
  static key = "gemini";
  static defaults = {
    description: "Google Gemini",
    type: "API",
    api_key_header: "none",
    endpoint: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:generateContent",
    endpoint_streaming: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:streamGenerateContent",
    streaming: true,
    adapter: "Gemini",
    models_endpoint: "https://generativelanguage.googleapis.com/v1beta/models",
    default_model: "gemini-1.5-pro",
    signup_url: "https://ai.google.dev/",
    can_use_tools: true
  };
  streaming_chunk_splitting_regex = /(\r\n|\n|\r){2}/g;
  // handle Google's BS (split on double newlines only)
  /**
   * Get request adapter class
   */
  req_adapter = SmartChatModelGeminiRequestAdapter;
  /**
   * Get response adapter class
   */
  res_adapter = SmartChatModelGeminiResponseAdapter;
  /**
   * Uses Gemini's dedicated token counting endpoint
   */
  async count_tokens(input) {
    const req = {
      url: `https://generativelanguage.googleapis.com/v1beta/models/${this.model_key}:countTokens?key=${this.api_key}`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(this.prepare_token_count_body(input))
    };
    const resp = await this.http_adapter.request(req);
    return resp.json.totalTokens;
  }
  /**
   * Formats input for token counting based on type
   * @private
   */
  prepare_token_count_body(input) {
    if (typeof input === "string") {
      return { contents: [{ parts: [{ text: input }] }] };
    } else if (Array.isArray(input)) {
      return { contents: input.map((msg) => this.transform_message_for_token_count(msg)) };
    } else if (typeof input === "object") {
      return { contents: [this.transform_message_for_token_count(input)] };
    }
    throw new Error("Invalid input for count_tokens");
  }
  /**
   * Transforms message for token counting, handling text and images
   * @private
   */
  transform_message_for_token_count(message) {
    return {
      role: message.role === "assistant" ? "model" : message.role,
      parts: Array.isArray(message.content) ? message.content.map((part) => {
        if (part.type === "text") return { text: part.text };
        if (part.type === "image_url") return {
          inline_data: {
            mime_type: part.image_url.url.split(";")[0].split(":")[1],
            data: part.image_url.url.split(",")[1]
          }
        };
        return part;
      }) : [{ text: message.content }]
    };
  }
  /**
   * Builds endpoint URLs with model and API key
   */
  get endpoint() {
    return `https://generativelanguage.googleapis.com/v1beta/models/${this.model_key}:generateContent?key=${this.api_key}`;
  }
  get endpoint_streaming() {
    return `https://generativelanguage.googleapis.com/v1beta/models/${this.model_key}:streamGenerateContent?key=${this.api_key}`;
  }
  // /**
  //  * Extracts text from Gemini's streaming format
  //  */
  // get_text_chunk_from_stream(event) {
  //   const data = JSON.parse(event.data);
  //   return data.candidates[0]?.content?.parts[0]?.text || '';
  // }
  /**
   * Get models endpoint URL with API key
   * @returns {string} Complete models endpoint URL
   */
  get models_endpoint() {
    return `${this.constructor.defaults.models_endpoint}?key=${this.api_key}`;
  }
  /**
   * Get HTTP method for models endpoint
   * @returns {string} HTTP method ("GET")
   */
  get models_endpoint_method() {
    return "GET";
  }
  get models_request_params() {
    return {
      url: this.models_endpoint,
      method: this.models_endpoint_method
    };
  }
  /**
   * Parse model data from Gemini API response
   * @param {Object} model_data - Raw model data from API
   * @returns {Object} Map of model objects with capabilities and limits
   */
  parse_model_data(model_data) {
    return model_data.models.filter((model) => model.name.startsWith("models/gemini")).reduce((acc, model) => {
      const out = {
        model_name: model.name.split("/").pop(),
        id: model.name.split("/").pop(),
        max_input_tokens: model.inputTokenLimit,
        max_output_tokens: model.maxOutputTokens,
        description: model.description,
        multimodal: model.name.includes("vision") || model.description.includes("multimodal"),
        raw: model
      };
      acc[model.name.split("/").pop()] = out;
      return acc;
    }, {});
  }
  is_end_of_stream(event) {
    return event.data.includes('"finishReason"');
    return false;
  }
};
var SmartChatModelGeminiRequestAdapter = class extends SmartChatModelRequestAdapter {
  to_platform(streaming = false) {
    return this.to_gemini(streaming);
  }
  to_gemini(streaming = false) {
    const gemini_body = {
      contents: this._transform_messages_to_gemini(),
      generationConfig: {
        temperature: this.temperature,
        maxOutputTokens: this.max_tokens,
        topK: this._req.topK || 1,
        topP: this._req.topP || 1,
        stopSequences: this._req.stop || []
      },
      safetySettings: [
        {
          category: "HARM_CATEGORY_HARASSMENT",
          threshold: "BLOCK_NONE"
        },
        {
          category: "HARM_CATEGORY_HATE_SPEECH",
          threshold: "BLOCK_NONE"
        },
        {
          category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
          threshold: "BLOCK_NONE"
        },
        {
          category: "HARM_CATEGORY_DANGEROUS_CONTENT",
          threshold: "BLOCK_NONE"
        }
      ]
    };
    if (this.tools) gemini_body.tools = this._transform_tools_to_gemini();
    if (gemini_body.tools && this.tool_choice !== "none") gemini_body.tool_config = this._transform_tool_choice_to_gemini();
    return {
      url: streaming ? this.adapter.endpoint_streaming : this.adapter.endpoint,
      method: "POST",
      headers: this.get_headers(),
      body: JSON.stringify(gemini_body)
    };
  }
  _transform_messages_to_gemini() {
    let gemini_messages = [];
    let system_message = "";
    for (const message of this.messages) {
      if (message.role === "system") {
        system_message += message.content + "\n";
      } else {
        gemini_messages.push({
          role: this._get_gemini_role(message.role),
          parts: this._transform_content_to_gemini(message.content)
        });
      }
    }
    if (system_message) {
      gemini_messages.unshift({
        role: "user",
        parts: [{ text: system_message.trim() }]
      });
    }
    return gemini_messages;
  }
  _get_gemini_role(role) {
    const role_map = {
      user: "user",
      assistant: "model",
      function: "model"
      // Gemini doesn't have a function role, so we'll treat it as model
    };
    return role_map[role] || role;
  }
  _transform_content_to_gemini(content) {
    if (Array.isArray(content)) {
      return content.map((part) => {
        if (part.type === "text") return { text: part.text };
        if (part.type === "image_url") {
          return {
            inline_data: {
              mime_type: part.image_url.url.split(";")[0].split(":")[1],
              data: part.image_url.url.split(",")[1]
            }
          };
        }
        if (part.type === "file" && part.file?.filename?.toLowerCase().endsWith(".pdf")) {
          if (part.file?.file_data) {
            return {
              inline_data: {
                mime_type: "application/pdf",
                data: part.file.file_data.split(",")[1]
              }
            };
          }
        }
        return part;
      });
    }
    return [{ text: content }];
  }
  _transform_tools_to_gemini() {
    return [{
      function_declarations: this.tools.map((tool2) => ({
        name: tool2.function.name,
        description: tool2.function.description,
        parameters: tool2.function.parameters
      }))
    }];
  }
  _transform_tool_choice_to_gemini() {
    return {
      function_calling_config: {
        mode: "ANY",
        allowed_function_names: this.tools.map((tool2) => tool2.function.name)
      }
    };
  }
};
var SmartChatModelGeminiResponseAdapter = class extends SmartChatModelResponseAdapter {
  static get platform_res() {
    return {
      candidates: [{
        content: {
          parts: [
            {
              text: ""
            }
          ],
          role: ""
        },
        finishReason: ""
      }],
      promptFeedback: {},
      usageMetadata: {}
    };
  }
  to_openai() {
    const first_candidate = this._res.candidates[0];
    if (!this._res.id) this._res.id = "gemini-" + Date.now().toString();
    return {
      id: this._res.id,
      object: "chat.completion",
      created: Date.now(),
      model: this.adapter.model_key,
      choices: [{
        index: 0,
        message: first_candidate?.content ? this._transform_message_to_openai(first_candidate.content) : "",
        finish_reason: this._get_openai_finish_reason(first_candidate.finishReason)
      }],
      usage: this._transform_usage_to_openai()
    };
  }
  _transform_message_to_openai(content) {
    const message = {
      role: "assistant",
      content: content.parts.filter((part) => part.text).map((part) => part.text).join("")
    };
    const function_call = content.parts.find((part) => part.functionCall);
    if (function_call) {
      message.tool_calls = [{
        type: "function",
        function: {
          name: function_call.functionCall.name,
          arguments: JSON.stringify(function_call.functionCall.args)
        }
      }];
    }
    return message;
  }
  _get_openai_finish_reason(finish_reason) {
    const reason_map = {
      "STOP": "stop",
      "MAX_TOKENS": "length",
      "SAFETY": "content_filter",
      "RECITATION": "content_filter",
      "OTHER": "null"
    };
    return reason_map[finish_reason] || finish_reason.toLowerCase();
  }
  _transform_usage_to_openai() {
    if (!this._res.usageMetadata) {
      return {
        prompt_tokens: null,
        completion_tokens: null,
        total_tokens: null
      };
    }
    return {
      prompt_tokens: this._res.usageMetadata.promptTokenCount || null,
      completion_tokens: this._res.usageMetadata.candidatesTokenCount || null,
      total_tokens: this._res.usageMetadata.totalTokenCount || null
    };
  }
  handle_chunk(chunk) {
    let chunk_trimmed = chunk.trim();
    if (["[", ","].includes(chunk_trimmed[0])) chunk_trimmed = chunk_trimmed.slice(1);
    if (["]", ","].includes(chunk_trimmed[chunk_trimmed.length - 1])) chunk_trimmed = chunk_trimmed.slice(0, -1);
    const data = JSON.parse(chunk_trimmed);
    if (data.candidates?.[0]?.content?.parts?.[0]?.text?.length) {
      this._res.candidates[0].content.parts[0].text += data.candidates[0].content.parts[0].text;
    }
    if (data.candidates?.[0]?.content?.role?.length) {
      this._res.candidates[0].content.role = data.candidates[0].content.role;
    }
    if (data.candidates?.[0]?.finishReason?.length) {
      this._res.candidates[0].finishReason += data.candidates[0].finishReason;
    }
    if (data.promptFeedback) {
      this._res.promptFeedback = {
        ...this._res.promptFeedback || {},
        ...data.promptFeedback
      };
    }
    if (data.usageMetadata) {
      this._res.usageMetadata = {
        ...this._res.usageMetadata || {},
        ...data.usageMetadata
      };
    }
    if (data.candidates?.[0]?.content?.parts?.[0]?.functionCall) {
      if (!this._res.candidates[0].content.parts[0].functionCall) {
        this._res.candidates[0].content.parts[0].functionCall = {
          name: "",
          args: {}
        };
      }
      this._res.candidates[0].content.parts[0].functionCall.name += data.candidates[0].content.parts[0].functionCall.name;
      if (data.candidates[0].content.parts[0].functionCall.args) {
        Object.entries(data.candidates[0].content.parts[0].functionCall.args).forEach(([key, value]) => {
          if (!this._res.candidates[0].content.parts[0].functionCall.args[key]) {
            this._res.candidates[0].content.parts[0].functionCall.args[key] = "";
          }
          this._res.candidates[0].content.parts[0].functionCall.args[key] += value;
        });
      }
    }
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-chat-model/adapters/open_router.js
var SmartChatModelOpenRouterAdapter = class extends SmartChatModelApiAdapter {
  static key = "open_router";
  static defaults = {
    description: "Open Router",
    type: "API",
    endpoint: "https://openrouter.ai/api/v1/chat/completions",
    streaming: true,
    adapter: "OpenRouter",
    models_endpoint: "https://openrouter.ai/api/v1/models",
    default_model: "mistralai/mistral-7b-instruct:free",
    signup_url: "https://accounts.openrouter.ai/sign-up?redirect_url=https%3A%2F%2Fopenrouter.ai%2Fkeys",
    can_use_tools: true
  };
  /**
   * Get request adapter class
   * @returns {typeof SmartChatModelOpenRouterRequestAdapter} Request adapter class
   */
  get req_adapter() {
    return SmartChatModelOpenRouterRequestAdapter;
  }
  /**
   * Get response adapter class
   * @returns {typeof SmartChatModelOpenRouterResponseAdapter} Response adapter class
   */
  get res_adapter() {
    return SmartChatModelOpenRouterResponseAdapter;
  }
  /**
   * Get API key from various sources
   * @returns {string|undefined} API key if available
   */
  get api_key() {
    return this.main.opts.api_key || this.adapter_settings?.api_key || "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";
  }
  /**
   * Count tokens in input text (rough estimate)
   * @param {string|Object} input - Text to count tokens for
   * @returns {Promise<number>} Estimated token count
   */
  async count_tokens(input) {
    const text = typeof input === "string" ? input : JSON.stringify(input);
    return Math.ceil(text.length / 4);
  }
  get models_request_params() {
    return {
      url: this.models_endpoint,
      method: "GET"
    };
  }
  /**
   * Parse model data from OpenRouter API response
   * @param {Object} model_data - Raw model data
   * @returns {Object} Map of model objects with capabilities and limits
   */
  parse_model_data(model_data) {
    if (model_data.data) {
      model_data = model_data.data;
    }
    if (model_data.error) throw new Error(model_data.error);
    return model_data.reduce((acc, model) => {
      acc[model.id] = {
        model_name: model.id,
        id: model.id,
        max_input_tokens: model.context_length,
        description: model.name,
        can_use_tools: model.description.includes("tool use") || model.description.includes("function call"),
        multimodal: model.architecture.modality === "multimodal",
        raw: model
      };
      return acc;
    }, {});
  }
};
var SmartChatModelOpenRouterRequestAdapter = class extends SmartChatModelRequestAdapter {
  to_platform(stream = false) {
    const req = this.to_openai(stream);
    return req;
  }
  _get_openai_content(message) {
    if (message.role === "user") {
      if (Array.isArray(message.content) && message.content.every((part) => part.type === "text")) {
        return message.content.map((part) => part.text).join("\n");
      }
    }
    return message.content;
  }
};
var SmartChatModelOpenRouterResponseAdapter = class extends SmartChatModelResponseAdapter {
  static get platform_res() {
    return {
      id: "",
      object: "chat.completion",
      created: 0,
      model: "",
      choices: [],
      usage: {}
    };
  }
  to_platform() {
    return this.to_openai();
  }
  get object() {
    return "chat.completion";
  }
  get error() {
    if (!this._res.error) return null;
    const error = this._res.error;
    if (!error.message) error.message = "";
    if (this._res.error.metadata?.raw) {
      if (typeof this._res.error.metadata.raw === "string") {
        error.message += `

${this._res.error.metadata.raw}`;
      } else {
        error.message += `

${JSON.stringify(this._res.error.metadata.raw, null, 2)}`;
      }
    }
    return error;
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-chat-model/adapters/lm_studio.js
var SmartChatModelLmStudioAdapter = class extends SmartChatModelApiAdapter {
  static key = "lm_studio";
  /** @type {import('./_adapter.js').SmartChatModelAdapter['constructor']['defaults']} */
  static defaults = {
    description: "LM Studio (OpenAI\u2011compatible)",
    type: "API",
    endpoint: "http://localhost:1234/v1/chat/completions",
    streaming: true,
    adapter: "LM_Studio_OpenAI_Compat",
    models_endpoint: "http://localhost:1234/v1/models",
    default_model: "",
    signup_url: "https://lmstudio.ai/docs/api/openai-api",
    can_use_tools: true,
    api_key: "no api key required"
  };
  /* ------------------------------------------------------------------ *
   *  Request / Response classes
   * ------------------------------------------------------------------ */
  get req_adapter() {
    return SmartChatModelLmStudioRequestAdapter;
  }
  get res_adapter() {
    return SmartChatModelLmStudioResponseAdapter;
  }
  /* ------------------------------------------------------------------ *
   *  Settings
   * ------------------------------------------------------------------ */
  /**
   * Extend the base settings with a read‑only HTML block that reminds the
   * user to enable CORS inside LM Studio. The Smart View renderer treats
   * `type: "html"` as a static fragment, so no extra runtime logic is needed.
   */
  get settings_config() {
    const config = super.settings_config;
    delete config["[CHAT_ADAPTER].api_key"];
    return {
      ...config,
      "[CHAT_ADAPTER].cors_instructions": {
        /* visible only when this adapter is selected */
        name: "CORS required",
        type: "html",
        value: "<p>Before sending requests from the browser you must enable CORS inside LM Studio:</p><p>Open the LM Studio application, choose <strong>Settings > OpenAI API Compatible</strong> and enable <strong>Allow Cross\u2011Origin Requests (CORS)</strong>. Restart the server afterwards.</p><p>With CORS enabled the local endpoint <code>http://localhost:1234</code> becomes reachable from web contexts.</p>"
      }
    };
  }
  /* ------------------------------------------------------------------ *
   *  Model list helpers
   * ------------------------------------------------------------------ */
  /**
   * LM Studio returns an OpenAI‑style list; normalise to the project shape.
   */
  parse_model_data(model_data) {
    if (model_data.object !== "list" || !Array.isArray(model_data.data)) {
      return { _: { id: "No models found." } };
    }
    const out = {};
    for (const m of model_data.data) {
      out[m.id] = {
        id: m.id,
        model_name: m.id,
        description: `LM Studio model: ${m.id}`,
        multimodal: false
      };
    }
    return out;
  }
  get models_endpoint_method() {
    return "get";
  }
  /**
   * Count tokens in input text (no dedicated endpoint)
   * Rough estimate: 1 token ~ 4 chars
   * @param {string|Object} input
   * @returns {Promise<number>}
   */
  async count_tokens(input) {
    const text = typeof input === "string" ? input : JSON.stringify(input);
    return Math.ceil(text.length / 4);
  }
  /**
   * Test API key - LM Studio doesn't require API key. Always true.
   * @returns {Promise<boolean>}
   */
  async test_api_key() {
    return true;
  }
  get api_key() {
    return "no api key required";
  }
  /**
   * Validate configuration
   */
  validate_config() {
    if (!this.adapter_config.model_key) {
      return { valid: false, message: "No model selected." };
    }
    return { valid: true, message: "Configuration is valid." };
  }
};
var SmartChatModelLmStudioRequestAdapter = class extends SmartChatModelRequestAdapter {
  to_platform(streaming = false) {
    const req = this.to_openai(streaming);
    const body = JSON.parse(req.body);
    if (this.tool_choice?.function?.name) {
      const last_msg = body.messages[body.messages.length - 1];
      if (typeof last_msg.content === "string") {
        last_msg.content = [
          { type: "text", text: last_msg.content }
        ];
      }
      last_msg.content.push({
        type: "text",
        text: `Use the "${this.tool_choice.function.name}" tool.`
      });
      body.tool_choice = "required";
    } else if (body.tool_choice && typeof body.tool_choice === "object") {
      body.tool_choice = "auto";
    }
    req.body = JSON.stringify(body);
    return req;
  }
};
var SmartChatModelLmStudioResponseAdapter = class extends SmartChatModelResponseAdapter {
};

// node_modules/obsidian-smart-env/node_modules/smart-chat-model/adapters/ollama.js
var SmartChatModelOllamaAdapter = class extends SmartChatModelApiAdapter {
  static key = "ollama";
  static defaults = {
    description: "Ollama (Local)",
    type: "API",
    models_endpoint: "http://localhost:11434/api/tags",
    endpoint: "http://localhost:11434/api/chat",
    api_key: "na",
    // streaming: false, // TODO: Implement streaming
    streaming: true
  };
  req_adapter = SmartChatModelOllamaRequestAdapter;
  res_adapter = SmartChatModelOllamaResponseAdapter;
  /**
   * Get parameters for models request - no auth needed for local instance
   * @returns {Object} Request parameters
   */
  get models_request_params() {
    return {
      url: this.adapter_config.models_endpoint
    };
  }
  /**
   * Get available models from local Ollama instance
   * @param {boolean} [refresh=false] - Whether to refresh cached models
   * @returns {Promise<Object>} Map of model objects
   */
  async get_models(refresh = false) {
    if (!refresh && this.adapter_config?.models && typeof this.adapter_config.models === "object" && Object.keys(this.adapter_config.models).length > 0) return this.adapter_config.models;
    try {
      const list_resp = await this.http_adapter.request(this.models_request_params);
      const list_data = await list_resp.json();
      const models_raw_data = [];
      for (const model of list_data.models) {
        const model_details_resp = await this.http_adapter.request({
          url: `http://localhost:11434/api/show`,
          method: "POST",
          body: JSON.stringify({ model: model.name })
        });
        const model_details_data = await model_details_resp.json();
        models_raw_data.push({ ...model_details_data, name: model.name });
      }
      const model_data = this.parse_model_data(models_raw_data);
      this.adapter_settings.models = model_data;
      this.model.re_render_settings();
      return model_data;
    } catch (error) {
      console.error("Failed to fetch model data:", error);
      return { "_": { id: `Failed to fetch models from ${this.model.adapter_name}` } };
    }
  }
  /**
   * Parse model data from Ollama API response
   * @param {Object[]} model_data - Raw model data from Ollama
   * @returns {Object} Map of model objects with capabilities and limits
   */
  parse_model_data(model_data) {
    if (!Array.isArray(model_data)) {
      this.model_data = {};
      console.error("Invalid model data format from Ollama:", model_data);
      return {};
    }
    if (model_data.length === 0) {
      this.model_data = { "no_models_available": {
        id: "no_models_available",
        name: "No models currently available"
      } };
      return this.model_data;
    }
    return model_data.reduce((acc, model) => {
      const out = {
        model_name: model.name,
        id: model.name,
        multimodal: false,
        max_input_tokens: Object.entries(model.model_info).find((m) => m[0].includes(".context_length"))[1],
        can_use_tools: true
        // TODO: CHECK MODELFILE FOR TOOLS SUPPORT
      };
      acc[model.name] = out;
      return acc;
    }, {});
  }
  /**
   * Override settings config to remove API key setting since not needed for local instance
   * @returns {Object} Settings configuration object
   */
  get settings_config() {
    const config = super.settings_config;
    delete config["[CHAT_ADAPTER].api_key"];
    return config;
  }
  is_end_of_stream(event) {
    return event.data.includes('"done_reason"');
  }
};
var SmartChatModelOllamaRequestAdapter = class extends SmartChatModelRequestAdapter {
  /**
   * Convert request to Ollama format
   * @returns {Object} Request parameters in Ollama format
   */
  to_platform(streaming = false) {
    const ollama_body = {
      model: this.model,
      messages: this._transform_messages_to_ollama(),
      options: this._transform_parameters_to_ollama(),
      stream: streaming || this.stream
      // format: 'json', // only used for tool calls since returns JSON in content body
    };
    if (this.tools) {
      ollama_body.tools = this._transform_functions_to_tools();
      if (this.tool_choice?.function?.name) {
        ollama_body.messages[ollama_body.messages.length - 1].content += `

Use the "${this.tool_choice.function.name}" tool.`;
        ollama_body.format = "json";
      }
    }
    return {
      url: this.adapter.endpoint,
      method: "POST",
      body: JSON.stringify(ollama_body)
    };
  }
  /**
   * Transform messages to Ollama format
   * @returns {Array} Messages in Ollama format
   * @private
   */
  _transform_messages_to_ollama() {
    return this.messages.map((message) => {
      const ollama_message = {
        role: message.role,
        content: this._transform_content_to_ollama(message.content)
      };
      const images = this._extract_images_from_content(message.content);
      if (images.length > 0) {
        ollama_message.images = images.map((img) => img.replace(/^data:image\/[^;]+;base64,/, ""));
      }
      return ollama_message;
    });
  }
  /**
   * Transform content to Ollama format
   * @param {string|Array} content - Message content
   * @returns {string} Content in Ollama format
   * @private
   */
  _transform_content_to_ollama(content) {
    if (Array.isArray(content)) {
      return content.filter((item) => item.type === "text").map((item) => item.text).join("\n");
    }
    return content;
  }
  /**
   * Extract images from content
   * @param {string|Array} content - Message content
   * @returns {Array} Array of image URLs
   * @private
   */
  _extract_images_from_content(content) {
    if (!Array.isArray(content)) return [];
    return content.filter((item) => item.type === "image_url").map((item) => item.image_url.url);
  }
  /**
   * Transform functions to tools format
   * @returns {Array} Tools array in Ollama format
   * @private
   */
  _transform_functions_to_tools() {
    return this.tools;
  }
  /**
   * Transform parameters to Ollama options format
   * @returns {Object} Options in Ollama format
   * @private
   */
  _transform_parameters_to_ollama() {
    const options = {};
    if (this.max_tokens) options.num_predict = this.max_tokens;
    if (this.temperature) options.temperature = this.temperature;
    if (this.top_p) options.top_p = this.top_p;
    if (this.frequency_penalty) options.frequency_penalty = this.frequency_penalty;
    if (this.presence_penalty) options.presence_penalty = this.presence_penalty;
    return options;
  }
};
var SmartChatModelOllamaResponseAdapter = class extends SmartChatModelResponseAdapter {
  static get platform_res() {
    return {
      model: "",
      created_at: null,
      message: {
        role: "",
        content: ""
      },
      total_duration: 0,
      load_duration: 0,
      prompt_eval_count: 0,
      prompt_eval_duration: 0,
      eval_count: 0,
      eval_duration: 0
    };
  }
  /**
   * Convert response to OpenAI format
   * @returns {Object} Response in OpenAI format
   */
  to_openai() {
    return {
      id: this._res.created_at,
      object: "chat.completion",
      created: Date.now(),
      model: this._res.model,
      choices: [
        {
          index: 0,
          message: this._transform_message_to_openai(),
          finish_reason: this._res.done_reason
        }
      ],
      usage: this._transform_usage_to_openai()
    };
  }
  /**
   * Transform message to OpenAI format
   * @returns {Object} Message in OpenAI format
   * @private
   */
  _transform_message_to_openai() {
    return {
      role: this._res.message.role,
      content: this._res.message.content,
      tool_calls: this._res.message.tool_calls
    };
  }
  /**
   * Transform usage statistics to OpenAI format
   * @returns {Object} Usage statistics in OpenAI format
   * @private
   */
  _transform_usage_to_openai() {
    return {
      prompt_tokens: this._res.prompt_eval_count || 0,
      completion_tokens: this._res.eval_count || 0,
      total_tokens: (this._res.prompt_eval_count || 0) + (this._res.eval_count || 0)
    };
  }
  /**
   * Parse chunk adds delta to content as expected output format
   */
  handle_chunk(chunk) {
    chunk = JSON.parse(chunk || "{}");
    if (chunk.created_at && !this._res.created_at) {
      this._res.created_at = chunk.created_at;
    }
    if (chunk.message?.content) {
      this._res.message.content += chunk.message.content;
    }
    if (chunk.message?.role) {
      this._res.message.role = chunk.message.role;
    }
    if (chunk.model) {
      this._res.model = chunk.model;
    }
    if (chunk.message?.tool_calls) {
      if (!this._res.message.tool_calls) {
        this._res.message.tool_calls = [{
          id: "",
          type: "function",
          function: {
            name: "",
            arguments: ""
          }
        }];
      }
      if (chunk.message.tool_calls[0].id) {
        this._res.message.tool_calls[0].id += chunk.message.tool_calls[0].id;
      }
      if (chunk.message.tool_calls[0].function.name) {
        this._res.message.tool_calls[0].function.name += chunk.message.tool_calls[0].function.name;
      }
      if (chunk.message.tool_calls[0].function.arguments) {
        if (typeof chunk.message.tool_calls[0].function.arguments === "string") {
          this._res.message.tool_calls[0].function.arguments += chunk.message.tool_calls[0].function.arguments;
        } else {
          this._res.message.tool_calls[0].function.arguments = chunk.message.tool_calls[0].function.arguments;
        }
      }
    }
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-chat-model/adapters/_custom.js
var adapters_map = {
  "openai": {
    req: SmartChatModelRequestAdapter,
    res: SmartChatModelResponseAdapter
  },
  "anthropic": {
    req: SmartChatModelAnthropicRequestAdapter,
    res: SmartChatModelAnthropicResponseAdapter
  },
  "gemini": {
    req: SmartChatModelGeminiRequestAdapter,
    res: SmartChatModelGeminiResponseAdapter
  },
  "lm_studio": {
    req: SmartChatModelLmStudioRequestAdapter,
    res: SmartChatModelLmStudioResponseAdapter
  },
  "ollama": {
    req: SmartChatModelOllamaRequestAdapter,
    res: SmartChatModelOllamaResponseAdapter
  }
};
var SmartChatModelCustomAdapter = class extends SmartChatModelApiAdapter {
  static key = "custom";
  static defaults = {
    description: "Custom API (Local or Remote, OpenAI format)",
    type: "API",
    /**
     * new default property: 'api_adapter' indicates which
     * request/response adapter set to use internally
     */
    api_adapter: "openai"
  };
  /**
   * Provide dynamic request/response classes
   * based on current adapter_config.api_adapter setting
   * ----------------------------------------------------
   */
  /**
   * @override
   * @returns {typeof SmartChatModelRequestAdapter}
   */
  get req_adapter() {
    const adapter_name = this.adapter_config.api_adapter || "openai";
    const map_entry = adapters_map[adapter_name];
    return map_entry && map_entry.req ? map_entry.req : SmartChatModelRequestAdapter;
  }
  /**
   * @override
   * @returns {typeof SmartChatModelResponseAdapter}
   */
  get res_adapter() {
    const adapter_name = this.adapter_config.api_adapter || "openai";
    const map_entry = adapters_map[adapter_name];
    return map_entry && map_entry.res ? map_entry.res : SmartChatModelResponseAdapter;
  }
  /**
   * Synthesize a custom endpoint from the config fields.
   * All fields are optional; fallback to a minimal default.
   * @returns {string}
   */
  get endpoint() {
    const protocol = this.adapter_config.protocol || "http";
    const hostname = this.adapter_config.hostname || "localhost";
    const port = this.adapter_config.port ? `:${this.adapter_config.port}` : "";
    let path = this.adapter_config.path || "";
    if (path && !path.startsWith("/")) path = `/${path}`;
    return `${protocol}://${hostname}${port}${path}`;
  }
  get_adapters_as_options() {
    return Object.keys(adapters_map).map((adapter_name) => ({ value: adapter_name, name: adapter_name }));
  }
  /**
   * Provide custom settings for configuring
   * the user-defined fields plus the new 'api_adapter'.
   * @override
   * @returns {Object} settings configuration
   */
  get settings_config() {
    return {
      /**
       * Select which specialized request/response adapter
       * you'd like to use for your custom endpoint.
       */
      "[CHAT_ADAPTER].api_adapter": {
        name: "API Adapter",
        type: "dropdown",
        description: "Pick a built-in or external adapter to parse request/response data.",
        // Provide a short selection set, or dynamically gather from keys of adapters_map
        options_callback: "adapter.get_adapters_as_options",
        default: "openai"
      },
      "[CHAT_ADAPTER].id": {
        name: "Model Name",
        type: "text",
        description: "Enter the model name for your endpoint if needed."
      },
      "[CHAT_ADAPTER].protocol": {
        name: "Protocol",
        type: "text",
        description: "e.g. http or https"
      },
      "[CHAT_ADAPTER].hostname": {
        name: "Hostname",
        type: "text",
        description: "e.g. localhost or some.remote.host"
      },
      "[CHAT_ADAPTER].port": {
        name: "Port",
        type: "number",
        description: "Port number or leave blank"
      },
      "[CHAT_ADAPTER].path": {
        name: "Path",
        type: "text",
        description: "Path portion of the URL (leading slash optional)"
      },
      "[CHAT_ADAPTER].streaming": {
        name: "Streaming",
        type: "toggle",
        description: "Enable streaming if your API supports it."
      },
      "[CHAT_ADAPTER].max_input_tokens": {
        name: "Max Input Tokens",
        type: "number",
        description: "Max number of tokens your model can handle in the prompt."
      },
      "[CHAT_ADAPTER].api_key": {
        name: "API Key",
        type: "password",
        description: "If your service requires an API key, add it here."
      }
    };
  }
  /**
   * Return 'true' for get_models params since user might
   * not rely on auto-populating. 
   * @override
   * @returns {true}
   */
  validate_get_models_params() {
    return true;
  }
  /**
   * Unlike most API-based adapters, we do NOT force the user to have model_key set.
   * So we override validate_config() to skip the "No model selected" error.
   * Since this is a custom adapter, the onus is on the user to configure it correctly.
   * @override
   * @returns {Object} { valid: boolean, message: string }
   */
  validate_config() {
    return { valid: true, message: "Configuration is valid." };
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-chat-model/adapters/groq.js
var SmartChatModelGroqAdapter = class extends SmartChatModelApiAdapter {
  static key = "groq";
  static defaults = {
    description: "Groq",
    type: "API",
    endpoint: "https://api.groq.com/openai/v1/chat/completions",
    streaming: true,
    adapter: "Groq",
    models_endpoint: "https://api.groq.com/openai/v1/models",
    default_model: "llama3-8b-8192",
    signup_url: "https://groq.com",
    can_use_tools: true
  };
  /**
   * Request adapter class
   * @returns {typeof SmartChatModelGroqRequestAdapter}
   */
  get req_adapter() {
    return SmartChatModelGroqRequestAdapter;
  }
  /**
   * Response adapter class
   * @returns {typeof SmartChatModelGroqResponseAdapter}
   */
  get res_adapter() {
    return SmartChatModelGroqResponseAdapter;
  }
  /**
   * Retrieve the list of models from Groq's API.
   * @returns {Promise<Object>} A dictionary of models keyed by their id
   */
  async get_models(refresh = false) {
    if (!refresh && this.adapter_config?.models && Object.keys(this.adapter_config.models).length > 0) {
      return this.adapter_config.models;
    }
    const request_params = {
      url: this.models_endpoint,
      method: "GET",
      headers: {
        "Authorization": `Bearer ${this.api_key}`
      }
    };
    try {
      const resp = await this.http_adapter.request(request_params);
      const data = await resp.json();
      const model_data = this.parse_model_data(data);
      this.adapter_settings.models = model_data;
      this.model.re_render_settings();
      return model_data;
    } catch (error) {
      console.error("Failed to fetch Groq model data:", error);
      return { "_": { id: "Failed to fetch models from Groq" } };
    }
  }
  /**
   * Parse model data from Groq API format to a dictionary keyed by model ID.
   * The API returns a list of model objects like:
   * {
   *   "object": "list",
   *   "data": [ { "id": "...", "object": "model", ... }, ... ]
   * }
   * 
   * We'll convert each model to:
   * {
   *   model_name: model.id,
   *   id: model.id,
   *   max_input_tokens: model.context_window,
   *   description: `Owned by: ${model.owned_by}, context: ${model.context_window}`,
   *   multimodal: Check if model name or description suggests multimodality
   * }
   */
  parse_model_data(model_data) {
    if (model_data.object !== "list" || !Array.isArray(model_data.data)) {
      return { "_": { id: "No models found." } };
    }
    const parsed = {};
    for (const m of model_data.data) {
      parsed[m.id] = {
        model_name: m.id,
        id: m.id,
        max_input_tokens: m.context_window || 8192,
        description: `Owned by: ${m.owned_by}, context: ${m.context_window}`,
        // A basic heuristic for multimodal: if 'vision' or 'tool' is in model id
        // Adjust as needed based on known capabilities
        multimodal: m.id.includes("vision")
      };
    }
    return parsed;
  }
  /**
   * Validate configuration for Groq
   * @returns {Object} { valid: boolean, message: string }
   */
  validate_config() {
    if (!this.adapter_config.model_key) return { valid: false, message: "No model selected." };
    if (!this.api_key) {
      return { valid: false, message: "API key is missing." };
    }
    return { valid: true, message: "Configuration is valid." };
  }
};
var SmartChatModelGroqRequestAdapter = class extends SmartChatModelRequestAdapter {
  _get_openai_content(message) {
    if (["assistant", "tool"].includes(message.role)) {
      if (Array.isArray(message.content)) {
        return message.content.map((part) => {
          if (typeof part === "string") return part;
          if (part?.text) return part.text;
          return "";
        }).join("\n");
      }
    }
    return message.content;
  }
};
var SmartChatModelGroqResponseAdapter = class extends SmartChatModelResponseAdapter {
};

// node_modules/obsidian-smart-env/node_modules/smart-chat-model/adapters/xai.js
var SmartChatModelXaiAdapter = class extends SmartChatModelApiAdapter {
  /** Human-readable platform key used by SmartChatModel */
  static key = "xai";
  /** @type {import('./_adapter.js').SmartChatModelAdapter['constructor']['defaults']} */
  static defaults = {
    description: "xAI Grok",
    type: "API",
    adapter: "xAI_Grok",
    endpoint: "https://api.x.ai/v1/chat/completions",
    streaming: true,
    models_endpoint: "https://api.x.ai/v1/models",
    default_model: "grok-3-mini-beta",
    signup_url: "https://ide.x.ai",
    can_use_tools: true
  };
  /** Grok is OpenAI-compatible → reuse the stock adapters */
  get req_adapter() {
    return SmartChatModelRequestAdapter;
  }
  get res_adapter() {
    return SmartChatModelResponseAdapter;
  }
  /* ------------------------------------------------------------------ *
   *  Model-list helpers
   * ------------------------------------------------------------------ */
  /**
   * The Grok `/v1/models` route is **GET**, not POST.
   * Override the HTTP verb so `get_models()` works.
   * @returns {string} 'GET'
   */
  get models_endpoint_method() {
    return "GET";
  }
  /**
   * Parse `/v1/models` payload to the canonical shape used by SmartChat.
   *
   * Grok returns:
   * ```json
   * { "object":"list",
   *   "data":[{ "id":"grok-3-beta", "context_length":128000, …}] }
   * ```
   */
  parse_model_data(model_data = {}) {
    const list = model_data.data || model_data.models || [];
    return list.reduce((acc, m) => {
      const id = m.id || m.name;
      acc[id] = {
        id,
        model_name: id,
        description: m.description || `context: ${m.context_length || "n/a"}`,
        max_input_tokens: m.context_length || 128e3,
        multimodal: !!m.modality && m.modality.includes("vision"),
        raw: m
      };
      return acc;
    }, {});
  }
  /* ------------------------------------------------------------------ *
   *  Validation helpers
   * ------------------------------------------------------------------ */
  validate_config() {
    if (!this.adapter_config.model_key) {
      return { valid: false, message: "No model selected." };
    }
    if (!this.api_key) {
      return { valid: false, message: "API key is missing." };
    }
    return { valid: true, message: "Configuration is valid." };
  }
};

// node_modules/obsidian-smart-env/default.config.js
var import_obsidian13 = require("obsidian");

// node_modules/obsidian-smart-env/node_modules/smart-completions/smart_completions.js
var SmartCompletions = class extends Collection {
  /**
   * Lazily instantiates and returns a chat_model. Similar to how
   * SmartEntities implements embed_model. You can adapt this
   * depending on how your environment is structured.
   *
   * @returns {Object|null} The chat model instance or null if not configured
   */
  get chat_model() {
    if (!this._chat_model) {
      this._chat_model = this.env.init_module("smart_chat_model", {
        model_config: {},
        settings: this.settings.chat_model ?? this.env.smart_chat_threads?.settings?.chat_model ?? {},
        reload_model: this.reload_chat_model.bind(this),
        re_render_settings: this.re_render_settings?.bind(this) ?? (() => {
          console.log("no re_render_settings");
        })
      });
    }
    return this._chat_model;
  }
  /**
   * Force unload & reload of chat model if user changes adapter or settings.
   */
  reload_chat_model() {
    if (this._chat_model?.unload) {
      this._chat_model.unload();
    }
    this._chat_model = null;
  }
  /**
   * In addition to base collection settings, merges `chat_model.settings_config`.
   * Allows the SmartCompletions UI to show chat-model relevant settings.
   * @returns {Object} Merged settings config
   */
  get settings_config() {
    return {};
  }
  /**
   * (Optional) An array of request adapter classes. SmartCompletion items will invoke these
   * in `run_completion_adapters()`. For example, we can list the context adapter or other custom ones.
   */
  get completion_adapters() {
    if (!this._completion_adapters) {
      this._completion_adapters = {};
      Object.values(this.opts.completion_adapters).forEach((adapter) => {
        this._completion_adapters[adapter.property_name] = adapter;
      });
    }
    return this._completion_adapters;
  }
};

// node_modules/smart-utils/coerce_primitives.js
function coerce_primitives(value) {
  if (typeof value !== "string") {
    return value;
  }
  const trimmed_value = value.trim();
  if (trimmed_value === "true") {
    return true;
  }
  if (trimmed_value === "false") {
    return false;
  }
  const float_pattern = /^-?\d+\.\d+$/;
  if (float_pattern.test(trimmed_value)) {
    const num = parseFloat(trimmed_value);
    if (num.toString() === trimmed_value) {
      return num;
    }
  }
  const int_pattern = /^-?(?:0|[1-9]\d*)$/;
  if (int_pattern.test(trimmed_value)) {
    return Number(trimmed_value);
  }
  return value;
}

// node_modules/smart-utils/parse_xml_fragments.js
function parse_xml_fragments(xml_input) {
  if (typeof xml_input !== "string" || xml_input.trim() === "") {
    return null;
  }
  const VERBATIM_TAGS = /* @__PURE__ */ new Set(["think"]);
  const compress_whitespace = (str) => str.replace(/\s+/g, " ").trim();
  const parse_attributes = (str) => {
    if (!str) return {};
    const attrs = {};
    const attr_re = /(\w[\w.\-]*)\s*=\s*"([^"]*)"/g;
    let m;
    while ((m = attr_re.exec(str)) !== null) {
      const [, key, raw_val] = m;
      attrs[key] = coerce_primitives(raw_val);
    }
    return attrs;
  };
  const attach_child = (map, tag, node) => {
    if (tag in map) {
      const existing = map[tag];
      map[tag] = Array.isArray(existing) ? [...existing, node] : [existing, node];
    } else {
      map[tag] = node;
    }
  };
  const finalize_node = (ctx) => {
    const text_raw = ctx.verbatim ? ctx.text.replace(/^\s*\n/, "").replace(/\s+$/, "") : compress_whitespace(ctx.text);
    if (Object.keys(ctx.children_map).length) {
      ctx.node.contents = ctx.children_map;
    } else if (text_raw !== "") {
      ctx.node.contents = ctx.verbatim ? text_raw : coerce_primitives(text_raw);
    } else {
      ctx.node.contents = null;
    }
  };
  const cleaned = xml_input.replace(/<!--[\s\S]*?-->/g, "");
  const token_re = /<[^>]+>|[^<]+/g;
  const root_map = {};
  const stack = [];
  let match;
  while ((match = token_re.exec(cleaned)) !== null) {
    const token = match[0];
    if (stack.length) {
      const top = stack[stack.length - 1];
      if (top.verbatim) {
        if (token.startsWith(`</${top.tag_name}`)) {
          stack.pop();
          finalize_node(top);
          if (stack.length === 0) {
            attach_child(root_map, top.tag_name, top.node);
          } else {
            attach_child(stack[stack.length - 1].children_map, top.tag_name, top.node);
          }
          continue;
        }
        top.text += token;
        continue;
      }
    }
    if (token.startsWith("<")) {
      if (token.startsWith("</")) {
        const tag_name = token.slice(2, -1).trim();
        if (!stack.length) return null;
        const ctx = stack.pop();
        if (ctx.tag_name !== tag_name) return null;
        finalize_node(ctx);
        if (stack.length === 0) {
          attach_child(root_map, tag_name, ctx.node);
        } else {
          attach_child(stack[stack.length - 1].children_map, tag_name, ctx.node);
        }
      } else {
        const self_closing = token.endsWith("/>");
        const body = self_closing ? token.slice(1, -2) : token.slice(1, -1);
        const first_space = body.indexOf(" ");
        const tag_name = first_space === -1 ? body : body.slice(0, first_space);
        const attr_str = first_space === -1 ? "" : body.slice(first_space + 1);
        const attributes = parse_attributes(attr_str);
        const node = Object.keys(attributes).length ? { attributes } : {};
        if (self_closing) {
          node.contents = null;
          if (stack.length === 0) {
            attach_child(root_map, tag_name, node);
          } else {
            attach_child(stack[stack.length - 1].children_map, tag_name, node);
          }
        } else {
          stack.push({
            tag_name,
            node,
            text: "",
            children_map: {},
            verbatim: VERBATIM_TAGS.has(tag_name)
          });
        }
      }
    } else {
      if (stack.length) stack[stack.length - 1].text += token;
    }
  }
  while (stack.length) {
    const ctx = stack.pop();
    finalize_node(ctx);
    if (stack.length === 0) {
      attach_child(root_map, ctx.tag_name, ctx.node);
    } else {
      attach_child(stack[stack.length - 1].children_map, ctx.tag_name, ctx.node);
    }
  }
  return Object.keys(root_map).length ? root_map : null;
}

// node_modules/obsidian-smart-env/node_modules/smart-completions/smart_completion.js
var SmartCompletion = class extends CollectionItem {
  constructor(env, data = null) {
    super(env, data);
    this.run_adapter_item_constructors();
  }
  run_adapter_item_constructors() {
    for (const [key, AdapterClass] of Object.entries(this.completion_adapters)) {
      AdapterClass.item_constructor?.(this);
    }
  }
  /**
   * Default data structure for a new SmartCompletion item.
   * @static
   * @returns {Object}
   */
  static get defaults() {
    return {
      data: {
        completion: {
          request: {},
          responses: [],
          chat_model: null
        }
      }
    };
  }
  /**
   * get_key
   * Overridden to produce a unique key based on a hash of this.data plus the current timestamp.
   * @returns {string}
   */
  get_key() {
    const hash = murmur_hash_32_alphanumeric(JSON.stringify(this.data));
    const ts = Date.now();
    return `${hash}-${ts}`;
  }
  /**
   * Called automatically in many cases (via create_or_update).
   * You can also call it manually if needed.
   */
  async init(completion_opts = {}) {
    if (this.data.chat_model_config) {
      this.chat_model = this.env.init_module("smart_chat_model", {
        settings: this.data.chat_model_config
      });
    }
    await this.build_request();
    await this.complete(completion_opts);
    await this.parse_response();
    this.queue_save();
    this.collection.process_save_queue();
  }
  /**
   * Collects or transforms data into a final `completion.request` structure
   * by running any applicable completion adapters.
   * @returns {Promise<void>}
   */
  async build_request() {
    this.data.completion.request = {};
    const adapters = Object.entries(this.completion_adapters).map(([key, AdapterClass]) => ({
      key,
      AdapterClass,
      order: AdapterClass.order ?? 0
    })).sort((a, b) => a.order - b.order);
    for (const { AdapterClass, key } of adapters) {
      const property = AdapterClass.property_name;
      if (property && this.data[property]) {
        const adapter = new AdapterClass(this);
        await adapter.to_request?.();
      }
    }
    return this.data.completion.request;
  }
  async parse_response() {
    const data_keys = Object.keys(this.data);
    for (const key of data_keys) {
      const AdapterClass = this.completion_adapters[key];
      if (AdapterClass) {
        const adapter = new AdapterClass(this);
        await adapter.from_response?.();
      }
    }
    return this.data.completion.responses;
  }
  /**
   * Calls the underlying chat model, stores the response in completion.responses.
   * @returns {Promise<void>}
   */
  async complete(opts = {}) {
    if (!this.data.completion || !this.data.completion.request) {
      console.warn("No completion.request found, skipping complete().");
      return;
    }
    const chat_model = this.get_chat_model(opts);
    this.data.completion.chat_model = {
      model_key: chat_model.model_key,
      platform_key: chat_model.adapter_name
    };
    if (!chat_model) {
      console.warn("No chat model available for SmartCompletion. Check environment config.");
      return;
    }
    try {
      const request_payload = this.data.completion.request;
      const stream = opts.stream;
      const result = stream ? await chat_model.stream(request_payload, this.stream_handlers(opts.stream_handlers)) : await chat_model.complete(request_payload);
      if (!stream) {
        this.data.completion.responses.push({
          timestamp: Date.now(),
          ...result
        });
      }
      const typing_indicator = this.container?.closest(".smart-chat-thread")?.querySelector(".smart-chat-typing-indicator");
      if (typing_indicator) typing_indicator.style.display = "none";
      this.queue_save();
    } catch (err) {
      console.error("Error in SmartCompletion.complete():", err);
    }
  }
  stream_handlers(stream_handlers = {}) {
    return {
      chunk: async (resp) => {
        this.data.completion.responses[0] = {
          timestamp: Date.now(),
          ...resp
        };
        await stream_handlers.chunk?.(this);
      },
      done: async (resp) => {
        this.data.completion.responses[0] = {
          timestamp: Date.now(),
          ...resp
        };
        await stream_handlers.done?.(this);
      },
      error: async (err) => {
        console.error("error", err);
        await stream_handlers.error?.(err);
      }
    };
  }
  /**
   * Access the completion adapters from the parent collection, if any.
   */
  get completion_adapters() {
    return this.collection?.completion_adapters || {};
  }
  /**
   * If a local chat_model config is present, creates a dedicated instance.
   * Otherwise, returns the collection-level chat_model or null.
   * @returns {Object|null}
   */
  get_chat_model() {
    if (this.chat_model) {
      return this.chat_model;
    } else {
      console.log("no chat_model, using collection chat_model");
      return this.collection?.chat_model || null;
    }
  }
  get response() {
    return this.data.completion.responses[0];
  }
  /**
   * @method response_text
   * @returns {string} The best guess at the main text from the model's first response.
   */
  get response_text() {
    const resp = this.data?.completion?.responses[0];
    if (!resp) return "";
    if (Array.isArray(resp.choices) && resp.choices[0]) {
      const choice = resp.choices[0];
      if (choice.message && choice.message.content) {
        return choice.message.content;
      }
      if (choice.text) return choice.text;
    }
    if (resp.text) return resp.text;
    return "";
  }
  get response_structured_output() {
    if (!this.response) return null;
    if (this.action_call) {
      try {
        const parsed2 = JSON.parse(this.action_call);
        return parsed2;
      } catch (e) {
        console.log("failed to parse tool_call in response_structured_output");
      }
    }
    if (!this.response_text) return null;
    const parsed = parse_xml_fragments(this.response_text);
    if (!parsed) return null;
    return parsed;
  }
  get action_call() {
    const resp = this.response;
    if (!resp) return null;
    return resp.choices?.[0]?.message?.tool_calls?.[0]?.function?.arguments;
  }
  get messages() {
    const messages = [];
    if (this.data.system_message) {
      messages.push({
        role: "system",
        content: this.data.system_message
      });
    }
    if (this.data.user_message) {
      messages.push({
        role: "user",
        content: this.data.user_message
      });
    }
    if (this.response_text) {
      messages.push({
        role: "assistant",
        content: this.response_text
      });
    }
    return messages;
  }
  get is_completed() {
    return this.data.completion.responses.length > 0;
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-collections/utils/ajson_merge.js
function ajson_merge(existing, new_obj) {
  if (new_obj === null) return null;
  if (new_obj === void 0) return existing;
  if (typeof new_obj !== "object") return new_obj;
  if (typeof existing !== "object" || existing === null) existing = {};
  const keys = Object.keys(new_obj);
  const length = keys.length;
  for (let i = 0; i < length; i++) {
    const key = keys[i];
    const new_val = new_obj[key];
    const existing_val = existing[key];
    if (Array.isArray(new_val)) {
      existing[key] = new_val.slice();
    } else if (is_object(new_val)) {
      existing[key] = ajson_merge(is_object(existing_val) ? existing_val : {}, new_val);
    } else if (new_val !== void 0) {
      existing[key] = new_val;
    }
  }
  return existing;
}
function is_object(obj) {
  return obj !== null && typeof obj === "object" && !Array.isArray(obj);
}

// node_modules/obsidian-smart-env/node_modules/smart-collections/adapters/ajson_single_file.js
var class_to_collection_key2 = {
  "SmartSource": "smart_sources",
  "SmartNote": "smart_sources",
  // DEPRECATED
  "SmartBlock": "smart_blocks",
  "SmartDirectory": "smart_directories"
};
function _parse_ajson_key(ajson_key) {
  let changed = false;
  let [collection_key, ...item_key] = ajson_key.split(":");
  if (class_to_collection_key2[collection_key]) {
    collection_key = class_to_collection_key2[collection_key];
    changed = true;
  }
  return {
    collection_key,
    item_key: item_key.join(":"),
    changed
  };
}
var AjsonSingleFileCollectionDataAdapter = class extends AjsonMultiFileCollectionDataAdapter {
  /**
   * Returns the single shared `.ajson` file path for this collection.
   * @param {string} [key] - (unused) Item key, ignored in single-file mode.
   * @returns {string} The single .ajson file path for the entire collection.
   */
  get_item_data_path(key) {
    const file_name = (this.collection?.collection_key || "collection") + ".ajson";
    const sep = this.fs?.sep || "/";
    const dir = this.collection.data_dir || "data";
    return [dir, file_name].join(sep);
  }
  /**
   * Override process_load_queue to parse the entire single-file .ajson once,
   * distributing final states to items.
   *
   * @async
   * @returns {Promise<void>}
   */
  async process_load_queue() {
    this.collection.show_process_notice("loading_collection");
    if (!await this.fs.exists(this.collection.data_dir)) {
      await this.fs.mkdir(this.collection.data_dir);
    }
    const path = this.get_item_data_path();
    if (!await this.fs.exists(path)) {
      for (const item of Object.values(this.collection.items)) {
        if (item._queue_load) {
          item.queue_import?.();
        }
      }
      this.collection.clear_process_notice("loading_collection");
      return;
    }
    const raw_data = await this.fs.read(path, "utf-8", { no_cache: true });
    if (!raw_data) {
      for (const item of Object.values(this.collection.items)) {
        if (item._queue_load) {
          item.queue_import?.();
        }
      }
      this.collection.clear_process_notice("loading_collection");
      return;
    }
    const { rewrite, file_data } = this.parse_single_file_ajson(raw_data);
    if (rewrite) {
      if (file_data.length) {
        await this.fs.write(path, file_data);
      } else {
        await this.fs.remove(path);
      }
    }
    for (const item of Object.values(this.collection.items)) {
      item._queue_load = false;
      item.loaded_at = Date.now();
    }
    this.collection.clear_process_notice("loading_collection");
  }
  /**
   * Helper to parse single-file .ajson content, distributing states to items.
   *
   * @param {string} raw
   * @returns {{ rewrite: boolean, file_data: string }}
   */
  parse_single_file_ajson(raw) {
    let rewrite = false;
    const lines = raw.trim().split("\n").filter(Boolean);
    let data_map = {};
    let line_count = 0;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line.endsWith(",")) {
        rewrite = true;
      }
      const trimmed = line.replace(/,$/, "");
      const combined = "{" + trimmed + "}";
      try {
        const obj = JSON.parse(combined);
        const [fullKey, value] = Object.entries(obj)[0];
        let { collection_key, item_key, changed } = _parse_ajson_key(fullKey);
        const newKey = `${collection_key}:${item_key}`;
        if (!value) {
          delete data_map[newKey];
          if (changed || newKey !== fullKey) {
            delete data_map[fullKey];
          }
          rewrite = true;
        } else {
          data_map[newKey] = value;
          if (changed || newKey !== fullKey) {
            delete data_map[fullKey];
            rewrite = true;
          }
        }
      } catch (err) {
        console.warn("parse error for line: ", line, err);
        rewrite = true;
      }
      line_count++;
    }
    for (const [ajson_key, val] of Object.entries(data_map)) {
      const [collection_key, ...rest] = ajson_key.split(":");
      const item_key = rest.join(":");
      const collection = this.collection.env[collection_key];
      if (!collection) continue;
      let item = collection.get(item_key);
      if (!item) {
        const ItemClass = collection.item_type;
        item = new ItemClass(this.env, val);
        collection.set(item);
      } else {
        item.data = ajson_merge(item.data, val);
      }
      item.loaded_at = Date.now();
      item._queue_load = false;
      if (!val.key) val.key = item_key;
    }
    if (line_count > Object.keys(data_map).length) {
      rewrite = true;
    }
    let minimal_lines = [];
    for (const [ajson_key, val] of Object.entries(data_map)) {
      minimal_lines.push(`${JSON.stringify(ajson_key)}: ${JSON.stringify(val)},`);
    }
    return {
      rewrite,
      file_data: minimal_lines.join("\n")
    };
  }
  /**
   * Override process_save_queue for single-file approach.
   * We'll simply call save_item for each queued item, which appends a line to the same `.ajson`.
   *
   * @async
   * @returns {Promise<void>}
   */
  async process_save_queue() {
    this.collection.show_process_notice("saving_collection");
    const save_queue = Object.values(this.collection.items).filter((item) => item._queue_save);
    const time_start = Date.now();
    const batch_size = 50;
    for (let i = 0; i < save_queue.length; i += batch_size) {
      const batch = save_queue.slice(i, i + batch_size);
      await Promise.all(batch.map((item) => {
        const adapter = this.create_item_adapter(item);
        return adapter.save().catch((err) => {
          console.warn(`Error saving item ${item.key}`, err);
          item.queue_save();
        });
      }));
    }
    const deleted_items = Object.values(this.collection.items).filter((item) => item.deleted);
    if (deleted_items.length) {
      deleted_items.forEach((item) => {
        delete this.collection.items[item.key];
      });
    }
    console.log(`Saved (single-file) ${this.collection.collection_key} in ${Date.now() - time_start}ms`);
    this.collection.clear_process_notice("saving_collection");
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-completions/utils/insert_user_message.js
function insert_user_message(request, user_message, opts = {}) {
  if (!user_message) return;
  const { position = "end", new_user_message = false } = opts;
  if (!request.messages) {
    request.messages = [];
  }
  const last_user_index = request.messages.findLastIndex((x) => x.role === "user");
  if (last_user_index === -1 || new_user_message) {
    const new_user_message2 = {
      role: "user",
      content: [{ type: "text", text: user_message }]
    };
    request.messages.push(new_user_message2);
    return;
  }
  const last_user_message = request.messages[last_user_index];
  if (!Array.isArray(last_user_message.content)) {
    last_user_message.content = [
      {
        type: "text",
        text: last_user_message.content
      }
    ];
  }
  if (position === "start") {
    last_user_message.content.unshift({
      type: "text",
      text: user_message
    });
  } else {
    last_user_message.content.push({
      type: "text",
      text: user_message
    });
  }
}

// node_modules/obsidian-smart-env/node_modules/smart-completions/adapters/_adapter.js
var SmartCompletionAdapter = class {
  constructor(item) {
    this.item = item;
  }
  get data() {
    return this.item.data;
  }
  get env() {
    return this.item.env;
  }
  get completion() {
    return this.data.completion;
  }
  get request() {
    return this.item.data.completion.request;
  }
  get response() {
    return this.item.response;
  }
  insert_user_message(user_message, opts = {}) {
    insert_user_message(this.request, user_message, opts);
  }
  // Override these methods in subclasses
  static get property_name() {
    return null;
  }
  /**
   * @returns {Promise<void>}
   */
  async to_request() {
  }
  /**
   * @returns {Promise<void>}
   */
  async from_response() {
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-completions/utils/insert_image.js
async function insert_image(request, image_path, fs) {
  const base64_image = await convert_image_to_base64(fs, image_path);
  if (!base64_image) return;
  const last_user_index = request.messages.findLastIndex((x) => x.role === "user");
  const image_content = {
    role: "user",
    content: [{ type: "image_url", image_url: { url: base64_image } }]
  };
  if (last_user_index === -1) {
    request.messages.unshift(image_content);
  }
  const last_user_message = request.messages[last_user_index];
  if (!last_user_message) return console.warn("insert_image: no last_user_message");
  if (!Array.isArray(last_user_message.content)) {
    last_user_message.content = [];
  }
  last_user_message.content.push(image_content.content[0]);
}
async function convert_image_to_base64(fs, image_path) {
  if (!image_path) return;
  const image_exts = ["png", "jpg", "jpeg", "gif", "webp", "svg", "bmp", "ico"];
  const ext = image_path.split(".").pop().toLowerCase();
  if (!image_exts.includes(ext)) return;
  try {
    const base64_data = await fs.read(image_path, "base64");
    const base64_url = `data:image/${ext};base64,${base64_data}`;
    return base64_url;
  } catch (err) {
    console.warn(`Failed to convert image ${image_path} to base64`, err);
  }
}

// node_modules/obsidian-smart-env/node_modules/smart-completions/utils/insert_pdf.js
async function insert_pdf(request, pdf_path, fs) {
  const base64_pdf = await convert_pdf_to_base64(fs, pdf_path);
  if (!base64_pdf) return;
  const last_user_index = request.messages.findLastIndex((x) => x.role === "user");
  const pdf_content = {
    role: "user",
    content: [{
      type: "file",
      file: {
        filename: pdf_path.split(/[\\/]/).pop(),
        file_data: `data:application/pdf;base64,${base64_pdf}`
        // <-- Prefix added
      }
    }]
  };
  if (last_user_index === -1) {
    request.messages.unshift(pdf_content);
    return;
  }
  const last_user_message = request.messages[last_user_index];
  if (!last_user_message) return console.warn("insert_pdf: no last_user_message");
  if (!Array.isArray(last_user_message.content)) {
    last_user_message.content = [];
  }
  last_user_message.content.push(pdf_content.content[0]);
}
async function convert_pdf_to_base64(fs, pdf_path) {
  if (!pdf_path) return;
  const ext = pdf_path.split(".").pop().toLowerCase();
  if (ext !== "pdf") return;
  try {
    const base64_data = await fs.read(pdf_path, "base64");
    return base64_data;
  } catch (err) {
    console.warn(`Failed to convert PDF ${pdf_path} to base64`, err);
  }
}

// node_modules/obsidian-smart-env/node_modules/smart-completions/adapters/context.js
var SmartCompletionContextAdapter = class extends SmartCompletionAdapter {
  static order = 10;
  static get property_name() {
    return "context_key";
  }
  async to_request() {
    const context_key = this.data.context_key;
    if (!context_key) return;
    const context_opts = this.data.context_opts;
    const context_collection = this.item.env.smart_contexts;
    if (!context_collection) {
      console.warn("No 'smart_contexts' collection found; skipping context adapter.");
      return;
    }
    const ctx_item = context_collection.get(context_key);
    if (!ctx_item) {
      console.warn(`SmartContext not found for key '${context_key}'`);
      return;
    }
    if (!ctx_item.has_context_items) {
      console.warn(`SmartContext '${context_key}' has no context items; skipping context adapter.`);
      return;
    }
    await ctx_item.save();
    let compiled;
    try {
      compiled = await ctx_item.compile(context_opts);
    } catch (err) {
      console.warn("Error compiling ephemeral context", err);
      return;
    }
    if (compiled.context) {
      this.insert_user_message(compiled.context);
      if (this.data.user_message) {
        this.insert_user_message(this.data.user_message, { position: "end" });
      }
    }
    if (compiled.images?.length > 0) {
      await this.insert_images(compiled.images);
    }
    if (compiled.pdfs?.length > 0) {
      await this.insert_pdfs(compiled.pdfs);
    }
  }
  async insert_images(image_paths) {
    if (!Array.isArray(image_paths) || !image_paths.length) return;
    for (const img_path of image_paths) {
      await insert_image(this.request, img_path, this.item.env.fs);
    }
  }
  async insert_pdfs(pdf_paths) {
    if (!Array.isArray(pdf_paths) || !pdf_paths.length) return;
    for (const pdf_path of pdf_paths) {
      await insert_pdf(this.request, pdf_path, this.item.env.fs);
    }
  }
  /**
   * No special post-processing after we get model response.
   */
  async from_response() {
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-completions/adapters/user.js
var SmartCompletionUserAdapter = class extends SmartCompletionAdapter {
  static order = 1;
  /**
   * @returns {string}
   */
  static get property_name() {
    return "user_message";
  }
  get request() {
    return this.item.data.completion.request;
  }
  /**
   * to_request: Checks `data.user`, adds a user message to `request.messages`.
   * @returns {Promise<void>}
   */
  async to_request() {
    const user_message = this.data.user_message;
    const new_user_message = this.data.new_user_message;
    this.insert_user_message(user_message, {
      position: "start",
      // always at start so that other adapters may add again to end (e.g. context adapter)
      new_user_message
    });
  }
  /**
   * from_response: No post-processing needed for default user message.
   * @returns {Promise<void>}
   */
  async from_response() {
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-completions/adapters/action.js
var ActionCompletionAdapter = class extends SmartCompletionAdapter {
  static get property_name() {
    return "action_key";
  }
  /**
   * @returns {Promise<void>}
   */
  async to_request() {
    const action_key = this.data.action_key;
    if (!action_key) return;
    const thread = this.item.thread;
    if (thread && thread.current_completion !== this.item) return console.log("ActionCompletionAdapter: skipping tools, not the current completion");
    const action_opts = this.data.action_opts;
    const action_collection = this.item.env.smart_actions;
    if (!action_collection) {
      console.warn("No 'smart_actions' collection found; skipping action adapter.");
      return;
    }
    const action_item = action_collection.get(action_key);
    if (!action_item) {
      console.warn(`SmartAction not found for key '${action_key}'`);
      return;
    }
    let tools;
    try {
      const tool2 = action_item.as_tool;
      tools = tool2 ? [tool2] : [];
    } catch (err) {
      console.warn("Error generating action tool", err);
      return;
    }
    if (!tools.length) return;
    if (!this.data.actions) this.data.actions = {};
    this.data.actions[action_key] = true;
    this.insert_tools(tools, { force: true });
  }
  get default_action_params() {
    return this.data.action_opts || {};
  }
  /**
   * @returns {Promise<void>}
   */
  async from_response() {
    console.log("ActionCompletionAdapter: from_response");
    const tool_call = this.response.choices[0].message?.tool_calls?.[0];
    if (!tool_call) return console.warn("No tool call found in response");
    const action_key = tool_call?.function?.name;
    const tool_arguments = tool_call?.function?.arguments;
    if (!action_key) return;
    const action_collection = this.item.env.smart_actions;
    if (!action_collection) return;
    const action_item = action_collection.get(action_key);
    if (!action_item) return;
    let parsed_args = tool_arguments;
    if (typeof parsed_args === "string") {
      try {
        parsed_args = JSON.parse(parsed_args);
      } catch (err) {
        console.warn("Could not parse tool_call arguments", err);
        return;
      }
    }
    const action_params = {
      ...this.default_action_params,
      ...parsed_args
    };
    const result = await action_item.run_action(action_params);
    if (result && typeof result === "object" && result.final) {
      if (!this.item.data.completion.responses[0]) {
        this.item.data.completion.responses[0] = { choices: [{ message: {} }] };
      } else if (!this.item.data.completion.responses[0].choices?.[0]) {
        this.item.data.completion.responses[0].choices = [{ message: {} }];
      }
      this.item.data.completion.responses[0].choices[0].message = {
        ...this.item.data.completion.responses[0].choices[0].message,
        role: "assistant",
        content: result.final
      };
    }
    if (!this.data.actions) this.data.actions = {};
    this.data.actions[action_key] = result;
  }
  /**
   * Insert the ephemeral tools into the request
   * @param {Array<object>} tools
   * @param {object} opts
   * @returns {void}
   */
  insert_tools(tools, opts = {}) {
    this.request.tools = tools;
    if (opts.force) {
      this.request.tool_choice = {
        type: "function",
        function: {
          name: tools[0].function.name
        }
      };
    }
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-completions/adapters/action_xml.js
function scaffold_xml(root_tag, root_desc, params) {
  return [
    `<${root_tag} instructions="${root_desc}">`,
    ...Object.entries(params).map(
      ([p, v]) => `  <${p} instructions="${v.description || ""}">VALUE</${p}>`
    ),
    `</${root_tag}>`
  ].join("\n");
}
function strip_instruction_attrs(xml) {
  return xml.replace(/\s+instructions="[^"]*"/g, "");
}
var ActionXmlCompletionAdapter = class extends ActionCompletionAdapter {
  static get property_name() {
    return "action_xml_key";
  }
  /* ────────────────────────────────────────────────────────────────────────
     REQUEST CONSTRUCTION
     ────────────────────────────────────────────────────────────────────── */
  async to_request() {
    const action_key = this.data.action_xml_key;
    if (!action_key) return;
    const thread = this.item.thread;
    if (thread.current_completion !== this.item) return console.log("ActionXmlCompletionAdapter: skipping tools, not the current completion");
    const action_item = this.env.smart_actions?.get(action_key);
    if (!action_item) {
      return console.warn(`SmartAction '${action_key}' not found`);
    }
    let tools;
    try {
      const tool2 = action_item.as_tool;
      tools = tool2 ? [tool2] : [];
    } catch (err) {
      return console.warn("Unable to compile OpenAPI \u2192 tools", err);
    }
    if (!tools.length) return;
    const func_def = tools[0].function;
    const param_props = func_def.parameters?.properties || {};
    const required_params = func_def.parameters?.required || [];
    this._func_name = func_def.name;
    this._required_params = required_params;
    const action_instruction = [
      "Important Instructions:",
      `1. You must invoke the action '${func_def.name}' exactly once.`,
      "2. You must respond *only* with XML in the exact structure provided below.",
      "3. Replace VALUE with real arguments based on the property-specific instructions below.",
      "4. Do not include any other text or instructions.",
      "5. Follow these property-specific instructions for producing the XML response.",
      "Action Instructions:",
      `- ${func_def.description || ""}`,
      "Property-Specific Instructions:",
      ...Object.entries(param_props).map(
        ([p, v]) => `- ${p}: ${v.description || ""}`
      )
    ].join("\n");
    const xml_scaffold = scaffold_xml(func_def.name, func_def.description, param_props);
    const xml_template = strip_instruction_attrs(xml_scaffold);
    const action_instruction_msg = [
      action_instruction,
      `You are ready to invoke the action '${func_def.name}'.`
    ].join("\n");
    const xml_template_msg = [
      `To invoke the action '${func_def.name}', respond *only* with XML in this exact structure (replace VALUE with real arguments based on the action and property-specific instructions above):`,
      xml_template
    ].join("\n");
    this.insert_user_message(action_instruction_msg);
    this.insert_user_message(xml_template_msg);
    this.data.actions ??= {};
    this.data.actions[action_key] = true;
    this.data.action_key = action_key;
  }
  /* ────────────────────────────────────────────────────────────────────────
     RESPONSE PARSING
     ────────────────────────────────────────────────────────────────────── */
  async from_response() {
    const action_key = this.data.action_xml_key;
    if (!action_key) return;
    const assistant_msg = this.response?.choices?.[0]?.message;
    if (!assistant_msg) {
      return console.warn("ActionXmlCompletionAdapter: assistant message not found");
    }
    const func_name = this._func_name || action_key;
    let parsed_xml = this.item?.response_structured_output;
    let root_node = parsed_xml[func_name];
    if (!root_node) {
      const candidate = Object.keys(parsed_xml)[0];
      console.warn(`ActionXmlCompletionAdapter: expected root <${func_name}>, found <${candidate}> \u2013 using candidate`);
      root_node = parsed_xml[candidate];
    }
    if (!root_node) {
      return console.warn(`ActionXmlCompletionAdapter: root tag '${func_name}' not found`);
    }
    const node_to_value = (node) => {
      if (!node || typeof node !== "object") return node;
      const { attributes = {}, contents } = node;
      if (contents === null || typeof contents !== "object") {
        return Object.keys(attributes).length ? { ...attributes, value: contents } : contents;
      }
      const out = {};
      for (const [k, v] of Object.entries(contents)) {
        out[k] = Array.isArray(v) ? v.map(node_to_value) : node_to_value(v);
      }
      return Object.keys(attributes).length ? { ...attributes, ...out } : out;
    };
    const args = node_to_value(root_node);
    const missing = (this._required_params || []).filter(
      (p) => args[p] === void 0 || args[p] === "" || args[p] === null
    );
    if (missing.length) {
      return console.warn(`ActionXmlCompletionAdapter: missing ${missing.join(", ")}`);
    }
    assistant_msg.tool_calls = [
      { function: { name: action_key, arguments: args } }
    ];
    delete assistant_msg.content;
    await super.from_response();
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-completions/adapters/system.js
var SmartCompletionSystemAdapter = class extends SmartCompletionAdapter {
  /**
   * Identifies the data property that triggers this adapter.
   * @returns {string}
   */
  static get property_name() {
    return "system_message";
  }
  /**
   * to_request: If `data.system_message` is present, prepends a system message to request.messages.
   * @returns {Promise<void>}
   */
  async to_request() {
    const sys_msg = this.data.system_message;
    if (!sys_msg) return;
    if (!this.request.messages) {
      this.request.messages = [];
    }
    this.request.messages.unshift({
      role: "system",
      content: sys_msg
    });
  }
  /**
   * from_response: No post-processing needed here.
   * @returns {Promise<void>}
   */
  async from_response() {
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-completions/index.js
var smart_completions_default_config = {
  class: SmartCompletions,
  data_adapter: AjsonSingleFileCollectionDataAdapter,
  item_type: SmartCompletion,
  completion_adapters: {
    // SmartCompletionTemplateAdapter,
    SmartCompletionContextAdapter,
    SmartCompletionUserAdapter,
    ActionCompletionAdapter,
    ActionXmlCompletionAdapter,
    SmartCompletionSystemAdapter
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-blocks/content_parsers/parse_blocks.js
function parse_blocks(source2, content) {
  let blocks_obj = parse_markdown_blocks(content);
  const last_read_at = source2.data.last_read?.at || Date.now();
  for (const [sub_key, line_range] of Object.entries(blocks_obj)) {
    const block_key = source2.key + sub_key;
    const existing_block = source2.block_collection.get(block_key);
    const block_content = get_line_range2(content, line_range[0], line_range[1]);
    if (existing_block && existing_block.lines[0] === line_range[0] && existing_block.lines[1] === line_range[1] && existing_block.size === block_content.length && existing_block.vec) {
      continue;
    }
    const block_outlinks = get_markdown_links(block_content);
    const block_data = {
      key: block_key,
      lines: line_range,
      size: block_content.length,
      outlinks: block_outlinks,
      last_read: {
        at: last_read_at,
        hash: murmur_hash_32_alphanumeric(block_content)
      }
    };
    if (!existing_block || existing_block?.data.last_read?.hash !== block_data.last_read.hash) {
      const new_item = new source2.block_collection.item_type(source2.env, block_data);
      source2.block_collection.set(new_item);
    } else {
      existing_block.data = {
        ...existing_block.data,
        ...block_data
        // overwrites lines, last_read
      };
    }
  }
  clean_and_update_source_blocks(source2, blocks_obj);
  for (const block of source2.blocks) {
    if (!block.vec) {
      block.queue_embed();
    }
  }
}
function clean_and_update_source_blocks(source2, blocks_obj) {
  const current_block_keys = new Set(Object.keys(blocks_obj).map((sk) => source2.key + sk));
  const blocks = source2.blocks;
  for (let i = 0; i < blocks.length; i++) {
    if (!current_block_keys.has(blocks[i].key)) {
      blocks[i].deleted = true;
      blocks[i].queue_save();
    }
  }
  source2.data.blocks = blocks_obj;
  source2.queue_save();
}

// node_modules/obsidian-smart-env/utils/format_collection_name.js
function format_collection_name(key) {
  return key.replace(/_/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
}

// node_modules/obsidian-smart-env/components/collection_settings.js
async function build_html3(collection, opts = {}) {
  const settings_html = Object.entries(collection.settings_config).map(([setting_key, setting_config]) => {
    if (!setting_config.setting) setting_config.setting = setting_key;
    return this.render_setting_html(setting_config);
  }).join("\n");
  const html = `<div><div class="collection-settings-container"><div class="source-settings collection-settings">
    <h2>${format_collection_name(collection.collection_key)}</h2>
    ${settings_html}
  </div></div></div>`;
  return html;
}
async function render5(collection, opts = {}) {
  const html = await build_html3.call(this, collection, opts);
  const frag = this.create_doc_fragment(html);
  await this.render_setting_components(frag, { scope: collection });
  if (opts.settings_container) {
    this.empty(opts.settings_container);
    opts.settings_container.appendChild(frag.querySelector(".collection-settings"));
  } else {
    collection.settings_container = frag.querySelector(".collection-settings-container");
  }
  return collection.settings_container;
}

// node_modules/obsidian-smart-env/modals/exclude_folders_fuzzy.js
var import_obsidian4 = require("obsidian");
var ExcludedFoldersFuzzy = class extends import_obsidian4.FuzzySuggestModal {
  /**
   * @param {App} app - The Obsidian app
   * @param {Object} env - An environment-like object, must have .settings and .fs.folder_paths
   */
  constructor(app2, env) {
    super(app2);
    this.env = env;
    this.setPlaceholder("Select a folder to exclude...");
  }
  open(callback) {
    this.callback = callback;
    super.open();
  }
  getItems() {
    return this.env.smart_sources?.fs?.folder_paths || [];
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item) {
    if (!item) return;
    const oldVal = this.env.settings.folder_exclusions || "";
    const splitted = oldVal.split(",").map((s) => s.trim()).filter(Boolean);
    if (!splitted.includes(item)) splitted.push(item);
    this.env.settings.folder_exclusions = splitted.join(",");
    this.callback?.();
  }
};

// node_modules/obsidian-smart-env/modals/excluded_sources.js
var import_obsidian5 = require("obsidian");
var ExcludedSourcesModal = class extends import_obsidian5.Modal {
  /**
   * @param {Object} app - Obsidian app
   * @param {Object} env - The environment instance
   */
  constructor(app2, env) {
    super(app2);
    this.env = env;
  }
  async onOpen() {
    this.titleEl.setText("Excluded Sources");
    this.contentEl.addClass("excluded-sources-modal");
    this.render_excluded_list();
  }
  async render_excluded_list() {
    this.contentEl.empty();
    const list_el = this.contentEl.createEl("ul");
    const excluded_file_paths = this.env.smart_sources.excluded_file_paths;
    for (const file_path of excluded_file_paths) {
      const li = list_el.createEl("li");
      li.setText(file_path);
    }
  }
};

// node_modules/obsidian-smart-env/modals/env_stats.js
var import_obsidian6 = require("obsidian");
var EnvStatsModal = class extends import_obsidian6.Modal {
  constructor(app2, env) {
    super(app2);
    this.env = env;
  }
  onOpen() {
    this.titleEl.setText("Smart Environment");
    this.contentEl.empty();
    this.contentEl.createEl("p", { text: "Loading stats..." });
    setTimeout(this.render.bind(this), 100);
  }
  async render() {
    const frag = await this.env.render_component("env_stats", this.env);
    this.contentEl.empty();
    if (frag) {
      this.contentEl.appendChild(frag);
    } else {
      this.contentEl.createEl("p", { text: "Failed to load stats." });
    }
  }
};

// node_modules/obsidian-smart-env/modals/exclude_files_fuzzy.js
var import_obsidian7 = require("obsidian");
var ExcludedFilesFuzzy = class extends import_obsidian7.FuzzySuggestModal {
  /**
   * @param {App} app - The Obsidian app
   * @param {Object} env - An environment-like object, must have .settings and .fs.file_paths
   */
  constructor(app2, env) {
    super(app2);
    this.env = env;
    this.setPlaceholder("Select a file to exclude...");
  }
  open(callback) {
    this.callback = callback;
    super.open();
  }
  getItems() {
    const fileExclusions = (this.env.settings.file_exclusions || "").split(",").map((s) => s.trim()).filter(Boolean);
    const candidates = (this.env.smart_sources?.fs?.file_paths || []).filter((path) => !fileExclusions.includes(path));
    return candidates;
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item) {
    if (!item) return;
    const oldVal = this.env.settings.file_exclusions || "";
    const splitted = oldVal.split(",").map((s) => s.trim()).filter(Boolean);
    if (!splitted.includes(item)) splitted.push(item);
    this.env.settings.file_exclusions = splitted.join(",");
    this.callback?.();
  }
};

// node_modules/obsidian-smart-env/components/env_settings.css
var css_sheet = new CSSStyleSheet();
css_sheet.replaceSync(`.sc-env-settings-container {
  margin: 1rem 0;
}

.sc-env-settings-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 0.5rem;
}

.toggle-env-settings-btn {
  cursor: pointer;
}

.smart-env-settings-header {
  margin-bottom: 1rem;
}

.excluded-folder-item,
.excluded-file-item {
  margin: 0.3rem 0;
}
`);
var env_settings_default = css_sheet;

// node_modules/obsidian-smart-env/components/env_settings.js
async function build_html4(env, opts = {}) {
  const env_settings_html = Object.entries(env.settings_config).map(([setting_key, setting_config]) => {
    if (setting_key === "file_exclusions" || setting_key === "folder_exclusions") return false;
    if (!setting_config.setting) setting_config.setting = setting_key;
    return this.render_setting_html(setting_config);
  }).filter(Boolean).join("\n");
  const add_excluded_folders_btn = `
    <button class="sc-add-excluded-folder-btn" type="button">Add excluded folder</button>
  `;
  const add_excluded_files_btn = `
    <button class="sc-add-excluded-file-btn" type="button">Add excluded file</button>
  `;
  const excluded_folders_list = `<div class="sc-excluded-folders-list"></div>`;
  const excluded_files_list = `<div class="sc-excluded-files-list"></div>`;
  return `
    <div class="sc-env-settings-container">
      <div class="sc-env-settings-header">
        <h2>Smart Environment</h2>
        <button type="button" class="toggle-env-settings-btn">Show environment settings</button>
      </div>
      <div class="sc-env-settings-body" style="display: none;">
        <div class="smart-env-settings-header" id="smart-env-buttons">
          <button class="sc-collection-stats-btn" type="button">Show stats</button>
          <button class="smart-env_reload-sources-btn" type="button">Reload sources</button>
          <button class="smart-env_clean-up-data-btn" type="button">Clean-up data</button>
          <button class="smart-env_clear-sources-data-btn" type="button">Clear sources data</button>
        </div>

        ${env_settings_html}

        <div class="smart-env-settings-header">
          <h2>Excluded folders</h2>
          ${add_excluded_folders_btn}
        </div>
        ${excluded_folders_list}

        <div class="smart-env-settings-header">
          <h2>Excluded files</h2>
          ${add_excluded_files_btn}
        </div>
        ${excluded_files_list}

        <button class="sc-excluded-sources-btn" type="button">Show excluded</button>

        <div data-smart-settings="smart_sources"></div>
        <div data-smart-settings="smart_blocks"></div>
        <p>Notes about embedding models:</p>
        <ul>
          <li>IMPORTANT: make sure local <code>BGE-micro-v2</code> embedding model works before trying other local models.</li>
          <li>API models require an API key and send your notes to third-party servers for processing.</li>
        </ul>
        <div data-smart-notices></div>
        <hr>
      </div>
      ${render_sign_in_or_open_smart_plugins(env)}
    </div>
  `;
}
async function render6(env, opts = {}) {
  const html = await build_html4.call(this, env, opts);
  const frag = this.create_doc_fragment(html);
  this.apply_style_sheet(env_settings_default);
  await this.render_setting_components(frag, { scope: env });
  env.settings_container = frag.querySelector(".sc-env-settings-container");
  const lean_coffee_callout = await env.render_component("lean_coffee_callout", env);
  env.settings_container.appendChild(lean_coffee_callout);
  post_process5.call(this, env, env.settings_container, opts);
  return frag;
}
async function post_process5(env, container, opts = {}) {
  const heading_btn = container.querySelector(".toggle-env-settings-btn");
  const body_el = container.querySelector(".sc-env-settings-body");
  if (heading_btn && body_el) {
    heading_btn.addEventListener("click", () => {
      const is_hidden = body_el.style.display === "none";
      body_el.style.display = is_hidden ? "block" : "none";
      heading_btn.textContent = is_hidden ? "Hide environment settings" : "Show environment settings";
    });
  }
  const muted_notices_frag = await env.render_component("muted_notices", env);
  await this.render_setting_components(muted_notices_frag, { scope: env });
  container.querySelector("[data-smart-notices]").appendChild(muted_notices_frag);
  const add_folder_btn = container.querySelector(".sc-add-excluded-folder-btn");
  if (add_folder_btn) {
    add_folder_btn.addEventListener("click", () => {
      const fuzzy = new ExcludedFoldersFuzzy(env.main.app, env);
      fuzzy.open(() => {
        render_excluded_dir_list(env, container);
        env.update_exclusions();
      });
    });
  }
  const add_file_btn = container.querySelector(".sc-add-excluded-file-btn");
  if (add_file_btn) {
    add_file_btn.addEventListener("click", () => {
      const fuzzy = new ExcludedFilesFuzzy(env.main.app, env);
      fuzzy.open(() => {
        render_excluded_file_list(env, container);
        env.update_exclusions();
      });
    });
  }
  const show_excluded_btn = container.querySelector(".sc-excluded-sources-btn");
  if (show_excluded_btn) {
    show_excluded_btn.addEventListener("click", () => {
      const modal = new ExcludedSourcesModal(env.main.app, env);
      modal.open();
    });
  }
  const show_stats_btn = container.querySelector(".sc-collection-stats-btn");
  if (show_stats_btn) {
    show_stats_btn.addEventListener("click", () => {
      const modal = new EnvStatsModal(env.main.app, env);
      modal.open();
    });
  }
  const reload_sources_btn = container.querySelector(".smart-env_reload-sources-btn");
  if (reload_sources_btn) {
    reload_sources_btn.addEventListener("click", async () => {
      const start = Date.now();
      env.smart_sources.unload();
      env.smart_blocks.unload();
      await env.init_collections();
      await env.load_collections();
      await env.smart_sources.process_embed_queue();
      const end = Date.now();
      env.main.notices?.show("reload_sources", { time_ms: end - start });
    });
  }
  const clean_up_data_btn = container.querySelector(".smart-env_clean-up-data-btn");
  if (clean_up_data_btn) {
    clean_up_data_btn.addEventListener("click", async () => {
      await env.smart_sources.run_clean_up_data();
    });
  }
  const smart_env_buttons = container.querySelector("#smart-env-buttons");
  const clear_sources_data_btn = smart_env_buttons.querySelector(".smart-env_clear-sources-data-btn");
  if (clear_sources_data_btn) {
    const inline_confirm_html = `
      <div class="sc-inline-confirm-row" style="display: none;">
        <span style="margin-right: 10px;">
          Are you sure you want to clear all sources data? This cannot be undone.
        </span>
        <span class="sc-inline-confirm-row-buttons">
          <button class="sc-inline-confirm-yes">Yes</button>
          <button class="sc-inline-confirm-cancel">Cancel</button>
        </span>
      </div>
    `;
    const inline_confirm_frag = this.create_doc_fragment(inline_confirm_html);
    smart_env_buttons.appendChild(inline_confirm_frag);
    const confirm_yes = smart_env_buttons.querySelector(".sc-inline-confirm-yes");
    const confirm_cancel = smart_env_buttons.querySelector(".sc-inline-confirm-cancel");
    clear_sources_data_btn.addEventListener("click", () => {
      const confirm_row = smart_env_buttons.querySelector(".sc-inline-confirm-row");
      confirm_row.style.display = "block";
      clear_sources_data_btn.style.display = "none";
    });
    confirm_yes.addEventListener("click", async (e) => {
      const confirm_row = e.target.closest(".sc-inline-confirm-row");
      await env.smart_sources.run_clear_all();
      confirm_row.style.display = "none";
      clear_sources_data_btn.style.display = "inline-block";
    });
    confirm_cancel.addEventListener("click", (e) => {
      const confirm_row = e.target.closest(".sc-inline-confirm-row");
      confirm_row.style.display = "none";
      clear_sources_data_btn.style.display = "inline-block";
    });
  }
  const env_collections_containers = container.querySelectorAll("[data-smart-settings]");
  for (const el of env_collections_containers) {
    const collection_key = el.dataset.smartSettings;
    const collection = env[collection_key];
    if (!collection) continue;
    const collection_settings_frag = await env.render_component("collection_settings", collection);
    el.appendChild(collection_settings_frag);
  }
  render_excluded_dir_list(env, container);
  render_excluded_file_list(env, container);
}
function render_excluded_dir_list(env, container) {
  const list_container = container.querySelector(".sc-excluded-folders-list");
  if (!list_container) return;
  list_container.empty();
  const ul = list_container.createEl("ul");
  const excluded_csv = env.settings.folder_exclusions || "";
  const arr = excluded_csv.split(",").map((s) => s.trim()).filter(Boolean);
  arr.forEach((folder) => {
    const li = ul.createEl("li", { cls: "excluded-folder-item" });
    li.setText(folder + "  ");
    const remove_btn = li.createEl("button", { text: "(x)", cls: "remove-folder-btn" });
    remove_btn.addEventListener("click", () => {
      const splitted = excluded_csv.split(",").map((x) => x.trim()).filter(Boolean);
      const new_arr = splitted.filter((f) => f !== folder);
      env.settings.folder_exclusions = new_arr.join(",");
      render_excluded_dir_list(env, container);
    });
  });
  if (!arr.length) {
    ul.createEl("li", { text: "No folders excluded yet." });
  }
}
function render_excluded_file_list(env, container) {
  const list_container = container.querySelector(".sc-excluded-files-list");
  if (!list_container) return;
  list_container.empty();
  const ul = list_container.createEl("ul");
  const excluded_csv = env.settings.file_exclusions || "";
  const arr = excluded_csv.split(",").map((s) => s.trim()).filter(Boolean);
  arr.forEach((file_path) => {
    const li = ul.createEl("li", { cls: "excluded-file-item" });
    li.setText(file_path + "  ");
    const remove_btn = li.createEl("button", { text: "(x)", cls: "remove-file-btn" });
    remove_btn.addEventListener("click", () => {
      const splitted = excluded_csv.split(",").map((s) => s.trim()).filter(Boolean);
      const new_arr = splitted.filter((f) => f !== file_path);
      env.settings.file_exclusions = new_arr.join(",");
      render_excluded_file_list(env, container);
    });
  });
  if (!arr.length) {
    ul.createEl("li", { text: "No files excluded yet." });
  }
}
function render_sign_in_or_open_smart_plugins(env) {
  const oauth_storage_prefix = env.plugin.app.vault.getName().toLowerCase().replace(/[^a-z0-9]/g, "_") + "_smart_plugins_oauth_";
  const isLoggedIn = !!localStorage.getItem(oauth_storage_prefix + "token");
  const buttonLabel = isLoggedIn ? "Open Smart Plugins" : "Sign in";
  const buttonCallback = isLoggedIn ? "open_smart_plugins_settings" : "initiate_smart_plugins_oauth";
  return `
    <div class="setting-component"
      data-name="Smart Plugins - Early Access"
      data-type="button"
      data-btn-text="${buttonLabel}"
      data-description="Supporters can sign in to access early-release Smart Plugins"
      data-callback="${buttonCallback}"
    ></div>
  `;
}

// node_modules/obsidian-smart-env/components/env_stats.js
async function build_html5(env, opts = {}) {
  const lines = [];
  lines.push(`<h2>Collections</h2>`);
  const collection_keys = Object.keys(env.collections).sort((a, b) => {
    if (a === "smart_sources" || a === "smart_blocks") return -1;
    if (b === "smart_sources" || b === "smart_blocks") return 1;
    return a.localeCompare(b);
  });
  for (const collection_key of collection_keys) {
    const collection = env[collection_key];
    if (!collection || !collection.items) {
      lines.push(`
        <div class="sc-collection-stats">
          <h3>${format_collection_name(collection_key)}</h3>
          <p>No valid items.</p>
        </div>
      `);
      continue;
    }
    const snippet = generate_collection_stats(collection, collection_key);
    lines.push(snippet);
  }
  return `
    <div class="sc-env-stats-container">
      ${lines.join("\n")}
    </div>
  `;
}
async function render7(env, opts = {}) {
  const html = await build_html5.call(this, env, opts);
  const frag = this.create_doc_fragment(html);
  return await post_process6.call(this, env, frag, opts);
}
async function post_process6(env, frag, opts = {}) {
  return frag;
}
function generate_collection_stats(collection, collectionKey) {
  const total_items = Object.values(collection.items).length;
  const niceName = format_collection_name(collectionKey);
  const state = collection.env.collections[collectionKey];
  if (state !== "loaded") {
    return `
      <div class="sc-collection-stats">
        <h3>${niceName}</h3>
        <p>Not loaded yet (${total_items} items known).</p>
      </div>
    `;
  }
  const load_time_html = collection.load_time_ms ? `<span>Load time: ${collection.load_time_ms}ms</span>` : "";
  const state_html = `<span>State: ${state}</span>`;
  let html = "";
  if (collectionKey === "smart_sources") {
    html = get_smart_sources_stats(collection, niceName, total_items);
  } else {
    html = get_generic_collection_stats(collection, niceName, total_items);
  }
  let embed_stats = "";
  if (typeof collection.process_embed_queue === "function") {
    embed_stats = calculate_embed_coverage(collection, total_items);
  }
  return `
    <div class="sc-collection-stats">
      <h3>${niceName}</h3>
      ${embed_stats}
      ${html}
      ${load_time_html}
      ${state_html}
    </div>
  `;
}
function get_smart_sources_stats(collection, niceName, total_items, load_time_html) {
  const totalFiles = collection.total_files ?? total_items;
  const included = collection.included_files ?? "Error calculating included files";
  const excluded = totalFiles - included;
  return `
      <p><strong>Total Files:</strong> ${totalFiles}</p>
      <p><strong>Excluded:</strong> ${excluded}</p>
      <p><strong>Included:</strong> ${included}</p>
  `;
}
function get_generic_collection_stats(collection, niceName, total_items, load_time_html) {
  return `
      <p><strong>Total:</strong> ${total_items}</p>
  `;
}
function calculate_embed_coverage(collection, total_items) {
  const embedded_items = Object.values(collection.items).filter((item) => item.vec);
  if (!embedded_items.length) return "<p>No items embedded</p>";
  const is_unembedded = Object.values(collection.items).filter((i) => i.should_embed && i.is_unembedded);
  const pct = embedded_items.length / total_items * 100;
  const percent = Math.round(pct);
  const display = `${percent}% (${embedded_items.length} / ${total_items})`;
  return `<p><strong>Embedding coverage:</strong> ${display}</p>` + (is_unembedded.length ? `<p><strong>Unembedded:</strong> ${is_unembedded.length}</p>` : "");
}

// node_modules/obsidian-smart-env/components/lean_coffee_callout.js
var import_obsidian8 = require("obsidian");
function build_html6(env, opts = {}) {
  return `<div class="wrapper">
    <div id="lean-coffee-callout" data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout" style="mix-blend-mode: unset;">
      <div class="callout-title" style="align-items: center;">
        <div class="callout-icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M12 16v-4"></path>
            <path d="M12 8h.01"></path>
          </svg>
        </div>
        <div class="callout-title-inner">
          <strong>Community Lean Coffee</strong>
        </div>
      </div>
      <div class="callout-content">
        <p dir="auto">
          <span>Ask questions. Bring challenges. Request features. Show workflows. Be ready to share.</span>
          <br>
          <i>Join the next <a href="https://lu.ma/calendar/cal-ZJtdnzAdURyouM7" target="_external">Community Lean Coffee</a> meeting.</i> Unable to attend? Submit a question <a href="https://docs.google.com/forms/d/e/1FAIpQLSdqOtTjksMwg1BOuGNCncpMQ_QT-wcd-3AgZGIe3A_isut5aQ/viewform?usp=dialog" target="_external">here</a> \u{1F334}
        </p>
      </div>
    </div>
  </div>`;
}
function render8(env, opts = {}) {
  const html = build_html6.call(this, env, opts);
  const frag = this.create_doc_fragment(html);
  const callout = frag.querySelector("#lean-coffee-callout");
  const icon_container = callout.querySelector(".callout-icon");
  const icon = (0, import_obsidian8.getIcon)("smart-chat");
  if (icon) {
    this.empty(icon_container);
    icon_container.appendChild(icon);
  }
  post_process7.call(this, env, callout, opts);
  return callout;
}
function post_process7(env, callout) {
}

// node_modules/obsidian-smart-env/components/muted_notices.js
async function build_html7(env, opts = {}) {
  let html = `<div class="muted-notice-container" style="display: flex; flex-direction: column; gap: 10px;">
    <h2>Muted notices</h2>
  `;
  if (Object.keys(env.notices.settings?.muted || {}).length) {
    for (const notice in env.notices.settings?.muted) {
      html += `<div class="muted-notice" data-notice="${notice}" style="display: flex; align-items: center; justify-content: space-between; gap: 10px;">
        <span>${notice}</span>
        <button class="unmute-button">Remove</button>
      </div>`;
    }
  } else {
    html += `<p>No muted notices.</p>`;
  }
  html += `</div>`;
  return html;
}
async function render9(env, opts = {}) {
  let html = await build_html7.call(this, env, opts);
  const frag = this.create_doc_fragment(html);
  post_process8.call(this, env, frag, opts);
  return frag;
}
async function post_process8(env, frag, opts = {}) {
  const unmute_buttons = frag.querySelectorAll(".unmute-button");
  unmute_buttons.forEach((button) => {
    button.addEventListener("click", () => {
      const notice = button.parentElement.dataset.notice;
      env.notices.settings.muted[notice] = false;
      delete env.notices.settings.muted[notice];
      button.parentElement.remove();
    });
  });
}

// node_modules/obsidian-smart-env/components/source_inspector.css
var css_sheet2 = new CSSStyleSheet();
css_sheet2.replaceSync(`.source-inspector {
  background-color: var(--background-secondary-alt);
  margin: var(--size-4-3) 0;
  padding: var(--size-4-3);
  border-radius: var(--radius-m);
}

.source-inspector-blocks-container {
  margin-top: var(--size-4-2);
  display: flex;
  flex-direction: column;
  gap: var(--size-4-3);
}

.source-inspector-blocks-container blockquote {
  margin-left: var(--size-4-3);
  padding-left: var(--size-4-3);
  border-left: 2px solid var(--text-faint);
}
`);
var source_inspector_default = css_sheet2;

// node_modules/obsidian-smart-env/components/source_inspector.js
function build_html8(source2, opts = {}) {
  return `<div>
    <div class="source-inspector-source-info">
      <button class="source-inspector-show-data-btn" type="button">Show source data</button>
      <div class="source-inspector-source-data" style="display:none; margin: 0.5em 0;">
        <pre style="max-height:300px; overflow:auto; background:#222; color:#fff; padding:0.5em; border-radius:4px;"></pre>
      </div>
    </div>
    <div class="smart-chat-message source-inspector">
      <h2>Blocks</h2>
      <div class="source-inspector-blocks-container"></div>
    </div>
  </div>`;
}
async function render10(source2, opts = {}) {
  const html = build_html8(source2, opts);
  const frag = this.create_doc_fragment(html);
  this.apply_style_sheet(source_inspector_default);
  await post_process9.call(this, source2, frag, opts);
  return frag;
}
async function post_process9(source2, frag, opts = {}) {
  const container = frag.querySelector(".source-inspector .source-inspector-blocks-container");
  if (!container) return frag;
  const source_info = frag.querySelector(".source-inspector-source-info");
  const btn = frag.querySelector(".source-inspector-show-data-btn");
  const data_div = frag.querySelector(".source-inspector-source-data");
  const pre = data_div?.querySelector("pre");
  if (btn && data_div && pre) {
    btn.addEventListener("click", () => {
      if (data_div.style.display === "none") {
        pre.textContent = JSON.stringify(source2.data, null, 2);
        data_div.style.display = "";
        btn.textContent = "Hide source data";
      } else {
        data_div.style.display = "none";
        btn.textContent = "Show source data";
      }
    });
  }
  const source_should_embed = source2.should_embed ? `<span style="color: green;">should embed</span>` : `<span style="color: orange;">embedding skipped</span>`;
  const source_embed_status = source2.vec ? `<span style="color: green;">vectorized</span>` : `<span style="color: orange;">not vectorized</span>`;
  const source_info_frag = this.create_doc_fragment(`<p>${source_should_embed} | ${source_embed_status}</p>`);
  source_info.appendChild(source_info_frag);
  if (!source2 || !source2.blocks || source2.blocks.length === 0) {
    this.safe_inner_html(container, `<p>No blocks</p>`);
    return frag;
  }
  const sorted_blocks = source2.blocks.sort((a, b) => a.line_start - b.line_start);
  for (const block of sorted_blocks) {
    const sub_key_display = block.sub_key.split("#").join(" > ");
    const block_info = `${sub_key_display} (${block.size} chars; lines: ${block.line_start}-${block.line_end})`;
    const should_embed = block.should_embed ? `<span style="color: green;">should embed</span>` : `<span style="color: orange;">embedding skipped</span>`;
    const embed_status = block.vec ? `<span style="color: green;">vectorized</span>` : `<span style="color: orange;">not vectorized</span>`;
    let block_content = "";
    try {
      const raw = await block.read();
      block_content = raw.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;");
    } catch (err) {
      console.error("[source_inspector] Error reading block:", err);
      block_content = `<em style="color:red;">Error reading block content</em>`;
    }
    const block_frag = this.create_doc_fragment(`
      <p>
        ${block_info}<br>
        ${should_embed} | ${embed_status}
      </p>
      <blockquote>${block_content}</blockquote>
      <hr>
    `);
    container.appendChild(block_frag);
  }
  return frag;
}

// node_modules/obsidian-smart-env/components/supporter_callout.js
var import_obsidian9 = require("obsidian");
function build_html9(plugin, opts = {}) {
  const { plugin_name = plugin.manifest.name } = opts;
  return `<div class="wrapper">
    <div id="footer-callout" data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout" style="mix-blend-mode: unset;">
      <div class="callout-title" style="align-items: center;">
        <div class="callout-icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M12 16v-4"></path>
            <path d="M12 8h.01"></path>
          </svg>
        </div>
        <div class="callout-title-inner"><strong>Become a Supporter</strong></div>
      </div>
      <div class="callout-content">
        <p>Try early &amp; experimental features:
          <ul>
            <li><b>Smart Connections Early Release:</b>
              <ul>
                <li>Inline block connections</li>
                <li>Footer connections view</li>
                <li>Connections re-ranking</li>
              </ul>
            </li>
            <li><b>Smart Context Early Release:</b>
              <ul>
                <li>Named contexts</li>
                <li>External sources: include code from external repositories</li>
                <li>Context codeblocks: embed context in notes ("My most valuable workflow" - \u{1F334} Brian)</li>
              </ul>
            </li>
            <li><b>Smart Editor:</b>
              <ul>
                <li>Generate &amp; review changes</li>
              </ul>
            </li>
            <li><em>Be the first to know what's coming next!</em></li>
          </ul>
        </p>
        <p>Access the Supporter Community Campfire Chat:
          <ul>
            <li>Supporter-only private discussions</li>
            <li>Share workflows</li>
            <li>Get priority help &amp; support</li>
          </ul>
        </p>
        <p>Guaranteed seat in the Community Lean Coffee meetings.</p>
        <p><i>Your support shapes the future of ${plugin_name}.</i></p>
        <p>
          <strong>Fuel the circle of empowerment.</strong> <a href="https://smartconnections.app/community-supporters?utm_source=obsidian-${plugin_name.replace(/[^a-zA-Z0-9]/g, "-").toLowerCase()}" class="button" target="_external">Become a Supporter</a>
        </p>
      </div>
    </div>
  </div>`;
}
function render11(plugin, opts = {}) {
  const html = build_html9.call(this, plugin, opts);
  const frag = this.create_doc_fragment(html);
  const callout = frag.querySelector("#footer-callout");
  const icon_container = callout.querySelector(".callout-icon");
  const icon = (0, import_obsidian9.getIcon)("hand-heart");
  if (icon) {
    this.empty(icon_container);
    icon_container.appendChild(icon);
  }
  post_process10.call(this, plugin, callout, opts);
  return callout;
}
function post_process10(plugin, callout) {
}

// node_modules/obsidian-smart-env/components/user_agreement_callout.js
var import_obsidian10 = require("obsidian");
function build_html10(plugin, opts = {}) {
  const { plugin_name = plugin.manifest.name } = opts;
  return `<div class="wrapper">
    <div id="footer-callout" data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout" style="mix-blend-mode: unset;">
      <div class="callout-title" style="align-items: center;">
        <div class="callout-icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M12 16v-4"></path>
            <path d="M12 8h.01"></path>
          </svg>
        </div>
        <div class="callout-title-inner"><strong>User Agreement</strong></div>
      </div>
      <div class="callout-content">
        <p>By using ${plugin_name} you agree to share how it helps you with at least one other person \u{1F60A}\u{1F334}</p>
      </div>
    </div>
  </div>`;
}
function render12(plugin, opts = {}) {
  const html = build_html10.call(this, plugin, opts);
  const frag = this.create_doc_fragment(html);
  const callout = frag.querySelector("#footer-callout");
  const icon_container = callout.querySelector(".callout-icon");
  const icon = (0, import_obsidian10.getIcon)("smart-connections");
  if (icon) {
    this.empty(icon_container);
    icon_container.appendChild(icon);
  }
  post_process11.call(this, plugin, callout, opts);
  return callout;
}
function post_process11(plugin, callout) {
}

// node_modules/obsidian-smart-env/smart_env.config.js
var smart_env_config = {
  collections: {},
  item_types: {},
  components: {
    collection_settings: render5,
    env_settings: render6,
    env_stats: render7,
    lean_coffee_callout: render8,
    muted_notices: render9,
    source_inspector: render10,
    supporter_callout: render11,
    user_agreement_callout: render12
  }
};

// node_modules/obsidian-smart-env/default.config.js
var smart_env_config2 = {
  env_path: "",
  modules: {
    smart_fs: {
      class: SmartFs,
      adapter: SmartFsObsidianAdapter
    },
    smart_view: {
      class: SmartView,
      adapter: SmartViewObsidianAdapter
    },
    // smart_notices: {
    //   class: SmartNotices,
    //   adapter: Notice,
    // },
    smart_embed_model: {
      class: SmartEmbedModel,
      adapters: {
        transformers: SmartEmbedTransformersIframeAdapter,
        openai: SmartEmbedOpenAIAdapter,
        ollama: SmartEmbedOllamaAdapter
      }
    },
    smart_chat_model: {
      class: SmartChatModel,
      // DEPRECATED FORMAT: will be changed (requires SmartModel adapters getters update)
      adapters: {
        anthropic: SmartChatModelAnthropicAdapter,
        azure: SmartChatModelAzureAdapter,
        custom: SmartChatModelCustomAdapter,
        gemini: SmartChatModelGeminiAdapter,
        groq: SmartChatModelGroqAdapter,
        lm_studio: SmartChatModelLmStudioAdapter,
        ollama: SmartChatModelOllamaAdapter,
        open_router: SmartChatModelOpenRouterAdapter,
        openai: SmartChatModelOpenaiAdapter,
        xai: SmartChatModelXaiAdapter
      },
      http_adapter: new SmartHttpRequest({
        adapter: SmartHttpObsidianRequestAdapter,
        obsidian_request_url: import_obsidian13.requestUrl
      })
    }
  },
  collections: {
    smart_sources: {
      collection_key: "smart_sources",
      class: SmartSources,
      data_adapter: AjsonMultiFileSourcesDataAdapter,
      source_adapters: {
        "md": ObsidianMarkdownSourceContentAdapter,
        "txt": ObsidianMarkdownSourceContentAdapter,
        "excalidraw.md": ExcalidrawSourceContentAdapter
        // "canvas": MarkdownSourceContentAdapter,
        // "default": MarkdownSourceContentAdapter,
      },
      content_parsers: [
        parse_blocks
      ],
      // process_embed_queue: false,
      process_embed_queue: true
      // trigger embedding on load
    },
    smart_blocks: {
      collection_key: "smart_blocks",
      class: SmartBlocks,
      data_adapter: AjsonMultiFileBlocksDataAdapter,
      block_adapters: {
        "md": MarkdownBlockContentAdapter,
        "txt": MarkdownBlockContentAdapter,
        "excalidraw.md": MarkdownBlockContentAdapter
        // "canvas": MarkdownBlockContentAdapter,
      }
    },
    smart_completions: smart_completions_default_config
  },
  item_types: {
    SmartSource,
    SmartBlock,
    SmartCompletion
  },
  items: {
    smart_source: smart_source_default,
    smart_block: smart_block_default
  },
  components: {
    smart_blocks: {
      settings: render3
    },
    smart_embed_model: {
      settings: render4
    }
  },
  default_settings: {
    is_obsidian_vault: true,
    smart_blocks: {
      embed_blocks: true,
      min_chars: 200
    },
    smart_sources: {
      min_chars: 200,
      embed_model: {
        adapter: "transformers",
        transformers: {
          legacy_transformers: false,
          model_key: "TaylorAI/bge-micro-v2"
        }
      }
    },
    excluded_headings: "",
    file_exclusions: "Untitled",
    folder_exclusions: "",
    language: "en",
    new_user: true,
    // DEPRECATED: 2025-06-05 (use localStorage instead)
    re_import_wait_time: 13,
    smart_chat_threads: {
      chat_model: {
        adapter: "ollama",
        ollama: {}
      }
    },
    smart_notices: {},
    smart_view_filter: {
      expanded_view: false,
      render_markdown: true,
      show_full_path: false
    },
    version: ""
  }
};
merge_env_config(smart_env_config2, smart_env_config);
var default_config_default = smart_env_config2;

// node_modules/obsidian-smart-env/utils/add_icons.js
var import_obsidian14 = require("obsidian");
function add_smart_chat_icon() {
  (0, import_obsidian14.addIcon)("smart-chat", `<defs>
  <symbol id="smart-chat-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
    <path d="M2 4c0-1.1.9-2 2-2h16c1.1 0 2 .9 2 2v11c0 1.1-.9 2-2 2h-8l-5 4v-4H4c-1.1 0-2-.9-2-2Z" stroke-width="2"></path>
    <path d="M7 8c.5.3 1.3.3 1.8 0" stroke-width="2"></path>
    <path d="M15.2 8c.5.3 1.3.3 1.8 0" stroke-width="2"></path>
    <path d="M8 11.5c1 .8 2.5 1.2 4 1.2s3-.4 4-1.2" stroke-width="2"></path>
  </symbol>
</defs>
<use href="#smart-chat-icon" />`);
}
function add_smart_connections_icon() {
  (0, import_obsidian14.addIcon)("smart-connections", `<path d="M50,20 L80,40 L80,60 L50,100" stroke="currentColor" stroke-width="4" fill="none"/>
    <path d="M30,50 L55,70" stroke="currentColor" stroke-width="5" fill="none"/>
    <circle cx="50" cy="20" r="9" fill="currentColor"/>
    <circle cx="80" cy="40" r="9" fill="currentColor"/>
    <circle cx="80" cy="70" r="9" fill="currentColor"/>
    <circle cx="50" cy="100" r="9" fill="currentColor"/>
    <circle cx="30" cy="50" r="9" fill="currentColor"/>`);
}

// node_modules/obsidian-smart-env/node_modules/smart-notices/smart_notices.js
var import_obsidian15 = require("obsidian");

// node_modules/obsidian-smart-env/node_modules/smart-notices/notices.js
var NOTICES = {
  item_excluded: {
    en: "Cannot show Smart Connections for excluded entity: {{entity_key}}"
  },
  load_env: {
    en: "Mobile detected: to prevent performance issues, click to load Smart Environment when ready.",
    button: {
      en: `Load Smart Env`,
      callback: (env) => {
        env.load(true);
      }
    },
    timeout: 1e4
  },
  /** @deprecated in favor of in-component insctructions (2025-06-22) */
  missing_entity: {
    en: "No entity found for key: {{key}}"
  },
  notice_muted: {
    en: "Notice muted"
  },
  new_version_available: {
    en: "A new version is available! (v{{version}})",
    timeout: 15e3,
    button: {
      en: "Release notes",
      callback: (scope) => {
        window.open("https://github.com/brianpetro/obsidian-smart-connections/releases", "_blank");
      }
    }
  },
  new_early_access_version_available: {
    en: "A new early access version is available! (v{{version}})"
  },
  supporter_key_required: {
    en: "Supporter license key required for early access update"
  },
  revert_to_stable_release: {
    en: 'Click "Check for Updates" in the community plugins tab and complete the update for Smart Connections to finish reverting to the stable release.',
    timeout: 0
  },
  action_installed: {
    en: 'Installed action "{{name}}"'
  },
  action_install_error: {
    en: 'Error installing action "{{name}}": {{error}}',
    timeout: 0
  },
  embed_model_not_loaded: {
    en: "Embed model not loaded. Please wait for the model to load and try again."
  },
  embed_search_text_failed: {
    en: "Failed to embed search text."
  },
  error_in_embedding_search: {
    en: "Error in embedding search. See console for details."
  },
  copied_to_clipboard: {
    en: "Message: {{content}} copied successfully."
  },
  copy_failed: {
    en: "Unable to copy message to clipboard."
  },
  copied_chatgpt_url_to_clipboard: {
    en: "ChatGPT URL copied to clipboard."
  },
  loading_collection: {
    en: "Loading {{collection_key}}..."
  },
  done_loading_collection: {
    en: "{{collection_key}} loaded."
  },
  saving_collection: {
    en: "Saving {{collection_key}}..."
  },
  initial_scan: {
    en: "[{{collection_key}}] Starting initial scan...",
    timeout: 0
  },
  done_initial_scan: {
    en: "[{{collection_key}}] Initial scan complete.",
    timeout: 3e3
  },
  pruning_collection: {
    en: "Pruning {{collection_key}}..."
  },
  done_pruning_collection: {
    en: "Pruned {{count}} items from {{collection_key}}."
  },
  embedding_progress: {
    en: "Embedding progress: {{progress}} / {{total}}\n{{tokens_per_second}} tokens/sec using {{model_name}}",
    button: {
      en: "Pause",
      callback: (env) => {
        console.log("pausing");
        env.smart_sources.entities_vector_adapter.halt_embed_queue_processing();
      }
    },
    timeout: 0
  },
  embedding_complete: {
    en: "Embedding complete. {{total_embeddings}} embeddings created. {{tokens_per_second}} tokens/sec using {{model_name}}",
    timeout: 0
  },
  embedding_paused: {
    en: "Embedding paused. Progress: {{progress}} / {{total}}\n{{tokens_per_second}} tokens/sec using {{model_name}}",
    button: {
      en: "Resume",
      callback: (env) => {
        env.smart_sources.entities_vector_adapter.resume_embed_queue_processing(100);
      }
    },
    timeout: 0
  },
  embedding_error: {
    en: "Error embedding: {{error}}",
    timeout: 0
  },
  import_progress: {
    en: "Importing... {{progress}} / {{total}} sources",
    timeout: 0
  },
  done_import: {
    en: "Import complete. {{count}} sources imported in {{time_in_seconds}}s",
    timeout: 0
  },
  no_import_queue: {
    en: "No items in import queue"
  },
  clearing_all: {
    en: "Clearing all data...",
    timeout: 0
  },
  done_clearing_all: {
    en: "All data cleared and reimported",
    timeout: 3e3
  },
  image_extracting: {
    en: "Extracting text from Image(s)",
    timeout: 0
  },
  pdf_extracting: {
    en: "Extracting text from PDF(s)",
    timeout: 0
  },
  insufficient_settings: {
    en: "Insufficient settings for {{key}}, missing: {{missing}}",
    timeout: 0
  },
  unable_to_init_source: {
    en: "Unable to initialize source: {{key}}",
    timeout: 0
  },
  reload_sources: {
    en: "Reloaded sources in {{time_ms}}ms"
  }
};

// node_modules/obsidian-smart-env/node_modules/smart-notices/smart_notices.js
function define_default_create_methods(notices) {
  for (const key of Object.keys(notices)) {
    const notice_obj = notices[key];
    if (typeof notice_obj.create !== "function") {
      notice_obj.create = function(opts = {}) {
        let text = this.en ?? key;
        for (const [k, v] of Object.entries(opts)) {
          text = text.replace(new RegExp(`{{${k}}}`, "g"), String(v));
        }
        let button;
        if (!opts.button && this.button) {
          const btn_label = typeof this.button.en === "string" ? this.button.en : "OK";
          button = {
            text: btn_label,
            callback: typeof this.button.callback === "function" ? this.button.callback : () => {
            }
            // no-op
          };
        } else {
          button = opts.button;
        }
        let final_timeout = opts.timeout ?? this.timeout ?? 5e3;
        return {
          text,
          button,
          timeout: final_timeout,
          confirm: opts.confirm,
          // pass any user-provided confirm
          immutable: opts.immutable
          // pass any user-provided immutable
        };
      };
    }
  }
  return notices;
}
var SmartNotices = class {
  /**
   * @param {Object} scope - The main plugin instance
   */
  constructor(env, opts = {}) {
    env?.create_env_getter(this);
    this.active = {};
    this.adapter = opts.adapter || this.env.config.modules.smart_notices.adapter;
    define_default_create_methods(NOTICES);
  }
  /** plugin settings for notices (muted, etc.) */
  get settings() {
    if (!this.env?.settings?.smart_notices) {
      this.env.settings.smart_notices = {};
    }
    if (!this.env?.settings?.smart_notices?.muted) {
      this.env.settings.smart_notices.muted = {};
    }
    return this.env?.settings?.smart_notices;
  }
  /**
   * Displays a notice by key or custom message.
   * Usage:
   *   notices.show('load_env', { scope: this });
   *
   * @param {string} id - The notice key or custom ID
   * @param {object} opts - Additional user opts
   */
  show(id, opts = {}) {
    let message = null;
    if (typeof opts === "string") {
      message = opts;
    } else {
      opts = opts || {};
    }
    const normalized_id = this._normalize_notice_key(id);
    if (this.settings?.muted?.[normalized_id]) {
      if (opts.confirm?.callback) {
        opts.confirm.callback();
      }
      return;
    }
    const notice_entry = NOTICES[id];
    let derived = {
      text: message || id,
      timeout: opts.timeout ?? 5e3,
      button: opts.button,
      immutable: opts.immutable,
      confirm: opts.confirm
    };
    if (notice_entry?.create) {
      const result = notice_entry.create({ ...opts });
      derived.text = message || result.text;
      derived.timeout = result.timeout;
      derived.button = result.button;
      derived.immutable = result.immutable;
      derived.confirm = result.confirm;
    }
    const content_fragment = this._build_fragment(normalized_id, derived.text, derived);
    if (this.active[normalized_id]?.noticeEl?.isConnected) {
      return this.active[normalized_id].setMessage(content_fragment, derived.timeout);
    }
    return this._render_notice(normalized_id, content_fragment, derived);
  }
  /**
   * Normalizes the notice key to a safe string.
   */
  _normalize_notice_key(key) {
    return key.replace(/[^a-zA-Z0-9_-]/g, "_");
  }
  /**
   * Creates and tracks the notice instance
   */
  _render_notice(normalized_id, content_fragment, { timeout }) {
    this.active[normalized_id] = new this.adapter(content_fragment, timeout);
    return this.active[normalized_id];
  }
  /**
   * Builds a DocumentFragment with notice text & possible buttons
   */
  _build_fragment(id, text, { button, confirm: confirm2, immutable }) {
    const frag = document.createDocumentFragment();
    frag.createEl("p", {
      cls: "sc-notice-head",
      text: `[Smart Env v${this.env.constructor.version}]`
    });
    const content = frag.createEl("p", { cls: "sc-notice-content", text });
    const actions = frag.createEl("div", { cls: "sc-notice-actions" });
    if (confirm2?.text && typeof confirm2.callback === "function") {
      this._add_button(confirm2, actions);
    }
    if (button?.text && typeof button.callback === "function") {
      this._add_button(button, actions);
    }
    if (!immutable) {
      this._add_mute_button(id, actions);
    }
    return frag;
  }
  /**
   * Creates a <button> appended to the container
   */
  _add_button(btnConfig, container) {
    const btn = document.createElement("button");
    this.env.smart_view.safe_inner_html(btn, btnConfig.text);
    btn.addEventListener("click", (e) => {
      if (btnConfig.stay_open) {
        e.preventDefault();
        e.stopPropagation();
      }
      btnConfig.callback?.(this.env);
    });
    container.appendChild(btn);
  }
  /**
   * Mute button
   */
  _add_mute_button(id, container) {
    const btn = document.createElement("button");
    (0, import_obsidian15.setIcon)(btn, "bell-off");
    btn.addEventListener("click", () => {
      if (!this.settings.muted) this.settings.muted = {};
      this.settings.muted[id] = true;
      if (NOTICES["notice muted"]) {
        this.show("notice muted", null, { timeout: 2e3 });
      }
    });
    container.appendChild(btn);
  }
  /**
   * Hides & clears all active notices
   */
  unload() {
    for (const id in this.active) {
      this.remove(id);
    }
  }
  /**
   * Removes an active notice by key
   */
  remove(id) {
    const normalized_id = this._normalize_notice_key(id);
    this.active[normalized_id]?.hide();
    delete this.active[normalized_id];
  }
};

// node_modules/obsidian-smart-env/styles.css
var css_sheet3 = new CSSStyleSheet();
css_sheet3.replaceSync(`.status-bar-item:has(.smart-env-status-container) {
  padding: 0 0.5em;

  &:hover {
    background-color: var(--background-modifier-hover);
  }
  &> .smart-env-status-container {
    display: flex;
    align-items: center;
    gap: 0.5em;
    text-decoration: none;
    color: var(--status-bar-text-color);
  }
}`);
var styles_default = css_sheet3;

// node_modules/obsidian-smart-env/sc_oauth.js
var import_obsidian17 = require("obsidian");

// node_modules/obsidian-smart-env/node_modules/smart-plugins-obsidian/utils.js
var import_obsidian16 = require("obsidian");
function get_smart_server_url() {
  if (typeof window !== "undefined" && window.SMART_SERVER_URL_OVERRIDE) {
    return window.SMART_SERVER_URL_OVERRIDE;
  }
  return "https://connect.smartconnections.app";
}
function try_get_zlib() {
  if (typeof window?.require === "function") {
    try {
      return window.require("zlib");
    } catch {
    }
  }
  return null;
}
function inflate_deflate_data(compressed) {
  const zlib = try_get_zlib();
  if (!zlib) {
    throw new Error("zlib not available (maybe Obsidian mobile?).");
  }
  const buf = Buffer.from(compressed);
  const out = zlib.inflateRawSync(buf);
  return new Uint8Array(out.buffer, out.byteOffset, out.length);
}
async function parse_zip_into_files(zipBuffer) {
  const dv = new DataView(zipBuffer);
  let offset = 0;
  const length = dv.byteLength;
  const files = [];
  let pluginManifest = null;
  while (offset + 4 <= length) {
    const localSig = dv.getUint32(offset, true);
    if (localSig === 33639248 || localSig === 134695760) {
      break;
    }
    if (localSig !== 67324752) {
      break;
    }
    offset += 4;
    const versionNeeded = dv.getUint16(offset, true);
    const generalPurposeBitFlag = dv.getUint16(offset + 2, true);
    const compressionMethod = dv.getUint16(offset + 4, true);
    offset += 6;
    const lastModTimeDate = dv.getUint32(offset, true);
    offset += 4;
    let crc32 = dv.getUint32(offset, true);
    let compressedSize = dv.getUint32(offset + 4, true);
    let uncompressedSize = dv.getUint32(offset + 8, true);
    offset += 12;
    const fileNameLen = dv.getUint16(offset, true);
    const extraLen = dv.getUint16(offset + 2, true);
    offset += 4;
    const fileNameBytes = new Uint8Array(zipBuffer.slice(offset, offset + fileNameLen));
    const fileName = new TextDecoder("utf-8").decode(fileNameBytes);
    offset += fileNameLen;
    offset += extraLen;
    const hasDataDescriptor = (generalPurposeBitFlag & 8) !== 0;
    let compDataStart = offset;
    let compDataEnd;
    if (!hasDataDescriptor) {
      compDataEnd = compDataStart + compressedSize;
    } else {
      let scanPos = compDataStart;
      let foundSig = false;
      while (scanPos + 4 <= length) {
        const sig = dv.getUint32(scanPos, true);
        if (sig === 134695760 || sig === 67324752 || sig === 33639248) {
          foundSig = true;
          break;
        }
        scanPos++;
      }
      compDataEnd = foundSig ? scanPos : length;
    }
    if (compDataEnd > length) {
      break;
    }
    const fileDataCompressed = new Uint8Array(zipBuffer.slice(compDataStart, compDataEnd));
    offset = compDataEnd;
    if (hasDataDescriptor) {
      if (offset + 4 <= length) {
        const ddSig = dv.getUint32(offset, true);
        if (ddSig === 134695760) {
          offset += 4;
        }
        if (offset + 12 <= length) {
          crc32 = dv.getUint32(offset, true);
          compressedSize = dv.getUint32(offset + 4, true);
          uncompressedSize = dv.getUint32(offset + 8, true);
          offset += 12;
        } else {
          break;
        }
      }
    }
    let rawData;
    if (compressionMethod === 0) {
      rawData = fileDataCompressed;
    } else if (compressionMethod === 8) {
      rawData = inflate_deflate_data(fileDataCompressed);
    } else {
      continue;
    }
    files.push({ fileName, data: rawData });
    if (fileName.toLowerCase().endsWith("manifest.json") && !fileName.includes("/")) {
      try {
        pluginManifest = JSON.parse(new TextDecoder("utf-8").decode(rawData));
      } catch {
      }
    }
  }
  return { files, pluginManifest };
}
async function write_files_with_adapter(adapter, baseFolder, files) {
  const hasWriteBinary = typeof adapter.writeBinary === "function";
  if (!await adapter.exists(baseFolder)) {
    await adapter.mkdir(baseFolder);
  }
  for (const { fileName, data } of files) {
    const fullPath = baseFolder + "/" + fileName;
    if (hasWriteBinary) {
      await adapter.writeBinary(fullPath, data);
    } else {
      const base642 = btoa(String.fromCharCode(...data));
      await adapter.write(fullPath, base642);
    }
  }
}
async function fetch_plugin_zip(repoName, token) {
  const resp = await (0, import_obsidian16.requestUrl)({
    url: `${get_smart_server_url()}/plugin_download`,
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${token}`
    },
    body: JSON.stringify({ repo: repoName })
  });
  if (resp.status !== 200) {
    throw new Error(`plugin_download error ${resp.status}: ${resp.text}`);
  }
  const ab = resp.arrayBuffer;
  if (ab.byteLength < 4) {
    throw new Error("Server returned too few bytes, not a valid ZIP.");
  }
  const dv = new DataView(ab);
  if (dv.getUint32(0, true) !== 67324752) {
    const txt = new TextDecoder().decode(new Uint8Array(ab));
    throw new Error(`Server did not return a valid ZIP. Text:
${txt}`);
  }
  return ab;
}
async function enable_plugin(app2, plugin_id) {
  await app2.plugins.enablePlugin(plugin_id);
  app2.plugins.enabledPlugins.add(plugin_id);
  app2.plugins.requestSaveConfig();
  app2.plugins.loadManifests();
}

// node_modules/obsidian-smart-env/sc_oauth.js
var CLIENT_ID = "smart-plugins-op";
var CLIENT_SECRET = "smart-plugins-op-secret";
function get_local_storage_token(oauth_storage_prefix) {
  return {
    token: localStorage.getItem(oauth_storage_prefix + "token") || "",
    refresh: localStorage.getItem(oauth_storage_prefix + "refresh") || ""
  };
}
function set_local_storage_token({ access_token, refresh_token }, oauth_storage_prefix) {
  localStorage.setItem(oauth_storage_prefix + "token", access_token);
  if (refresh_token) {
    localStorage.setItem(oauth_storage_prefix + "refresh", refresh_token);
  }
}
async function exchange_code_for_tokens(code, plugin) {
  const oauth_storage_prefix = plugin.app.vault.getName().toLowerCase().replace(/[^a-z0-9]/g, "_") + "_smart_plugins_oauth_";
  const url = `${get_smart_server_url()}/auth/oauth_exchange2`;
  const resp = await (0, import_obsidian17.requestUrl)({
    url,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      client_id: CLIENT_ID,
      client_secret: CLIENT_SECRET,
      code
    })
  });
  if (resp.status !== 200) {
    throw new Error(`OAuth exchange error ${resp.status} ${resp.text}`);
  }
  const { access_token, refresh_token } = resp.json;
  if (!access_token) {
    throw new Error("No access_token in response");
  }
  set_local_storage_token({ access_token, refresh_token }, oauth_storage_prefix);
}
async function install_smart_plugins_plugin(plugin) {
  const oauth_storage_prefix = plugin.app.vault.getName().toLowerCase().replace(/[^a-z0-9]/g, "_") + "_smart_plugins_oauth_";
  const { token } = get_local_storage_token(oauth_storage_prefix);
  if (!token) throw new Error('No token found to install "smart-plugins"');
  const repo = "brianpetro/smart-plugins-obsidian";
  const zipData = await fetch_plugin_zip(repo, token);
  const { files, pluginManifest } = await parse_zip_into_files(zipData);
  let folder_name = (pluginManifest?.id || "smart-plugins").trim();
  folder_name = folder_name.replace(/[^\w-]/g, "_");
  const base_folder = ".obsidian/plugins/" + folder_name;
  await write_files_with_adapter(plugin.app.vault.adapter, base_folder, files);
  await plugin.app.plugins.loadManifests();
  if (plugin.app.plugins.manifests[folder_name]) {
    await enable_plugin(plugin.app, folder_name);
  }
}

// node_modules/obsidian-smart-env/utils/open_url_externally.js
function open_url_externally(plugin, url) {
  const webviewer = plugin.app.internalPlugins?.plugins?.webviewer?.instance;
  window.open(url, webviewer ? "_external" : "_blank");
}

// node_modules/obsidian-smart-env/utils/register_status_bar_context_menu.js
var import_obsidian19 = require("obsidian");

// node_modules/obsidian-smart-env/views/source_inspector.js
var import_obsidian18 = require("obsidian");
var SmartNoteInspectModal = class extends import_obsidian18.Modal {
  constructor(smart_connections_plugin, entity) {
    super(smart_connections_plugin.app);
    this.smart_connections_plugin = smart_connections_plugin;
    this.entity = entity;
  }
  get env() {
    return this.smart_connections_plugin.env;
  }
  onOpen() {
    this.titleEl.innerText = this.entity.key;
    this.render();
  }
  async render() {
    this.contentEl.empty();
    const frag = await this.env.render_component("source_inspector", this.entity);
    this.contentEl.appendChild(frag);
  }
};

// node_modules/obsidian-smart-env/utils/register_status_bar_context_menu.js
function register_status_bar_context_menu(env, status_container) {
  const plugin = env.main;
  const on_context_menu = (ev) => {
    ev.preventDefault();
    ev.stopPropagation();
    const menu = new import_obsidian19.Menu(plugin.app);
    menu.addItem(
      (item) => item.setTitle("Inspect active note").setIcon("search").onClick(async () => {
        const active_file = plugin.app.workspace.getActiveFile();
        if (!active_file) {
          new import_obsidian19.Notice("No active note found");
          return;
        }
        const src = env.smart_sources?.get(active_file.path);
        if (!src) {
          new import_obsidian19.Notice("Active note is not indexed by Smart Environment");
          return;
        }
        new SmartNoteInspectModal(plugin, src).open();
      })
    );
    menu.addItem(
      (item) => item.setTitle("Show stats").setIcon("chart-pie").onClick(() => {
        const modal = new EnvStatsModal(plugin.app, env);
        modal.open();
      })
    );
    menu.addSeparator();
    menu.addItem(
      (item) => item.setTitle("Learn about Community Supporters").setIcon("hand-heart").onClick(() => {
        const url = "https://smartconnections.app/community-supporters/?utm_source=status-bar";
        window.open(url, "_external");
      })
    );
    menu.showAtPosition({ x: ev.pageX, y: ev.pageY });
  };
  plugin.registerDomEvent(status_container, "contextmenu", on_context_menu);
  return on_context_menu;
}

// node_modules/obsidian-smart-env/smart_env.js
var SmartEnv2 = class extends SmartEnv {
  static async create(plugin, main_env_opts = null) {
    add_smart_chat_icon();
    add_smart_connections_icon();
    if (!main_env_opts) main_env_opts = plugin.smart_env_config;
    if (plugin.app.plugins.plugins["smart-connections"] && plugin.app.plugins.plugins["smart-connections"].env && !plugin.app.plugins.plugins["smart-connections"].env.constructor.version) {
      const update_notice = "Detected older SmartEnv with 'init_main'. Reloading without the outdated plugin. Please update Smart Connections.";
      console.warn(update_notice);
      new import_obsidian20.Notice(update_notice, 0);
      disable_plugin(plugin.app, "smart-connections");
    }
    const opts = merge_env_config(main_env_opts, default_config_default);
    return await super.create(plugin, opts);
  }
  async load(force_load = false) {
    if (!import_obsidian20.Platform.isMobile && !this.plugin.app.workspace.protocolHandlers.has("sc-op/callback")) {
      this.plugin.registerObsidianProtocolHandler("sc-op/callback", async (params) => {
        await this.handle_sc_op_oauth_callback(params);
      });
    }
    if (import_obsidian20.Platform.isMobile && !force_load) {
      const frag = this.smart_view.create_doc_fragment(`<div><p>Smart Environment loading deferred on mobile.</p><button>Load Environment</button></div>`);
      frag.querySelector("button").addEventListener("click", () => {
        this.load(true);
      });
      new import_obsidian20.Notice(frag, 0);
      return;
    }
    await super.load();
    const plugin = this.main;
    plugin.registerEvent(
      plugin.app.vault.on("create", (file) => {
        if (file instanceof import_obsidian20.TFile && this.smart_sources?.source_adapters?.[file.extension]) {
          const source2 = this.smart_sources?.init_file_path(file.path);
          if (source2) {
            this.queue_source_re_import(source2);
          } else {
            console.warn("SmartEnv: Unable to init source for newly created file", file.path);
          }
        }
      })
    );
    plugin.registerEvent(
      plugin.app.vault.on("rename", (file, old_path) => {
        if (file instanceof import_obsidian20.TFile && this.smart_sources?.source_adapters?.[file.extension]) {
          const source2 = this.smart_sources?.init_file_path(file.path);
          if (source2) {
            this.queue_source_re_import(source2);
          } else {
            console.warn("SmartEnv: Unable to init source for renamed file", file.path);
          }
        }
        if (old_path) {
          const source2 = this.smart_sources?.get(old_path);
          if (source2) {
            source2.delete();
            if (this.rename_debounce_timeout) clearTimeout(this.rename_debounce_timeout);
            this.rename_debounce_timeout = setTimeout(() => {
              this.smart_sources?.process_save_queue();
              this.rename_debounce_timeout = null;
            }, 1e3);
          }
        }
      })
    );
    plugin.registerEvent(
      plugin.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian20.TFile && this.smart_sources?.source_adapters?.[file.extension]) {
          const source2 = this.smart_sources?.get(file.path);
          if (source2) {
            this.queue_source_re_import(source2);
          } else {
            console.warn("SmartEnv: Unable to get source for modified file", file.path);
          }
        }
      })
    );
    plugin.registerEvent(
      plugin.app.workspace.on("editor-change", () => {
        this.debounce_re_import_queue();
      })
    );
    plugin.registerEvent(
      plugin.app.workspace.on("active-leaf-change", () => {
        this.debounce_re_import_queue();
      })
    );
    plugin.registerEvent(
      plugin.app.vault.on("delete", (file) => {
        if (file instanceof import_obsidian20.TFile && this.smart_sources?.source_adapters?.[file.extension]) {
          delete this.smart_sources?.items[file.path];
        }
      })
    );
    this.refresh_status();
  }
  // queue re-import the file
  queue_source_re_import(source2) {
    if (!source2 || !source2.key) return;
    if (!this.sources_re_import_queue) this.sources_re_import_queue = {};
    if (this.sources_re_import_queue?.[source2.key]) return;
    source2.data.last_import = { at: 0, hash: null, mtime: 0, size: 0 };
    this.sources_re_import_queue[source2.key] = source2;
    this.debounce_re_import_queue();
  }
  debounce_re_import_queue() {
    this.refresh_status();
    this.sources_re_import_halted = true;
    if (this.sources_re_import_timeout) clearTimeout(this.sources_re_import_timeout);
    if (!this.sources_re_import_queue || Object.keys(this.sources_re_import_queue).length === 0) {
      this.sources_re_import_timeout = null;
      return;
    }
    this.sources_re_import_timeout = setTimeout(this.run_re_import.bind(this), this.settings.re_import_wait_time * 1e3);
  }
  async run_re_import() {
    this.sources_re_import_halted = false;
    const queue_length = Object.keys(this.sources_re_import_queue || {}).length;
    if (queue_length) {
      for (const [key, src] of Object.entries(this.sources_re_import_queue)) {
        await src.import();
        if (!this.smart_sources._embed_queue) this.smart_sources._embed_queue = [];
        if (src.should_embed) this.smart_sources._embed_queue.push(src);
        if (this.smart_blocks.settings.embed_blocks) {
          for (const block of src.blocks) {
            if (block._queue_embed || block.should_embed && block.is_unembedded) {
              this.smart_sources._embed_queue.push(block);
              block._queue_embed = true;
            }
          }
        }
        delete this.sources_re_import_queue[key];
        if (this.sources_re_import_halted) {
          this.debounce_re_import_queue();
        }
      }
      if (this.smart_sources?._embed_queue?.length) {
        await this.smart_sources.process_embed_queue();
      }
    }
    if (this.sources_re_import_timeout) clearTimeout(this.sources_re_import_timeout);
    this.sources_re_import_timeout = null;
    this.refresh_status();
  }
  refresh_status() {
    if (!this.status_elm) {
      const existing = this.main.app.statusBar.containerEl.querySelector(".smart-env-status-container");
      if (existing) {
        existing.closest(".status-bar-item")?.remove();
      }
      this.status_elm = this.main.addStatusBarItem();
      this.smart_view.apply_style_sheet(styles_default);
      this.status_container = this.status_elm.createEl("a", {
        cls: "smart-env-status-container"
      });
      (0, import_obsidian20.setIcon)(this.status_container, "smart-connections");
      this.status_msg = this.status_container.createSpan(
        "smart-env-status-msg"
      );
      this.open_context_menu_handler = register_status_bar_context_menu(
        this,
        this.status_container
      );
    }
    const queue_length = Object.keys(this.sources_re_import_queue || {}).length;
    if (queue_length) {
      this.status_msg.setText(`Embed now (${queue_length})`);
      this.status_container.setAttribute("title", "Click to re\u2011import.");
      this.status_container.removeAttribute("href");
      this.status_container.removeEventListener(
        "click",
        this.open_menu_click_handler
      );
      this.status_container.removeEventListener(
        "click",
        re_embed_click_handler
      );
      this.status_container.addEventListener("click", re_embed_click_handler);
      return;
    }
    this.status_msg.setText("Smart Env " + this.constructor.version);
    this.status_container.setAttribute("title", "Smart Environment status");
    this.status_container.removeEventListener("click", re_embed_click_handler);
    this.status_container.removeAttribute("href");
    this.status_container.removeAttribute("target");
    if (!this.open_menu_click_handler) {
      this.open_menu_click_handler = (e) => {
        const evt = new MouseEvent("contextmenu", e);
        this.status_container.dispatchEvent(evt);
      };
    }
    this.status_container.removeEventListener(
      "click",
      this.open_menu_click_handler
    );
    this.status_container.addEventListener("click", this.open_menu_click_handler);
  }
  get notices() {
    if (!this._notices) {
      this._notices = new SmartNotices(this, {
        adapter: import_obsidian20.Notice
      });
    }
    return this._notices;
  }
  get settings_config() {
    const config = super.settings_config;
    delete config["is_obsidian_vault"];
    config["re_import_wait_time"] = {
      type: "number",
      name: "Re-import wait time",
      description: "Time in seconds to wait before re-importing a file after modification."
    };
    return config;
  }
  // Smart Plugins
  /**
   * This is the function that is called by the new "Sign in with Smart Plugins" button.
   * It replicates the old 'initiate_oauth()' logic from sc_settings_tab.js
   */
  initiate_smart_plugins_oauth() {
    console.log("initiate_smart_plugins_oauth");
    const state = Math.random().toString(36).slice(2);
    const redirect_uri = encodeURIComponent("obsidian://sc-op/callback");
    const url = `${get_smart_server_url()}/oauth?client_id=smart-plugins-op&redirect_uri=${redirect_uri}&state=${state}`;
    open_url_externally(this.plugin, url);
  }
  /**
   * Handles the OAuth callback from the Smart Plugins server.
   * @param {Object} params - The URL parameters from the OAuth callback.
   */
  async handle_sc_op_oauth_callback(params) {
    const code = params.code;
    if (!code) {
      new import_obsidian20.Notice("No OAuth code provided in URL. Login failed.");
      return;
    }
    try {
      await exchange_code_for_tokens(code, this.plugin);
      await install_smart_plugins_plugin(this.plugin);
      new import_obsidian20.Notice("Smart Plugins installed / updated successfully!");
      this.open_smart_plugins_settings();
    } catch (err) {
      console.error("OAuth callback error", err);
      new import_obsidian20.Notice(`OAuth callback error: ${err.message}`);
    }
  }
  /**
   * Opens the Obsidian settings window with the 'Smart Plugins' tab active.
   * @public
   */
  async open_smart_plugins_settings() {
    const spInstalled = this.plugin.app.plugins.plugins["smart-plugins"];
    if (!spInstalled) {
      await install_smart_plugins_plugin(this.plugin);
      await new Promise((r) => setTimeout(r, 500));
    }
    const spEnabled = this.plugin.app.plugins.enabledPlugins.has("smart-plugins");
    if (!spEnabled) {
      await enable_plugin(this.plugin.app, "smart-plugins");
      await new Promise((r) => setTimeout(r, 500));
    }
    this.plugin.app.commands.executeCommandById("app:open-settings");
    const spTab = this.plugin.app.setting.pluginTabs.find((t) => t.name === "Smart Plugins");
    if (spTab) {
      this.plugin.app.setting.openTab(spTab);
    }
  }
  // WAIT FOR OBSIDIAN SYNC
  async ready_to_load_collections() {
    await new Promise((r) => setTimeout(r, 3e3));
    await this.wait_for_obsidian_sync();
  }
  async wait_for_obsidian_sync() {
    while (this.obsidian_is_syncing) {
      console.log("Smart Connections: Waiting for Obsidian Sync to finish");
      await new Promise((r) => setTimeout(r, 1e3));
      if (!this.plugin) throw new Error("Plugin disabled while waiting for obsidian sync, reload required.");
    }
  }
  get obsidian_is_syncing() {
    const obsidian_sync_instance = this.plugin?.app?.internalPlugins?.plugins?.sync?.instance;
    if (!obsidian_sync_instance) return false;
    if (obsidian_sync_instance?.syncStatus.startsWith("Uploading")) return false;
    if (obsidian_sync_instance?.syncStatus.startsWith("Fully synced")) return false;
    return obsidian_sync_instance?.syncing;
  }
};
async function disable_plugin(app2, plugin_id) {
  console.log("disabling plugin " + plugin_id);
  await app2.plugins.unloadPlugin(plugin_id);
  await app2.plugins.disablePluginAndSave(plugin_id);
  await app2.plugins.loadManifests();
}
function re_embed_click_handler(e) {
  e.preventDefault();
  e.stopPropagation();
  smart_env.status_msg.setText(`Embedding...`);
  smart_env.run_re_import();
}

// node_modules/smart-collections/adapters/_adapter.js
var CollectionDataAdapter2 = class {
  /**
   * @constructor
   * @param {Object} collection - The collection instance that this adapter manages.
   */
  constructor(collection) {
    this.collection = collection;
    this.env = collection.env;
  }
  /**
   * The class to use for item adapters.
   * @type {typeof ItemDataAdapter}
   */
  ItemDataAdapter = ItemDataAdapter2;
  /**
   * Optional factory method to create item adapters.
   * If `this.item_adapter_class` is not null, it uses that; otherwise can be overridden by subclasses.
   * @param {Object} item - The item to create an adapter for.
   * @returns {ItemDataAdapter}
   */
  create_item_adapter(item) {
    if (!this.ItemDataAdapter) {
      throw new Error("No item_adapter_class specified and create_item_adapter not overridden.");
    }
    return new this.ItemDataAdapter(item);
  }
  /**
   * Load a single item by its key using an `ItemDataAdapter`.
   * @async
   * @param {string} key - The key of the item to load.
   * @returns {Promise<void>} Resolves when the item is loaded.
   */
  async load_item(key) {
    throw new Error("Not implemented");
  }
  /**
   * Save a single item by its key using its associated `ItemDataAdapter`.
   * @async
   * @param {string} key - The key of the item to save.
   * @returns {Promise<void>} Resolves when the item is saved.
   */
  async save_item(key) {
    throw new Error("Not implemented");
  }
  /**
   * Delete a single item by its key. This may involve updating or removing its file,
   * as handled by the `ItemDataAdapter`.
   * @async
   * @param {string} key - The key of the item to delete.
   * @returns {Promise<void>} Resolves when the item is deleted.
   */
  async delete_item(key) {
    throw new Error("Not implemented");
  }
  /**
   * Process any queued load operations. Typically orchestrates calling `load_item()` 
   * on items that have been flagged for loading.
   * @async
   * @returns {Promise<void>}
   */
  async process_load_queue() {
    throw new Error("Not implemented");
  }
  /**
   * Process any queued save operations. Typically orchestrates calling `save_item()` 
   * on items that have been flagged for saving.
   * @async
   * @returns {Promise<void>}
   */
  async process_save_queue() {
    throw new Error("Not implemented");
  }
  /**
   * Load the item's data from storage if it has been updated externally.
   * @async
   * @param {string} key - The key of the item to load.
   * @returns {Promise<void>} Resolves when the item is loaded.
   */
  async load_item_if_updated(item) {
    const adapter = this.create_item_adapter(item);
    await adapter.load_if_updated();
  }
};
var ItemDataAdapter2 = class {
  /**
   * @constructor
   * @param {Object} item - The collection item instance that this adapter manages.
   */
  constructor(item) {
    this.item = item;
  }
  /**
   * Load the item's data from storage. May involve reading a file and parsing 
   * its contents, then updating `item.data`.
   * @async
   * @returns {Promise<void>} Resolves when the item is fully loaded.
   */
  async load() {
    throw new Error("Not implemented");
  }
  /**
   * Save the item's data to storage. May involve writing to a file or appending 
   * lines in an append-only format.
   * @async
   * @param {string|null} [ajson=null] - An optional serialized representation of the item’s data.
   *                                     If not provided, the adapter should derive it from the item.
   * @returns {Promise<void>} Resolves when the item is saved.
   */
  async save(ajson = null) {
    throw new Error("Not implemented");
  }
  /**
   * Delete the item's data from storage. May involve removing a file or writing 
   * a `null` entry in an append-only file to signify deletion.
   * @async
   * @returns {Promise<void>} Resolves when the item’s data is deleted.
   */
  async delete() {
    throw new Error("Not implemented");
  }
  /**
   * Returns the file path or unique identifier used by this adapter to locate and store 
   * the item's data. This may be a file name derived from the item's key.
   * @returns {string} The path or identifier for the item's data.
   */
  get data_path() {
    throw new Error("Not implemented");
  }
  /**
   * @returns {CollectionDataAdapter} The collection data adapter that this item data adapter belongs to.
   */
  get collection_adapter() {
    return this.item.collection.data_adapter;
  }
  get env() {
    return this.item.env;
  }
  /**
   * Load the item's data from storage if it has been updated externally.
   * @async
   * @returns {Promise<void>} Resolves when the item is loaded.
   */
  async load_if_updated() {
    throw new Error("Not implemented");
  }
};

// node_modules/smart-collections/adapters/_file.js
var FileCollectionDataAdapter2 = class extends CollectionDataAdapter2 {
  /**
   * The class to use for item adapters.
   * @type {typeof ItemDataAdapter}
   */
  ItemDataAdapter = FileItemDataAdapter2;
  /**
   * @returns {Object} Filesystem interface derived from environment or collection settings.
   */
  get fs() {
    return this.collection.data_fs || this.collection.env.data_fs;
  }
};
var FileItemDataAdapter2 = class extends ItemDataAdapter2 {
  /**
   * @returns {Object} Filesystem interface derived from environment or collection settings.
   */
  get fs() {
    return this.item.collection.data_fs || this.item.collection.env.data_fs;
  }
  get data_path() {
    throw new Error("Not implemented");
  }
  async load_if_updated() {
    const data_path = this.data_path;
    if (await this.fs.exists(data_path)) {
      const loaded_at = this.item.loaded_at || 0;
      const data_file_stat = await this.fs.stat(data_path);
      if (data_file_stat.mtime > loaded_at + 1 * 60 * 1e3) {
        console.log(`Smart Collections: Re-loading item ${this.item.key} because it has been updated on disk`);
        await this.load();
      }
    }
  }
};

// node_modules/smart-collections/adapters/ajson_multi_file.js
var class_to_collection_key3 = {
  "SmartSource": "smart_sources",
  "SmartNote": "smart_sources",
  // DEPRECATED
  "SmartBlock": "smart_blocks",
  "SmartDirectory": "smart_directories"
};
var AjsonMultiFileCollectionDataAdapter2 = class extends FileCollectionDataAdapter2 {
  /**
   * The class to use for item adapters.
   * @type {typeof ItemDataAdapter}
   */
  ItemDataAdapter = AjsonMultiFileItemDataAdapter2;
  /**
   * Load a single item by its key.
   * @async
   * @param {string} key
   * @returns {Promise<void>}
   */
  async load_item(key) {
    const item = this.collection.get(key);
    if (!item) return;
    const adapter = this.create_item_adapter(item);
    await adapter.load();
  }
  /**
   * Save a single item by its key.
   * @async
   * @param {string} key
   * @returns {Promise<void>}
   */
  async save_item(key) {
    const item = this.collection.get(key);
    if (!item) return;
    const adapter = this.create_item_adapter(item);
    await adapter.save();
  }
  /**
   * Process any queued load operations.
   * @async
   * @returns {Promise<void>}
   */
  async process_load_queue() {
    this.collection.show_process_notice("loading_collection");
    if (!await this.fs.exists(this.collection.data_dir)) {
      await this.fs.mkdir(this.collection.data_dir);
    }
    const load_queue = Object.values(this.collection.items).filter((item) => item._queue_load);
    if (!load_queue.length) {
      this.collection.clear_process_notice("loading_collection");
      return;
    }
    console.log(`Loading ${this.collection.collection_key}: ${load_queue.length} items`);
    const batch_size = 100;
    for (let i = 0; i < load_queue.length; i += batch_size) {
      const batch = load_queue.slice(i, i + batch_size);
      await Promise.all(batch.map((item) => {
        const adapter = this.create_item_adapter(item);
        return adapter.load().catch((err) => {
          console.warn(`Error loading item ${item.key}`, err);
          item.queue_load();
        });
      }));
    }
    this.collection.loaded = load_queue.length;
    this.collection.clear_process_notice("loading_collection");
  }
  /**
   * Process any queued save operations.
   * @async
   * @returns {Promise<void>}
   */
  async process_save_queue() {
    this.collection.show_process_notice("saving_collection");
    const save_queue = Object.values(this.collection.items).filter((item) => item._queue_save);
    console.log(`Saving ${this.collection.collection_key}: ${save_queue.length} items`);
    const time_start = Date.now();
    const batch_size = 50;
    for (let i = 0; i < save_queue.length; i += batch_size) {
      const batch = save_queue.slice(i, i + batch_size);
      await Promise.all(batch.map((item) => {
        const adapter = this.create_item_adapter(item);
        return adapter.save().catch((err) => {
          console.warn(`Error saving item ${item.key}`, err);
          item.queue_save();
        });
      }));
    }
    const deleted_items = Object.values(this.collection.items).filter((item) => item.deleted);
    if (deleted_items.length) {
      deleted_items.forEach((item) => {
        delete this.collection.items[item.key];
      });
    }
    console.log(`Saved ${this.collection.collection_key} in ${Date.now() - time_start}ms`);
    this.collection.clear_process_notice("saving_collection");
  }
  get_item_data_path(key) {
    return [
      this.collection.data_dir || "multi",
      this.fs?.sep || "/",
      this.get_data_file_name(key) + ".ajson"
    ].join("");
  }
  /**
   * Transforms the item key into a safe filename.
   * Replaces spaces, slashes, and dots with underscores.
   * @returns {string} safe file name
   */
  get_data_file_name(key) {
    return key.split("#")[0].replace(/[\s\/\.]/g, "_").replace(".md", "");
  }
  /**
   * Build a single AJSON line for the given item and data.
   * @param {Object} item 
   * @returns {string}
   */
  get_item_ajson(item) {
    const collection_key = item.collection_key;
    const key = item.key;
    const data_value = item.deleted ? "null" : JSON.stringify(item.data);
    return `${JSON.stringify(`${collection_key}:${key}`)}: ${data_value},`;
  }
};
var AjsonMultiFileItemDataAdapter2 = class extends FileItemDataAdapter2 {
  /**
   * Derives the `.ajson` file path from the collection's data_dir and item key.
   * @returns {string}
   */
  get data_path() {
    return this.collection_adapter.get_item_data_path(this.item.key);
  }
  /**
   * Load the item from its `.ajson` file.
   * @async
   * @returns {Promise<void>}
   */
  async load() {
    try {
      const raw_data = await this.fs.adapter.read(this.data_path, "utf-8", { no_cache: true });
      if (!raw_data) {
        this.item.queue_import();
        return;
      }
      const { rewrite, file_data } = this._parse(raw_data);
      if (rewrite) {
        if (file_data.length) await this.fs.write(this.data_path, file_data);
        else await this.fs.remove(this.data_path);
      }
      const last_import_mtime = this.item.data.last_import?.at || 0;
      if (last_import_mtime && this.item.init_file_mtime > last_import_mtime) {
        this.item.queue_import();
      }
    } catch (e) {
      this.item.queue_import();
    }
  }
  /**
   * Parse the entire AJSON content as a JSON object, handle legacy keys, and extract final state.
   * @private
   * @param {string} ajson 
   * @returns {boolean}
   */
  _parse(ajson) {
    try {
      let rewrite = false;
      if (!ajson.length) return false;
      ajson = ajson.trim();
      const original_line_count = ajson.split("\n").length;
      const json_str = "{" + ajson.slice(0, -1) + "}";
      const data = JSON.parse(json_str);
      const entries = Object.entries(data);
      for (let i = 0; i < entries.length; i++) {
        const [ajson_key, value] = entries[i];
        if (!value) {
          delete data[ajson_key];
          rewrite = true;
          continue;
        }
        const { collection_key, item_key, changed } = this._parse_ajson_key(ajson_key);
        if (changed) {
          rewrite = true;
          data[collection_key + ":" + item_key] = value;
          delete data[ajson_key];
        }
        const collection = this.env[collection_key];
        if (!collection) continue;
        const existing_item = collection.get(item_key);
        if (!value.key) value.key = item_key;
        if (existing_item) {
          existing_item.data = value;
          existing_item._queue_load = false;
          existing_item.loaded_at = Date.now();
        } else {
          const ItemClass = collection.item_type;
          const new_item = new ItemClass(this.env, value);
          new_item._queue_load = false;
          new_item.loaded_at = Date.now();
          collection.set(new_item);
        }
      }
      if (rewrite || original_line_count > entries.length) {
        rewrite = true;
      }
      return {
        rewrite,
        file_data: rewrite ? Object.entries(data).map(([key, value]) => `${JSON.stringify(key)}: ${JSON.stringify(value)},`).join("\n") : null
      };
    } catch (e) {
      if (ajson.split("\n").some((line) => !line.endsWith(","))) {
        console.warn("fixing trailing comma error");
        ajson = ajson.split("\n").map((line) => line.endsWith(",") ? line : line + ",").join("\n");
        return this._parse(ajson);
      }
      console.warn("Error parsing JSON:", e);
      return { rewrite: true, file_data: null };
    }
  }
  _parse_ajson_key(ajson_key) {
    let changed;
    let [collection_key, ...item_key] = ajson_key.split(":");
    if (class_to_collection_key3[collection_key]) {
      collection_key = class_to_collection_key3[collection_key];
      changed = true;
    }
    return {
      collection_key,
      item_key: item_key.join(":"),
      changed
    };
  }
  /**
   * Save the current state of the item by appending a new line to its `.ajson` file.
   * @async
   * @returns {Promise<void>}
   */
  async save(retries = 0) {
    try {
      const ajson_line = this.get_item_ajson();
      await this.fs.append(this.data_path, "\n" + ajson_line);
      this.item._queue_save = false;
    } catch (e) {
      if (e.code === "ENOENT" && retries < 1) {
        const dir = this.collection_adapter.collection.data_dir;
        if (!await this.fs.exists(dir)) {
          await this.fs.mkdir(dir);
        }
        return await this.save(retries + 1);
      }
      console.warn("Error saving item", this.data_path, this.item.key, e);
    }
  }
  /**
   * Build a single AJSON line for the given item and data.
   * @param {Object} item 
   * @returns {string}
   */
  get_item_ajson() {
    return this.collection_adapter.get_item_ajson(this.item);
  }
};

// node_modules/smart-file-system/utils/glob_to_regex.js
function create_regex2(pattern, { case_sensitive, extended_glob, windows_paths }) {
  const regex_pattern = glob_to_regex_pattern2(pattern, extended_glob);
  const adjusted_pattern = adjust_for_windows_paths2(regex_pattern, windows_paths);
  const flags = case_sensitive ? "" : "i";
  return new RegExp(`^${adjusted_pattern}$`, flags);
}
function adjust_for_windows_paths2(pattern, windows_paths) {
  return windows_paths ? pattern.replace(/\\\//g, "[\\\\/]").replace(/\\\\\\/g, "[\\\\/]") : pattern;
}
function glob_to_regex_pattern2(pattern, extended_glob) {
  let in_class = false;
  let in_brace = 0;
  let result = "";
  for (let i = 0; i < pattern.length; i++) {
    const char = pattern[i];
    switch (char) {
      case "\\":
        if (i + 1 < pattern.length) {
          result += `\\${pattern[i + 1]}`;
          i++;
        } else {
          result += "\\\\";
        }
        break;
      case "/":
        result += "\\/";
        break;
      case "[":
        if (!in_class) {
          const closingIndex = pattern.indexOf("]", i + 1);
          if (closingIndex === -1) {
            result += "\\[";
          } else {
            in_class = true;
            if (pattern[i + 1] === "!") {
              result += "[^";
              i++;
            } else {
              result += "[";
            }
          }
        } else {
          result += "\\[";
        }
        break;
      case "]":
        if (in_class) {
          in_class = false;
          result += "]";
        } else {
          result += "\\]";
        }
        break;
      case "{":
        if (!in_class) {
          const closingIndex = pattern.indexOf("}", i + 1);
          if (closingIndex === -1) {
            result += "\\{";
          } else {
            in_brace++;
            result += "(";
          }
        } else {
          result += "\\{";
        }
        break;
      case "}":
        if (!in_class && in_brace > 0) {
          in_brace--;
          result += ")";
        } else {
          result += "\\}";
        }
        break;
      case ",":
        if (!in_class && in_brace > 0) {
          result += "|";
        } else {
          result += ",";
        }
        break;
      case "*":
        if (!in_class) {
          if (i + 1 < pattern.length && pattern[i + 1] === "*") {
            result += ".*";
            i++;
          } else {
            result += "[^/]*";
          }
        } else {
          result += "\\*";
        }
        break;
      case "?":
        if (!in_class) {
          result += "[^/]";
        } else {
          result += "\\?";
        }
        break;
      // We escape these to ensure they remain literal
      case "(":
      case ")":
      case "+":
      case "|":
      case "^":
      case "$":
      case ".":
        result += `\\${char}`;
        break;
      default:
        result += char;
        break;
    }
  }
  if (in_class) {
    result += "]";
    in_class = false;
  }
  if (extended_glob) {
    result = result.replace(/\\\+\\\((.*?)\\\)/g, "($1)+").replace(/\\\@\\\((.*?)\\\)/g, "($1)").replace(/\\\!\\\((.*?)\\\)/g, "(?!$1).*").replace(/\\\?\\\((.*?)\\\)/g, "($1)?").replace(/\\\*\\\((.*?)\\\)/g, "($1)*");
  }
  return result;
}
function glob_to_regex2(pattern, options = {}) {
  const default_options = {
    case_sensitive: true,
    extended_glob: false,
    windows_paths: false
  };
  const merged_options = { ...default_options, ...options };
  if (pattern === "") {
    return /^$/;
  }
  if (pattern === "*" && !merged_options.windows_paths) {
    return /^[^/]+$/;
  }
  if (pattern === "**" && !merged_options.windows_paths) {
    return /^.+$/;
  }
  return create_regex2(pattern, merged_options);
}

// node_modules/smart-file-system/utils/fuzzy_search.js
function fuzzy_search2(arr, search_term) {
  let matches = [];
  for (let i = 0; i < arr.length; i++) {
    const search_chars = search_term.toLowerCase().split("");
    let match = true;
    let distance = 0;
    const name = arr[i];
    const label_name = name.toLowerCase();
    for (let j = 0; j < search_chars.length; j++) {
      const search_index = label_name.substring(distance).indexOf(search_chars[j]);
      if (search_index >= 0) {
        distance += search_index + 1;
      } else {
        match = false;
        break;
      }
    }
    if (match) matches.push({ name, distance });
  }
  matches.sort((a, b) => a.distance - b.distance);
  return matches.map((match) => match.name);
}

// node_modules/smart-file-system/smart_fs.js
var SmartFs2 = class {
  /**
   * Create a new SmartFs instance
   * 
   * @param {Object} env - The Smart Environment instance
   * @param {Object} [opts={}] - Optional configuration
   * @param {string} [opts.fs_path] - Custom environment path
   */
  constructor(env, opts = {}) {
    this.env = env;
    this.opts = opts;
    this.fs_path = opts.fs_path || opts.env_path || "";
    if (!opts.adapter) throw new Error("SmartFs requires an adapter");
    this.adapter = new opts.adapter(this);
    this.excluded_patterns = [];
    if (Array.isArray(opts.exclude_patterns)) {
      opts.exclude_patterns.forEach((pattern) => this.add_ignore_pattern(pattern));
    }
    this.folders = {};
    this.files = {};
    this.file_paths = [];
    this.folder_paths = [];
    this.auto_excluded_files = [];
  }
  async refresh() {
    this.files = {};
    this.file_paths = [];
    this.folders = {};
    this.folder_paths = [];
    await this.init();
  }
  async init() {
    await this.load_exclusions();
    await this.load_files();
  }
  async load_files() {
    const all = await this.list_recursive();
    this.file_paths = [];
    this.folder_paths = [];
    all.forEach((file) => {
      if (file.type === "file") {
        this.files[file.path] = file;
        this.file_paths.push(file.path);
      } else if (file.type === "folder") {
        this.folders[file.path] = file;
        this.folder_paths.push(file.path);
      }
    });
  }
  include_file(file_path) {
    const file = this.adapter.get_file(file_path);
    this.files[file.path] = file;
    this.file_paths.push(file.path);
    return file;
  }
  /**
   * Load .gitignore patterns
   * 
   * @returns {Promise<RegExp[]>} Array of RegExp patterns
   */
  async load_exclusions() {
    const gitignore_path = ".gitignore";
    const gitignore_exists = await this.adapter.exists(gitignore_path);
    if (gitignore_exists && !this.env.settings.skip_excluding_gitignore) {
      const gitignore_content = await this.adapter.read(gitignore_path, "utf-8");
      gitignore_content.split("\n").filter((line) => !line.startsWith("#")).filter(Boolean).forEach((pattern) => this.add_ignore_pattern(pattern));
    }
    this.add_ignore_pattern(".**");
    this.add_ignore_pattern("**/.**");
    this.add_ignore_pattern("**/.*/**");
    this.add_ignore_pattern("**/*.ajson");
  }
  /**
   * Add a new ignore pattern
   * 
   * @param {string} pattern - The pattern to add
   */
  add_ignore_pattern(pattern, opts = {}) {
    this.excluded_patterns.push(glob_to_regex2(pattern.trim(), opts));
  }
  /**
   * Check if a path is ignored based on gitignore patterns
   * 
   * @param {string} _path - The path to check
   * @returns {boolean} True if the path is ignored, false otherwise
   */
  is_excluded(_path) {
    try {
      if (_path.includes("#")) return true;
      if (!this.excluded_patterns.length) return false;
      return this.excluded_patterns.some((pattern) => pattern.test(_path));
    } catch (e) {
      console.error(`Error checking if path is excluded: ${e.message}`);
      console.error(`Path: `, _path);
      throw e;
    }
  }
  /**
   * Check if any path in an array of paths is excluded
   * 
   * @param {string[]} paths - Array of paths to check
   * @returns {boolean} True if any path is excluded, false otherwise
   */
  has_excluded_patterns(paths) {
    return paths.some((p) => this.is_excluded(p));
  }
  /**
   * Pre-process an array of paths, throwing an error if any path is excluded
   * 
   * @param {string[]} paths - Array of paths to pre-process
   * @throws {Error} If any path in the array is excluded
   * @returns {string[]} The array of paths
   */
  pre_process(paths) {
    if (this.has_excluded_patterns(paths)) {
      throw new Error(`Path is excluded: ${paths.find((p) => this.is_excluded(p))}`);
    }
    return paths;
  }
  /**
   * Post-process the result of an operation
   * 
   * @param {any} returned_value - The value returned by the operation
   * @returns {any} The post-processed value
   */
  post_process(returned_value) {
    if (this.adapter.post_process) return this.adapter.post_process(returned_value);
    if (Array.isArray(returned_value)) {
      returned_value = returned_value.filter((r) => {
        if (typeof r === "string") return !this.is_excluded(r);
        if (typeof r === "object" && r.path) return !this.is_excluded(r.path);
        return true;
      });
    }
    return returned_value;
  }
  // v2
  /**
   * Use the adapter for a method
   * runs pre_process and post_process (checks exclusions)
   * @param {string} method - The method to use
   * @param {string[]} paths - The paths to use
   * @param {...any} args - Additional arguments for the method
   * @returns {Promise<any>} The result of the method
   */
  async use_adapter(method, paths, ...args) {
    if (!this.adapter[method]) throw new Error(`Method ${method} not found in adapter`);
    paths = this.pre_process(paths ?? []);
    let resp = await this.adapter[method](...paths, ...args);
    return this.post_process(resp);
  }
  /**
   * Append content to a file
   * 
   * @param {string} rel_path - The relative path of the file to append to
   * @param {string|Buffer} content - The content to append
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async append(rel_path, content) {
    return await this.use_adapter("append", [rel_path], content);
  }
  /**
   * Create a new directory
   * 
   * @param {string} rel_path - The relative path of the directory to create
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async mkdir(rel_path, opts = { recursive: true }) {
    return await this.use_adapter("mkdir", [rel_path], opts);
  }
  /**
   * Check if a file or directory exists
   * 
   * @param {string} rel_path - The relative path to check
   * @returns {Promise<boolean>} True if the path exists, false otherwise
   */
  async exists(rel_path) {
    return await this.use_adapter("exists", [rel_path]);
  }
  /**
   * List files in a directory
   * 
   * @param {string} rel_path - The relative path to list
   * @returns {Promise<string[]>} Array of file paths
   */
  async list(rel_path = "/") {
    return await this.use_adapter("list", [rel_path]);
  }
  async list_recursive(rel_path = "/") {
    return await this.use_adapter("list_recursive", [rel_path]);
  }
  async list_files(rel_path = "/") {
    return await this.use_adapter("list_files", [rel_path]);
  }
  async list_files_recursive(rel_path = "/") {
    return await this.use_adapter("list_files_recursive", [rel_path]);
  }
  async list_folders(rel_path = "/") {
    return await this.use_adapter("list_folders", [rel_path]);
  }
  async list_folders_recursive(rel_path = "/") {
    return await this.use_adapter("list_folders_recursive", [rel_path]);
  }
  /**
   * Read the contents of a file
   * 
   * @param {string} rel_path - The relative path of the file to read
   * @returns {Promise<string|Buffer>} The contents of the file
   */
  async read(rel_path, encoding = "utf-8") {
    try {
      const content = await this.adapter.read(rel_path, encoding);
      return content;
    } catch (error) {
      console.warn("Error during read: " + error.message, rel_path);
      if (error.code === "ENOENT") return null;
      return { error: error.message };
    }
  }
  /**
   * Remove a file
   * 
   * @param {string} rel_path - The relative path of the file to remove
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async remove(rel_path) {
    return await this.use_adapter("remove", [rel_path]);
  }
  /**
   * Remove a directory
   * 
   * @param {string} rel_path - The relative path of the directory to remove
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async remove_dir(rel_path, recursive = false) {
    return await this.use_adapter("remove_dir", [rel_path], recursive);
  }
  /**
   * Rename a file or directory
   * 
   * @param {string} rel_path - The current relative path
   * @param {string} new_rel_path - The new relative path
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async rename(rel_path, new_rel_path) {
    await this.use_adapter("rename", [rel_path, new_rel_path]);
    await this.refresh();
  }
  /**
   * Get file or directory statistics
   * 
   * @param {string} rel_path - The relative path to get statistics for
   * @returns {Promise<Object>} An object containing file or directory statistics
   */
  async stat(rel_path) {
    return await this.use_adapter("stat", [rel_path]);
  }
  /**
   * Write content to a file
   * Should handle when target path is within a folder that doesn't exist
   * 
   * @param {string} rel_path - The relative path of the file to write to
   * @param {string|Buffer} content - The content to write
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async write(rel_path, content) {
    try {
      await this.adapter.write(rel_path, content);
    } catch (error) {
      console.error("Error during write:", error);
      throw error;
    }
  }
  // // aliases
  // async create(rel_path, content) { return await this.use_adapter('write', [rel_path], content); }
  // async update(rel_path, content) { return await this.use_adapter('write', [rel_path], content); }
  get_link_target_path(link_target, source_path) {
    if (this.adapter.get_link_target_path) return this.adapter.get_link_target_path(link_target, source_path);
    if (!this.file_paths) return console.warn("get_link_target_path: file_paths not found");
    const matching_file_paths = this.file_paths.filter((path) => path.includes(link_target));
    return fuzzy_search2(matching_file_paths, link_target)[0];
  }
  get sep() {
    return this.adapter.sep || "/";
  }
  get_full_path(rel_path = "") {
    return this.adapter.get_full_path(rel_path);
  }
  get base_path() {
    return this.adapter.get_base_path();
  }
};

// node_modules/smart-file-system/adapters/obsidian.js
var obsidian2 = __toESM(require("obsidian"), 1);
var SmartFsObsidianAdapter2 = class {
  /**
   * Create an SmartFsObsidianAdapter instance
   * 
   * @param {Object} smart_fs - The SmartFs instance
   */
  constructor(smart_fs) {
    this.smart_fs = smart_fs;
    this.obsidian = obsidian2;
    this.obsidian_app = smart_fs.env.main.app;
    this.obsidian_adapter = smart_fs.env.main.app.vault.adapter;
  }
  get fs_path() {
    return this.smart_fs.fs_path;
  }
  get_file(file_path) {
    const file = {};
    file.path = file_path.replace(/\\/g, "/").replace(this.smart_fs.fs_path, "").replace(/^\//, "");
    file.type = "file";
    file.extension = file.path.split(".").pop().toLowerCase();
    file.name = file.path.split("/").pop();
    file.basename = file.name.split(".").shift();
    Object.defineProperty(file, "stat", {
      get: () => {
        const tfile = this.obsidian_app.vault.getAbstractFileByPath(file_path);
        if (tfile) {
          return {
            ctime: tfile.stat.ctime,
            mtime: tfile.stat.mtime,
            size: tfile.stat.size,
            isDirectory: () => tfile instanceof this.obsidian.TFolder,
            isFile: () => tfile instanceof this.obsidian.TFile
          };
        }
        return null;
      }
    });
    return file;
  }
  /**
   * Append content to a file
   * 
   * @param {string} rel_path - The relative path of the file to append to
   * @param {string} data - The content to append
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async append(rel_path, data) {
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    return await this.obsidian_adapter.append(rel_path, data);
  }
  /**
   * Create a new directory
   * 
   * @param {string} rel_path - The relative path of the directory to create
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async mkdir(rel_path) {
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    return await this.obsidian_adapter.mkdir(rel_path);
  }
  /**
   * Check if a file or directory exists
   * 
   * @param {string} rel_path - The relative path to check
   * @returns {Promise<boolean>} True if the path exists, false otherwise
   */
  async exists(rel_path) {
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    return await this.obsidian_adapter.exists(rel_path);
  }
  /**
   * List files in a directory (NOT up-to-date with list_recursive)
   * 
   * @param {string} rel_path - The relative path to list
   * @returns {Promise<string[]>} Array of file paths
   */
  async list(rel_path, opts = {}) {
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    if (rel_path.startsWith("/")) rel_path = rel_path.slice(1);
    if (rel_path.endsWith("/")) rel_path = rel_path.slice(0, -1);
    if (rel_path.includes(".")) {
      const { files: file_paths } = await this.obsidian_adapter.list(rel_path);
      const files2 = file_paths.map((file_path) => {
        if (this.smart_fs.fs_path) file_path = file_path.replace(this.smart_fs.fs_path, "").slice(1);
        const file_name = file_path.split("/").pop();
        const file = {
          basename: file_name.split(".")[0],
          extension: file_name.split(".").pop().toLowerCase(),
          name: file_name,
          path: file_path
        };
        return file;
      });
      return files2;
    }
    const files = this.obsidian_app.vault.getAllLoadedFiles().filter((file) => {
      const last_slash = file.path.lastIndexOf("/");
      if (last_slash === -1 && rel_path !== "") return false;
      const folder_path = file.path.slice(0, last_slash);
      if (folder_path !== rel_path) return false;
      return true;
    });
    return files;
  }
  // NOTE: currently does not handle hidden files and folders
  async list_recursive(rel_path, opts = {}) {
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    if (rel_path.startsWith("/")) rel_path = rel_path.slice(1);
    if (rel_path.endsWith("/")) rel_path = rel_path.slice(0, -1);
    const files = this.obsidian_app.vault.getAllLoadedFiles().filter((file) => {
      if (file.path.length > 200) {
        this.smart_fs.auto_excluded_files.push(file.path);
        return false;
      }
      if (rel_path !== "" && !file.path.startsWith(rel_path)) return false;
      if (file instanceof this.obsidian.TFile) {
        if (opts.type === "folder") return false;
        file.type = "file";
      } else if (file instanceof this.obsidian.TFolder) {
        if (opts.type === "file") return false;
        delete file.basename;
        delete file.extension;
        file.type = "folder";
      }
      if (this.smart_fs.fs_path) file.path = file.path.replace(this.smart_fs.fs_path, "").slice(1);
      return true;
    });
    return files;
  }
  async list_files(rel_path) {
    return await this.list(rel_path, { type: "file" });
  }
  async list_files_recursive(rel_path) {
    return await this.list_recursive(rel_path, { type: "file" });
  }
  async list_folders(rel_path) {
    return await this.list(rel_path, { type: "folder" });
  }
  async list_folders_recursive(rel_path) {
    return await this.list_recursive(rel_path, { type: "folder" });
  }
  /**
   * Read the contents of a file
   * 
   * @param {string} rel_path - The relative path of the file to read
   * @returns {Promise<string>} The contents of the file
   */
  async read(rel_path, encoding, opts = {}) {
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    if (encoding === "utf-8") {
      if (!opts.no_cache) {
        const tfile = this.obsidian_app.vault.getFileByPath(rel_path);
        if (tfile) return await this.obsidian_app.vault.cachedRead(tfile);
      }
      return await this.obsidian_adapter.read(rel_path);
    }
    if (encoding === "base64") {
      const array_buffer2 = await this.obsidian_adapter.readBinary(rel_path, "base64");
      const base642 = this.obsidian.arrayBufferToBase64(array_buffer2);
      return base642;
    }
    const array_buffer = await this.obsidian_adapter.readBinary(rel_path);
    return array_buffer;
  }
  /**
   * Rename a file or directory
   * 
   * @param {string} old_path - The current path of the file or directory
   * @param {string} new_path - The new path for the file or directory
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async rename(old_path, new_path) {
    if (!old_path.startsWith(this.fs_path)) old_path = this.fs_path + "/" + old_path;
    if (!new_path.startsWith(this.fs_path)) new_path = this.fs_path + "/" + new_path;
    return await this.obsidian_adapter.rename(old_path, new_path);
  }
  /**
   * Remove a file
   * 
   * @param {string} rel_path - The relative path of the file to remove
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async remove(rel_path) {
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    try {
      return await this.obsidian_adapter.remove(rel_path);
    } catch (error) {
      console.warn(`Error removing file: ${rel_path}`, error);
    }
  }
  /**
   * Remove a directory
   * 
   * @param {string} rel_path - The relative path of the directory to remove
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async remove_dir(rel_path, recursive = false) {
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    return await this.obsidian_adapter.rmdir(rel_path, recursive);
  }
  /**
   * Get file or directory information
   * 
   * @param {string} rel_path - The relative path of the file or directory
   * @returns {Promise<Object>} An object containing file or directory information
   */
  async stat(rel_path) {
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    return await this.obsidian_adapter.stat(rel_path);
  }
  /**
   * Write content to a file
   * 
   * @param {string} rel_path - The relative path of the file to write to
   * @param {string} data - The content to write
   * @returns {Promise<void>} A promise that resolves when the operation is complete
   */
  async write(rel_path, data) {
    if (!data) data = "";
    if (!rel_path.startsWith(this.fs_path)) rel_path = this.fs_path + "/" + rel_path;
    const folder_path = rel_path.split("/").slice(0, -1).join("/");
    if (!await this.exists(folder_path)) {
      await this.mkdir(folder_path);
      console.log(`Created folder: ${folder_path}`);
    }
    return await this.obsidian_adapter.write(rel_path, data);
  }
  get_link_target_path(link_path, file_path) {
    return this.obsidian_app.metadataCache.getFirstLinkpathDest(link_path, file_path)?.path;
  }
  get_base_path() {
    return this.obsidian_adapter.basePath;
  }
  get_full_path(rel_path = "") {
    const sep = rel_path.includes("/") ? "/" : "\\";
    return this.get_base_path() + sep + rel_path;
  }
};

// node_modules/smart-view/utils/empty.js
function empty2(elm) {
  const range = document.createRange();
  range.selectNodeContents(elm);
  range.deleteContents();
}

// node_modules/smart-view/utils/replace_html.js
var replace_html2 = /* @__PURE__ */ (() => {
  const cache = /* @__PURE__ */ new Map();
  return (container, html_snippet) => {
    const key = html_snippet.trim();
    let tpl = cache.get(key);
    if (!tpl) {
      tpl = document.createElement("template");
      tpl.innerHTML = key;
      cache.set(key, tpl);
    }
    container.replaceChildren(tpl.content.cloneNode(true));
  };
})();

// node_modules/smart-view/utils/replace_with_fragment.js
var replace_with_fragment2 = (container, html_snippet) => {
  const range = document.createRange();
  const frag = range.createContextualFragment(html_snippet.trim());
  container.replaceChildren(frag);
};

// node_modules/smart-view/utils/safe_inner_html.js
var restricted_re2 = /<(td|th|tr|thead|tbody|tfoot|caption|col|colgroup|option|optgroup|li|dt|dd|source|track)\b/i;
var safe_inner_html2 = (container, html_snippet) => {
  const trimmed = html_snippet.trim();
  (restricted_re2.test(trimmed) ? replace_with_fragment2 : replace_html2)(container, trimmed);
};

// node_modules/smart-view/smart_view.js
var SmartView2 = class {
  /**
   * @constructor
   * @param {object} opts - Additional options or overrides for rendering.
   */
  constructor(opts = {}) {
    this.opts = opts;
    this._adapter = null;
  }
  /**
   * Renders all setting components within a container.
   * @async
   * @param {HTMLElement} container - The container element.
   * @param {Object} opts - Additional options for rendering.
   * @returns {Promise<void>}
   */
  async render_setting_components(container, opts = {}) {
    const components = container.querySelectorAll(".setting-component");
    const promises = [];
    for (const component of components) {
      promises.push(this.render_setting_component(component, opts));
    }
    await Promise.all(promises);
    return container;
  }
  /**
   * Creates a document fragment from HTML string.
   * @param {string} html - The HTML string.
   * @returns {DocumentFragment}
   */
  create_doc_fragment(html) {
    return document.createRange().createContextualFragment(html);
  }
  /**
   * Gets the adapter instance used for rendering (e.g., Obsidian or Node, etc.).
   * @returns {Object} The adapter instance.
   */
  get adapter() {
    if (!this._adapter) {
      if (!this.opts.adapter) {
        throw new Error("No adapter provided to SmartView. Provide a 'smart_view.adapter' in env config.");
      }
      const AdapterClass = this.opts.adapter;
      this._adapter = new AdapterClass(this);
    }
    return this._adapter;
  }
  /**
   * Gets an icon (implemented in the adapter).
   * @param {string} icon_name - Name of the icon to get.
   * @returns {string} The icon HTML string.
   */
  get_icon_html(icon_name) {
    return this.adapter.get_icon_html(icon_name);
  }
  /**
   * Renders a single setting component (implemented in adapter).
   * @async
   * @param {HTMLElement} setting_elm - The DOM element for the setting.
   * @param {Object} opts - Additional options for rendering.
   * @returns {Promise<*>}
   */
  async render_setting_component(setting_elm, opts = {}) {
    return await this.adapter.render_setting_component(setting_elm, opts);
  }
  /**
   * Renders markdown content (implemented in adapter).
   * @param {string} markdown - The markdown content.
   * @param {object|null} scope - The scope to pass for rendering.
   * @returns {Promise<DocumentFragment>}
   */
  async render_markdown(markdown, scope = null) {
    return await this.adapter.render_markdown(markdown, scope);
  }
  /**
   * Gets a value from an object by path.
   * @param {Object} obj - The object to search in.
   * @param {string} path - The path to the value.
   * @returns {*}
   */
  get_by_path(obj, path, settings_scope = null) {
    return get_by_path2(obj, path, settings_scope);
  }
  /**
   * Sets a value in an object by path.
   * @param {Object} obj - The object to modify.
   * @param {string} path - The path to set the value.
   * @param {*} value - The value to set.
   */
  set_by_path(obj, path, value, settings_scope = null) {
    set_by_path2(obj, path, value, settings_scope);
  }
  /**
   * Deletes a value from an object by path.
   * @param {Object} obj - The object to modify.
   * @param {string} path - The path to delete.
   */
  delete_by_path(obj, path, settings_scope = null) {
    delete_by_path2(obj, path, settings_scope);
  }
  /**
   * Escapes HTML special characters in a string.
   * @param {string} str - The string to escape.
   * @returns {string} The escaped string.
   */
  escape_html(str) {
    if (typeof str !== "string") return str;
    return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  /**
   * A convenience method to build a setting HTML snippet from a config object.
   * @param {Object} setting_config
   * @returns {string}
   */
  render_setting_html(setting_config) {
    if (setting_config.type === "html") {
      return setting_config.value;
    }
    const attributes = Object.entries(setting_config).map(([attr, value]) => {
      if (attr.includes("class")) return "";
      if (typeof value === "number") return `data-${attr.replace(/_/g, "-")}=${value}`;
      return `data-${attr.replace(/_/g, "-")}="${value}"`;
    }).join("\n");
    return `<div class="setting-component${setting_config.scope_class ? " " + setting_config.scope_class : ""}"
data-setting="${setting_config.setting}"
${attributes}
></div>`;
  }
  /**
   * Renders settings from a config, returning a fragment.
   * @async
   * @param {Object} settings_config
   * @param {Object} opts
   * @returns {Promise<DocumentFragment>}
   */
  async render_settings(settings_config5, opts = {}) {
    const html = Object.entries(settings_config5).map(([setting_key, setting_config]) => {
      if (!setting_config.setting) {
        setting_config.setting = setting_key;
      }
      return this.render_setting_html(setting_config);
    }).join("\n");
    const frag = this.create_doc_fragment(`<div>${html}</div>`);
    return await this.render_setting_components(frag, opts);
  }
  /**
   * @function add_settings_listeners
   * @description
   * Scans the given container for elements that have `data-smart-setting` and attaches
   * a 'change' event listener. On change, it updates the corresponding path in `scope.settings`.
   * 
   * @param {Object} scope - An object containing a `settings` property, where new values will be stored.
   * @param {HTMLElement} [container=document] - The DOM element to scan. Defaults to the entire document.
   */
  add_settings_listeners(scope, container = document) {
    const elements = container.querySelectorAll("[data-smart-setting]");
    elements.forEach((elm) => {
      const path = elm.dataset.smartSetting;
      if (!path) return;
      if (!elm.dataset.listenerAttached) {
        elm.dataset.listenerAttached = "true";
        elm.addEventListener("change", () => {
          let newValue;
          if (elm instanceof HTMLInputElement) {
            if (elm.type === "checkbox") {
              newValue = elm.checked;
            } else if (elm.type === "radio") {
              if (elm.checked) {
                newValue = elm.value;
              } else {
                return;
              }
            } else {
              newValue = elm.value;
            }
          } else if (elm instanceof HTMLSelectElement || elm instanceof HTMLTextAreaElement) {
            newValue = elm.value;
          } else {
            newValue = elm.value ?? elm.textContent;
          }
          this.set_by_path(scope.settings, path, newValue);
        });
      }
    });
  }
  apply_style_sheet(sheet) {
    if ("adoptedStyleSheets" in Document.prototype) {
      document.adoptedStyleSheets = [...document.adoptedStyleSheets, sheet];
    } else {
      const styleEl = document.createElement("style");
      if (sheet.cssRules) {
        styleEl.textContent = Array.from(sheet.cssRules).map((rule) => rule.cssText).join("\n");
      }
      document.head.appendChild(styleEl);
    }
  }
  empty(elm) {
    empty2(elm);
  }
  safe_inner_html(elm, html) {
    safe_inner_html2(elm, html);
  }
};
function get_by_path2(obj, path, settings_scope = null) {
  if (!path) return "";
  const keys = path.split(".");
  if (settings_scope) {
    keys.unshift(settings_scope);
  }
  const finalKey = keys.pop();
  const instance = keys.reduce((acc, key) => acc && acc[key], obj);
  if (instance && typeof instance[finalKey] === "function") {
    return instance[finalKey].bind(instance);
  }
  return instance ? instance[finalKey] : void 0;
}
function set_by_path2(obj, path, value, settings_scope = null) {
  const keys = path.split(".");
  if (settings_scope) {
    keys.unshift(settings_scope);
  }
  const final_key = keys.pop();
  const target = keys.reduce((acc, key) => {
    if (!acc[key] || typeof acc[key] !== "object") {
      acc[key] = {};
    }
    return acc[key];
  }, obj);
  target[final_key] = value;
}
function delete_by_path2(obj, path, settings_scope = null) {
  const keys = path.split(".");
  if (settings_scope) {
    keys.unshift(settings_scope);
  }
  const finalKey = keys.pop();
  const instance = keys.reduce((acc, key) => acc && acc[key], obj);
  if (instance) {
    delete instance[finalKey];
  }
}

// node_modules/smart-view/adapters/_adapter.js
var SmartViewAdapter2 = class {
  constructor(main) {
    this.main = main;
  }
  // NECESSARY OVERRIDES
  /**
   * Retrieves the class used for settings.
   * Must be overridden by subclasses to return the appropriate setting class.
   * @abstract
   * @returns {Function} The setting class constructor.
   * @throws Will throw an error if not implemented in the subclass.
   */
  get setting_class() {
    throw new Error("setting_class() not implemented");
  }
  /**
   * Generates the HTML for a specified icon.
   * Must be overridden by subclasses to provide the correct icon HTML.
   * @abstract
   * @param {string} icon_name - The name of the icon to generate HTML for.
   * @returns {string} The HTML string representing the icon.
   * @throws Will throw an error if not implemented in the subclass.
   */
  get_icon_html(icon_name) {
    throw new Error("get_icon_html() not implemented");
  }
  /**
   * Renders Markdown content within a specific scope.
   * Must be overridden by subclasses to handle Markdown rendering appropriately.
   * @abstract
   * @param {string} markdown - The Markdown content to render.
   * @param {object|null} [scope=null] - The scope within which to render the Markdown.
   * @returns {Promise<void>} A promise that resolves when rendering is complete.
   * @throws Will throw an error if not implemented in the subclass.
   */
  async render_markdown(markdown, scope = null) {
    throw new Error("render_markdown() not implemented");
  }
  /**
   * Opens a specified URL.
   * Should be overridden by subclasses to define how URLs are opened.
   * @abstract
   * @param {string} url - The URL to open.
   */
  open_url(url) {
    throw new Error("open_url() not implemented");
  }
  /**
   * Handles the selection of a folder by invoking the folder selection dialog and updating the setting.
   * @abstract
   * @param {string} setting - The path of the setting being modified.
   * @param {string} value - The current value of the setting.
   * @param {HTMLElement} elm - The HTML element associated with the setting.
   * @param {object} scope - The current scope containing settings and actions.
   */
  handle_folder_select(path, value, elm, scope) {
    throw new Error("handle_folder_select not implemented");
  }
  /**
   * Handles the selection of a file by invoking the file selection dialog and updating the setting.
   * @abstract
   * @param {string} setting - The path of the setting being modified.
   * @param {string} value - The current value of the setting.
   * @param {HTMLElement} elm - The HTML element associated with the setting.
   * @param {object} scope - The current scope containing settings and actions.
   */
  handle_file_select(path, value, elm, scope) {
    throw new Error("handle_file_select not implemented");
  }
  /**
   * Performs actions before a setting is changed, such as clearing notices and updating the UI.
   * @abstract
   * @param {string} setting - The path of the setting being changed.
   * @param {*} value - The new value for the setting.
   * @param {HTMLElement} elm - The HTML element associated with the setting.
   * @param {object} scope - The current scope containing settings and actions.
   */
  pre_change(path, value, elm) {
  }
  /**
   * Performs actions after a setting is changed, such as updating UI elements.
   * @abstract
   * @param {string} setting - The path of the setting that was changed.
   * @param {*} value - The new value for the setting.
   * @param {HTMLElement} elm - The HTML element associated with the setting.
   * @param {object} changed - Additional information about the change.
   */
  post_change(path, value, elm) {
  }
  /**
   * Reverts a setting to its previous value in case of validation failure or error.
   * @abstract
   * @param {string} setting - The path of the setting to revert.
   * @param {HTMLElement} elm - The HTML element associated with the setting.
   * @param {object} scope - The current scope containing settings.
   */
  revert_setting(path, elm, scope) {
    console.warn("revert_setting() not implemented");
  }
  // DEFAULT IMPLEMENTATIONS (may be overridden)
  get setting_renderers() {
    return {
      text: this.render_text_component,
      string: this.render_text_component,
      password: this.render_password_component,
      number: this.render_number_component,
      dropdown: this.render_dropdown_component,
      toggle: this.render_toggle_component,
      textarea: this.render_textarea_component,
      textarea_array: this.render_textarea_array_component,
      button: this.render_button_component,
      remove: this.render_remove_component,
      folder: this.render_folder_select_component,
      "text-file": this.render_file_select_component,
      file: this.render_file_select_component,
      slider: this.render_slider_component,
      html: this.render_html_component,
      button_with_confirm: this.render_button_with_confirm_component
    };
  }
  async render_setting_component(elm, opts = {}) {
    this.empty(elm);
    const path = elm.dataset.setting;
    const scope = opts.scope || this.main.main;
    const settings_scope = opts.settings_scope || null;
    try {
      let value = elm.dataset.value ?? this.main.get_by_path(scope.settings, path, settings_scope);
      if (typeof value === "undefined" && typeof elm.dataset.default !== "undefined") {
        value = elm.dataset.default;
        if (typeof value === "string") value = value.toLowerCase() === "true" ? true : value === "false" ? false : value;
        this.main.set_by_path(scope.settings, path, value, settings_scope);
      }
      const renderer = this.setting_renderers[elm.dataset.type];
      if (!renderer) {
        console.warn(`Unsupported setting type: ${elm.dataset.type}`);
        return elm;
      }
      const setting = renderer.call(this, elm, path, value, scope, settings_scope);
      if (elm.dataset.name) setting.setName(elm.dataset.name);
      if (elm.dataset.description) {
        const frag = this.main.create_doc_fragment(`<span>${elm.dataset.description}</span>`);
        setting.setDesc(frag);
      }
      if (elm.dataset.tooltip) setting.setTooltip(elm.dataset.tooltip);
      this.add_button_if_needed(setting, elm, path, scope);
      this.handle_disabled_and_hidden(elm);
      return elm;
    } catch (e) {
      console.error(JSON.stringify({ path, elm }, null, 2));
      console.error(JSON.stringify(e, null, 2));
    }
  }
  render_dropdown_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    let options;
    if (elm.dataset.optionsCallback) {
      console.log(`getting options callback: ${elm.dataset.optionsCallback}`);
      const opts_callback = this.main.get_by_path(scope, elm.dataset.optionsCallback);
      if (typeof opts_callback === "function") options = opts_callback();
      else console.warn(`optionsCallback is not a function: ${elm.dataset.optionsCallback}`, scope);
    }
    if (!options || !options.length) {
      options = this.get_dropdown_options(elm);
    }
    smart_setting.addDropdown((dropdown) => {
      if (elm.dataset.required) dropdown.inputEl.setAttribute("required", true);
      options.forEach((option) => {
        const opt = dropdown.addOption(option.value, option.name ?? option.value);
        opt.selected = option.value === value;
      });
      dropdown.onChange((value2) => {
        this.handle_on_change(path, value2, elm, scope, settings_scope);
      });
      dropdown.setValue(value);
    });
    return smart_setting;
  }
  render_text_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addText((text) => {
      text.setPlaceholder(elm.dataset.placeholder || "");
      if (value) text.setValue(value);
      let debounceTimer;
      if (elm.dataset.button) {
        smart_setting.addButton((button) => {
          button.setButtonText(elm.dataset.button);
          button.onClick(async () => this.handle_on_change(path, text.getValue(), elm, scope));
        });
      } else {
        text.onChange(async (value2) => {
          clearTimeout(debounceTimer);
          debounceTimer = setTimeout(() => this.handle_on_change(path, value2.trim(), elm, scope, settings_scope), 2e3);
        });
      }
    });
    return smart_setting;
  }
  render_password_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addText((text) => {
      text.inputEl.type = "password";
      text.setPlaceholder(elm.dataset.placeholder || "");
      if (value) text.setValue(value);
      let debounceTimer;
      text.onChange(async (value2) => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => this.handle_on_change(path, value2, elm, scope, settings_scope), 2e3);
      });
    });
    return smart_setting;
  }
  render_number_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addText((number) => {
      number.inputEl.type = "number";
      number.setPlaceholder(elm.dataset.placeholder || "");
      if (typeof value !== "undefined") number.inputEl.value = parseInt(value);
      number.inputEl.min = elm.dataset.min || 0;
      if (elm.dataset.max) number.inputEl.max = elm.dataset.max;
      let debounceTimer;
      number.onChange(async (value2) => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => this.handle_on_change(path, parseInt(value2), elm, scope, settings_scope), 2e3);
      });
    });
    return smart_setting;
  }
  render_toggle_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addToggle((toggle) => {
      let checkbox_val = value ?? false;
      if (typeof checkbox_val === "string") {
        checkbox_val = checkbox_val.toLowerCase() === "true";
      }
      toggle.setValue(checkbox_val);
      toggle.onChange(async (value2) => this.handle_on_change(path, value2, elm, scope, settings_scope));
    });
    return smart_setting;
  }
  render_textarea_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addTextArea((textarea) => {
      textarea.setPlaceholder(elm.dataset.placeholder || "");
      textarea.setValue(value || "");
      let debounceTimer;
      textarea.onChange(async (value2) => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => this.handle_on_change(path, value2, elm, scope, settings_scope), 2e3);
      });
    });
    return smart_setting;
  }
  render_textarea_array_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addTextArea((textarea) => {
      textarea.setPlaceholder(elm.dataset.placeholder || "");
      textarea.setValue(Array.isArray(value) ? value.join("\n") : value || "");
      let debounceTimer;
      textarea.onChange(async (value2) => {
        value2 = value2.split("\n").map((v) => v.trim()).filter((v) => v);
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => this.handle_on_change(path, value2, elm, scope, settings_scope), 2e3);
      });
    });
    return smart_setting;
  }
  render_button_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addButton((button) => {
      button.setButtonText(elm.dataset.btnText || elm.dataset.name);
      button.onClick(async () => {
        if (elm.dataset.confirm && !confirm(elm.dataset.confirm)) return;
        if (elm.dataset.href) this.open_url(elm.dataset.href);
        if (elm.dataset.callback) {
          const callback = this.main.get_by_path(scope, elm.dataset.callback);
          if (callback) callback(path, value, elm, scope, settings_scope);
        }
      });
    });
    return smart_setting;
  }
  render_remove_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addButton((button) => {
      button.setButtonText(elm.dataset.btnText || elm.dataset.name || "Remove");
      button.onClick(async () => {
        this.main.delete_by_path(scope.settings, path, settings_scope);
        if (elm.dataset.callback) {
          const callback = this.main.get_by_path(scope, elm.dataset.callback);
          if (callback) callback(path, value, elm, scope, settings_scope);
        }
      });
    });
    return smart_setting;
  }
  render_folder_select_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addFolderSelect((folder_select) => {
      folder_select.setPlaceholder(elm.dataset.placeholder || "");
      if (value) folder_select.setValue(value);
      folder_select.inputEl.closest("div").addEventListener("click", () => {
        this.handle_folder_select(path, value, elm, scope);
      });
      folder_select.inputEl.querySelector("input").addEventListener("change", (e) => {
        const folder = e.target.value;
        this.handle_on_change(path, folder, elm, scope, settings_scope);
      });
    });
    return smart_setting;
  }
  render_file_select_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addFileSelect((file_select) => {
      file_select.setPlaceholder(elm.dataset.placeholder || "");
      if (value) file_select.setValue(value);
      file_select.inputEl.closest("div").addEventListener("click", () => {
        this.handle_file_select(path, value, elm, scope, settings_scope);
      });
    });
    return smart_setting;
  }
  render_slider_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addSlider((slider) => {
      const min = parseFloat(elm.dataset.min) || 0;
      const max = parseFloat(elm.dataset.max) || 100;
      const step = parseFloat(elm.dataset.step) || 1;
      const currentValue = typeof value !== "undefined" ? parseFloat(value) : min;
      slider.setLimits(min, max, step);
      slider.setValue(currentValue);
      slider.onChange((newVal) => {
        const numericVal = parseFloat(newVal);
        this.handle_on_change(path, numericVal, elm, scope, settings_scope);
      });
    });
    return smart_setting;
  }
  render_html_component(elm, path, value, scope) {
    this.safe_inner_html(elm, value);
    return elm;
  }
  add_button_if_needed(smart_setting, elm, path, scope) {
    if (elm.dataset.btn) {
      smart_setting.addButton((button) => {
        button.setButtonText(elm.dataset.btn);
        button.inputEl.addEventListener("click", (e) => {
          if (elm.dataset.btnCallback && typeof scope[elm.dataset.btnCallback] === "function") {
            if (elm.dataset.btnCallbackArg) scope[elm.dataset.btnCallback](elm.dataset.btnCallbackArg);
            else scope[elm.dataset.btnCallback](path, null, smart_setting, scope);
          } else if (elm.dataset.btnHref) {
            this.open_url(elm.dataset.btnHref);
          } else if (elm.dataset.callback && typeof this.main.get_by_path(scope, elm.dataset.callback) === "function") {
            this.main.get_by_path(scope, elm.dataset.callback)(path, null, smart_setting, scope);
          } else if (elm.dataset.href) {
            this.open_url(elm.dataset.href);
          } else {
            console.error("No callback or href found for button.");
          }
        });
        if (elm.dataset.btnDisabled || elm.dataset.disabled && elm.dataset.btnDisabled !== "false") {
          button.inputEl.disabled = true;
        }
      });
    }
  }
  handle_disabled_and_hidden(elm) {
    if (elm.dataset.disabled && elm.dataset.disabled !== "false") {
      elm.classList.add("disabled");
      elm.querySelector("input, select, textarea, button").disabled = true;
    }
    if (elm.dataset.hidden && elm.dataset.hidden !== "false") {
      elm.style.display = "none";
    }
  }
  get_dropdown_options(elm) {
    return Object.entries(elm.dataset).reduce((acc, [k, v]) => {
      if (!k.startsWith("option")) return acc;
      const [value, name] = v.split("|");
      acc.push({ value, name: name || value });
      return acc;
    }, []);
  }
  handle_on_change(path, value, elm, scope, settings_scope) {
    this.pre_change(path, value, elm, scope);
    if (elm.dataset.validate) {
      const valid = this[elm.dataset.validate](path, value, elm, scope);
      if (!valid) {
        elm.querySelector(".setting-item").style.border = "2px solid red";
        this.revert_setting(path, elm, scope);
        return;
      }
    }
    this.main.set_by_path(scope.settings, path, value, settings_scope);
    if (elm.dataset.callback) {
      const callback = this.main.get_by_path(scope, elm.dataset.callback);
      if (callback) callback(path, value, elm, scope);
    }
    this.post_change(path, value, elm, scope);
  }
  render_button_with_confirm_component(elm, path, value, scope) {
    const smart_setting = new this.setting_class(elm);
    smart_setting.addButton((button) => {
      button.setButtonText(elm.dataset.btnText || elm.dataset.name);
      elm.appendChild(this.main.create_doc_fragment(`
        <div class="sc-inline-confirm-row" style="
          display: none;
        ">
          <span style="margin-right: 10px;">
            ${elm.dataset.confirm || "Are you sure?"}
          </span>
          <span class="sc-inline-confirm-row-buttons">
            <button class="sc-inline-confirm-yes">Yes</button>
            <button class="sc-inline-confirm-cancel">Cancel</button>
          </span>
        </div>
      `));
      const confirm_row = elm.querySelector(".sc-inline-confirm-row");
      const confirm_yes = confirm_row.querySelector(".sc-inline-confirm-yes");
      const confirm_cancel = confirm_row.querySelector(".sc-inline-confirm-cancel");
      button.onClick(async () => {
        confirm_row.style.display = "block";
        elm.querySelector(".setting-item").style.display = "none";
      });
      confirm_yes.addEventListener("click", async () => {
        if (elm.dataset.href) this.open_url(elm.dataset.href);
        if (elm.dataset.callback) {
          const callback = this.main.get_by_path(scope, elm.dataset.callback);
          if (callback) callback(path, value, elm, scope);
        }
        elm.querySelector(".setting-item").style.display = "block";
        confirm_row.style.display = "none";
      });
      confirm_cancel.addEventListener("click", () => {
        confirm_row.style.display = "none";
        elm.querySelector(".setting-item").style.display = "block";
      });
    });
    return smart_setting;
  }
  empty(elm) {
    empty2(elm);
  }
  safe_inner_html(elm, html) {
    safe_inner_html2(elm, html);
  }
};

// node_modules/smart-view/adapters/obsidian.js
var import_obsidian21 = require("obsidian");
var SmartViewObsidianAdapter2 = class extends SmartViewAdapter2 {
  get setting_class() {
    return import_obsidian21.Setting;
  }
  open_url(url) {
    window.open(url);
  }
  async render_file_select_component(elm, path, value) {
    return super.render_text_component(elm, path, value);
  }
  async render_markdown(markdown, scope) {
    const component = scope.env.smart_connections_plugin?.connections_view || new import_obsidian21.Component();
    if (!scope) return console.warn("Scope required for rendering markdown in Obsidian adapter");
    const frag = this.main.create_doc_fragment("<div><div class='inner'></div></div>");
    const container = frag.querySelector(".inner");
    try {
      await import_obsidian21.MarkdownRenderer.render(
        scope.env.plugin.app,
        markdown,
        container,
        scope?.file_path || "",
        component
      );
    } catch (e) {
      console.warn("Error rendering markdown in Obsidian adapter", e);
    }
    return frag;
  }
  get_icon_html(name) {
    return (0, import_obsidian21.getIcon)(name).outerHTML;
  }
  // Obsidian Specific
  is_mod_event(event) {
    return import_obsidian21.Keymap.isModEvent(event);
  }
  render_folder_select_component(elm, path, value, scope, settings_scope) {
    const smart_setting = new this.setting_class(elm);
    const folders = scope.env.plugin.app.vault.getAllFolders().sort((a, b) => a.path.localeCompare(b.path));
    smart_setting.addDropdown((dropdown) => {
      if (elm.dataset.required) dropdown.inputEl.setAttribute("required", true);
      dropdown.addOption("", "No folder selected");
      folders.forEach((folder) => {
        dropdown.addOption(folder.path, folder.path);
      });
      dropdown.onChange((value2) => {
        this.handle_on_change(path, value2, elm, scope, settings_scope);
      });
      dropdown.setValue(value);
    });
    return smart_setting;
  }
};

// node_modules/smart-collections/components/settings.js
async function render13(scope, opts = {}) {
  const html = Object.entries(scope.settings_config).map(([setting_key, setting_config]) => {
    if (!setting_config.setting) setting_config.setting = setting_key;
    return this.render_setting_html(setting_config);
  }).join("\n");
  const heading_html = `<h2>${scope.collection_key.split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ")} Settings</h2>`;
  const frag = this.create_doc_fragment(heading_html + html);
  return await post_process12.call(this, scope, frag, opts);
}
async function post_process12(scope, frag, opts = {}) {
  await this.render_setting_components(frag, { scope });
  return frag;
}

// node_modules/smart-model/components/settings.js
async function render14(scope, opts = {}) {
  const html = Object.entries(scope.settings_config).map(([setting_key, setting_config]) => {
    if (!setting_config.setting) setting_config.setting = setting_key;
    return this.render_setting_html(setting_config);
  }).join("\n");
  const frag = this.create_doc_fragment(html);
  return await post_process13.call(this, scope, frag, opts);
}
async function post_process13(scope, frag, opts = {}) {
  await this.render_setting_components(frag, { scope });
  return frag;
}

// node_modules/obsidian-smart-env/modals/story.js
var import_obsidian22 = require("obsidian");
var StoryModal = class _StoryModal extends import_obsidian22.Modal {
  constructor(plugin, { title, url }) {
    super(plugin.app);
    this.plugin = plugin;
    this.title = title;
    this.url = url;
  }
  static open(plugin, story_url) {
    const modal = new _StoryModal(plugin, story_url);
    modal.open();
  }
  onOpen() {
    this.titleEl.setText(this.title);
    this.modalEl.addClass("sc-story-modal");
    const container = this.contentEl.createEl("div", {
      cls: "sc-story-container"
    });
    if (import_obsidian22.Platform.isMobile) {
      const btn = container.createEl("button", { text: "Open in browser" });
      btn.addEventListener("click", () => {
        open_url_externally(this.plugin, this.url);
        this.close();
      });
      return;
    } else {
      const webview = container.createEl("webview", {
        attr: { src: this.url, allowpopups: "" }
      });
      webview.style.width = "100%";
      webview.style.height = "100%";
      webview.addEventListener("did-navigate", (event) => {
        const new_url = event.url || webview.getAttribute("src");
        if (new_url && new_url !== this.url) {
          open_url_externally(this.plugin, new_url);
          this.close();
        }
      });
    }
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/components/connections.js
function build_top_bar_buttons(view_env) {
  const expanded_view = view_env.settings.smart_view_filter.expanded_view ?? view_env.settings.expanded_view;
  const buttons = [
    { title: "Refresh", icon: "refresh-cw" },
    { title: "Fold all toggle", icon: expanded_view ? "fold-vertical" : "unfold-vertical" },
    { title: "Lookup", icon: "search" },
    { title: "Settings", icon: "settings" },
    { title: "Help", icon: "help-circle" }
  ];
  return buttons.map(
    (btn) => `
    <button title="${btn.title}" aria-label="${btn.title} button">
      ${this.get_icon_html(btn.icon)}
    </button>`
  ).join("");
}
async function build_html11(entity, opts = {}) {
  const top_bar_buttons = build_top_bar_buttons.call(this, entity.env);
  return `<div><div class="sc-connections-view">
    <div class="sc-top-bar">
      <p class="sc-context" data-key="">Loading\u2026</p>
      ${top_bar_buttons}
    </div>
    <div class="sc-list"></div>
    <div class="sc-bottom-bar">
      <span class="sc-context" data-key="" title="Loading context\u2026">Loading context\u2026</span>
      ${opts.attribution || ""}
    </div>
  </div></div>`;
}
async function render15(entity, opts = {}) {
  const html = await build_html11.call(this, entity, opts);
  const frag = this.create_doc_fragment(html);
  const container = frag.querySelector(".sc-connections-view");
  post_process14.call(this, entity, container, opts);
  return container;
}
async function post_process14(entity, container, opts = {}) {
  const plugin = entity.env.smart_connections_plugin;
  const list_el = container.querySelector(".sc-list");
  const header_ctx = container.querySelector(".sc-top-bar .sc-context");
  const footer_ctx = container.querySelector(".sc-bottom-bar .sc-context");
  const filter_settings = entity.env.settings.smart_view_filter;
  const render_results = async () => {
    const exclude_keys = Object.keys(entity.data.hidden_connections || {});
    const results = await entity.find_connections({
      exclude_key_ends_with: "---frontmatter---",
      exclude_blocks_from_source_connections: filter_settings.exclude_blocks_from_source_connections ?? false,
      exclude_keys,
      ...opts.filter || {}
    });
    const results_frag = await entity.env.render_component(
      "connections_results",
      results,
      opts
    );
    this.empty(list_el);
    Array.from(results_frag.children).forEach((el) => list_el.appendChild(el));
    header_ctx.innerText = entity.path.split("/").pop();
    footer_ctx.innerText = entity.path.split("/").pop();
    header_ctx.dataset.key = entity.key;
    footer_ctx.dataset.key = entity.key;
    list_el.dataset.key = entity.key;
  };
  if (entity.vec) {
    await render_results();
  } else {
    list_el.createEl("p", {
      text: "This source is not embedded. Check your Smart Environment settings. For example, the current content may be less than the minimum embedding size.",
      cls: "sc-warning"
    });
    const inspect_btn = list_el.createEl("button", {
      text: "Inspect Source",
      cls: "sc-inspect-source-btn",
      title: "Inspect source details"
    });
    inspect_btn.addEventListener("click", async () => {
      new SmartNoteInspectModal(plugin, entity).open();
    });
  }
  const toggle_btn = container.querySelector('[title="Fold all toggle"]');
  toggle_btn.addEventListener("click", () => {
    const expanded = entity.env.settings.smart_view_filter.expanded_view ?? entity.env.settings.expanded_view;
    entity.env.settings.smart_view_filter.expanded_view = !expanded;
    list_el.querySelectorAll(".sc-result").forEach(
      (elm) => expanded ? elm.classList.add("sc-collapsed") : elm.classList.remove("sc-collapsed")
    );
    this.safe_inner_html(
      toggle_btn,
      this.get_icon_html(expanded ? "unfold-vertical" : "fold-vertical")
    );
  });
  const refresh_btn = container.querySelector('[title="Refresh"]');
  refresh_btn.addEventListener("click", async () => {
    await entity.read();
    entity.queue_import();
    await entity.collection.process_source_import_queue?.();
    await render_results();
  });
  container.querySelector('[title="Lookup"]')?.addEventListener("click", () => plugin.open_lookup_view());
  container.querySelector('[title="Help"]')?.addEventListener(
    "click",
    () => StoryModal.open(plugin, {
      title: "Getting Started With Smart Connections",
      url: "https://smartconnections.app/story/smart-connections-getting-started/?utm_source=connections-view-help#page=understanding-connections-1"
    })
  );
  container.querySelector('[title="Settings"]')?.addEventListener("click", async () => {
    await app.setting.open();
    await app.setting.openTabById("smart-connections");
  });
  if (!filter_settings.render_markdown) list_el.classList.add("sc-result-plaintext");
  container.querySelectorAll(".sc-context").forEach((el) => {
    el.addEventListener("click", (event) => {
      new SmartNoteInspectModal(plugin, entity).open();
    });
  });
  return container;
}

// src/components/lookup.js
async function build_html12(collection, opts = {}) {
  const expanded_view = collection.env.settings.smart_view_filter?.expanded_view ?? collection.env.settings.expanded_view;
  return `<div id="sc-lookup-view">
    <div class="sc-top-bar">
      <button class="sc-fold-toggle">${this.get_icon_html(expanded_view ? "fold-vertical" : "unfold-vertical")}</button>
    </div>
    <div class="sc-container">
      <h2>Smart Lookup</h2>
      <div class="sc-textarea-container">
        <textarea
          id="query"
          name="query"
          placeholder="Describe what you're looking for (e.g., 'PKM strategies', 'story elements', 'personal AI alignment')"
        ></textarea>
        <div class="sc-textarea-btn-container">
          <button class="send-button">${this.get_icon_html("search")}</button>
        </div>
      </div>
      <p>Use semantic (embeddings) search to surface relevant notes. Results are sorted by similarity to your query. Note: returns different results than lexical (keyword) search.</p>
    </div>
    <div class="sc-list">
    </div>
    <div class="sc-bottom-bar">
      ${opts.attribution || ""}
    </div>
  </div>`;
}
async function render16(collection, opts = {}) {
  let html = await build_html12.call(this, collection, opts);
  const frag = this.create_doc_fragment(html);
  return await post_process15.call(this, collection, frag, opts);
}
async function post_process15(collection, frag, opts = {}) {
  const query_input = frag.querySelector("#query");
  const results_container = frag.querySelector(".sc-list");
  const render_lookup = async (query, results_container2) => {
    const lookup_params = {
      hypotheticals: [query],
      filter: opts.filter
    };
    const results = await collection.lookup(lookup_params);
    this.empty(results_container2);
    const results_frag = await collection.env.render_component("connections_results", results, opts);
    Array.from(results_frag.children).forEach((elm) => results_container2.appendChild(elm));
  };
  let timeout;
  query_input.addEventListener("input", (event) => {
    clearTimeout(timeout);
    const query = event.target.value.trim();
    if (query) {
      timeout = setTimeout(async () => {
        await render_lookup(query, results_container);
      }, 500);
    }
  });
  if (opts.query) {
    query_input.value = opts.query;
    await render_lookup(opts.query, results_container);
  }
  const send_button = frag.querySelector(".send-button");
  send_button.addEventListener("click", async (event) => {
    clearTimeout(timeout);
    const query = query_input.value.trim();
    if (query) {
      await render_lookup(query, results_container);
    }
  });
  const fold_toggle = frag.querySelector(".sc-fold-toggle");
  fold_toggle.addEventListener("click", async (event) => {
    const container = event.target.closest("#sc-lookup-view");
    const expanded = collection.env.settings.smart_view_filter?.expanded_view ?? collection.env.settings.expanded_view;
    const results = container.querySelectorAll(".sc-result");
    for (const elm of results) {
      if (expanded) {
        elm.classList.add("sc-collapsed");
      } else {
        elm.click();
      }
    }
    if (!collection.settings.smart_view_filter) collection.settings.smart_view_filter = {};
    collection.settings.smart_view_filter.expanded_view = !expanded;
    const updated_expanded_view = collection.settings.smart_view_filter.expanded_view;
    this.safe_inner_html(fold_toggle, this.get_icon_html(updated_expanded_view ? "fold-vertical" : "unfold-vertical"));
    fold_toggle.setAttribute("aria-label", updated_expanded_view ? "Fold all" : "Unfold all");
  });
  return frag;
}

// src/components/connections_results.js
async function build_html13(results, opts = {}) {
  return ``;
}
async function render17(results, opts = {}) {
  const html = await build_html13.call(this, results, opts);
  const frag = this.create_doc_fragment(html);
  if (!results || !Array.isArray(results) || results.length === 0) {
    const no_results = this.create_doc_fragment(`<p class="sc-no-results">No results found.<br><em>Try using the refresh button. If that doesn't work, try running "Clear sources data" and then "Reload sources" in the Smart Environment settings.</em></p>`);
    frag.appendChild(no_results);
    return frag;
  }
  const result_frags = await Promise.all(results.map((result) => {
    return result.item.env.render_component("connections_result", result, { ...opts });
  }));
  result_frags.forEach((result_frag) => frag.appendChild(result_frag));
  return frag;
}

// src/views/smart_chat.js
function build_html14(obsidian_view, opts = {}) {
  const top_bar_buttons = [
    // { title: 'Open Conversation Note', icon: 'external-link' },
    { title: "New Chat", icon: "plus" },
    { title: "Chat History", icon: "history" },
    { title: "Chat Options", icon: "sliders-horizontal", style: "display: none;" },
    { title: "Chat Settings", icon: "settings" },
    { title: "Help", icon: "help-circle" }
  ].map((btn) => `
    <button title="${btn.title}" ${btn.style ? `style="${btn.style}"` : ""}>
      ${this.get_icon_html(btn.icon)}
    </button>
  `).join("");
  return `
    <div class="sc-chat-container">
      <div class="sc-top-bar-container">
        <input class="sc-chat-name-input" type="text" value="" placeholder="Add name to save this chat">
        ${top_bar_buttons}
      </div>
      <div id="settings" class="smart-chat-overlay" style="display: none;">
        <div class="smart-chat-overlay-header">
          <button class="smart-chat-overlay-close">
            ${this.get_icon_html("x")}
          </button>
        </div>
        <div class="sc-settings"></div>
      </div>
      <div class="sc-thread">
        <!-- Thread messages will be inserted here -->
      </div>
    </div>
    ${obsidian_view.attribution || ""}
  `;
}
async function render18(obsidian_view, opts = {}) {
  const html = build_html14.call(this, obsidian_view, opts);
  const frag = this.create_doc_fragment(html);
  return await post_process16.call(this, obsidian_view, frag, opts);
}
async function post_process16(obsidian_view, frag, opts) {
  const chat_box = frag.querySelector(".sc-thread");
  const settings_button = frag.querySelector('button[title="Chat Settings"]');
  const overlay_container = frag.querySelector(".smart-chat-overlay");
  const settings_container = overlay_container.querySelector(".sc-settings");
  while (!obsidian_view.env.smart_threads) {
    await new Promise((resolve) => setTimeout(resolve, 300));
  }
  const threads_collection = obsidian_view.env.smart_threads;
  threads_collection.container = frag.querySelector(".sc-chat-container");
  let thread;
  if (opts.thread_key) {
    thread = threads_collection.get(opts.thread_key);
  }
  if (!thread) thread = threads_collection.get_active_thread();
  if (!thread) {
    thread = await threads_collection.create_or_update({});
  }
  chat_box.setAttribute("data-thread-key", thread.key);
  await thread.render(chat_box, opts);
  const chat_input = frag.querySelector(".sc-chat-form textarea");
  if (chat_input) {
    chat_input.addEventListener("keydown", obsidian_view.handle_chat_input_keydown.bind(obsidian_view));
  }
  const close_button = overlay_container.querySelector(".smart-chat-overlay-close");
  if (close_button) {
    close_button.addEventListener("click", () => {
      overlay_container.style.display = "none";
    });
  }
  settings_button.addEventListener("click", () => {
    if (overlay_container.style.display === "none") {
      threads_collection.render_settings(settings_container);
      overlay_container.style.display = "block";
    } else {
      overlay_container.style.display = "none";
    }
  });
  const help_button = frag.querySelector("[title='Help']");
  help_button.addEventListener("click", () => {
    window.open("https://docs.smartconnections.app/smart-chat", "_blank");
  });
  const new_chat_button = frag.querySelector('button[title="New Chat"]');
  new_chat_button.addEventListener("click", async () => {
    this.empty(threads_collection.container);
    opts.thread_key = null;
    obsidian_view.render_view();
  });
  const chat_history_button = frag.querySelector('button[title="Chat History"]');
  chat_history_button.addEventListener("click", () => {
    obsidian_view.open_chat_history();
  });
  setup_chat_name_input_handler.call(this, frag, thread);
  return frag;
}
function setup_chat_name_input_handler(frag, thread) {
  const name_input = frag.querySelector(".sc-chat-name-input");
  if (!name_input) return;
  if (!thread.key.startsWith("Untitled")) {
    name_input.value = thread.key;
  }
  name_input.addEventListener("blur", async () => {
    const new_name = name_input.value.trim();
    if (new_name && new_name !== thread.key) {
      try {
        await thread.rename(new_name);
        console.log(`Thread renamed to "${new_name}"`);
      } catch (error) {
        console.error("Error renaming thread:", error);
        name_input.value = thread.key;
      }
    }
  });
  name_input.addEventListener("keydown", async (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      name_input.blur();
    }
  });
}

// node_modules/smart-model/smart_model.js
var SmartModel2 = class {
  scope_name = "smart_model";
  static defaults = {
    // override in sub-class if needed
  };
  /**
   * Create a SmartModel instance.
   * @param {Object} opts - Configuration options
   * @param {Object} opts.adapters - Map of adapter names to adapter classes
   * @param {Object} opts.settings - Model settings configuration
   * @param {Object} opts.model_config - Model-specific configuration
   * @param {string} opts.model_config.adapter - Name of the adapter to use
   * @param {string} [opts.model_key] - Optional model identifier to override settings
   * @throws {Error} If required options are missing
   */
  constructor(opts = {}) {
    this.opts = opts;
    this.validate_opts(opts);
    this.state = "unloaded";
    this._adapter = null;
  }
  /**
   * Initialize the model by loading the configured adapter.
   * @async
   * @returns {Promise<void>}
   */
  async initialize() {
    this.load_adapter(this.adapter_name);
    await this.load();
  }
  /**
   * Validate required options.
   * @param {Object} opts - Configuration options
   */
  validate_opts(opts) {
    if (!opts.adapters) throw new Error("opts.adapters is required");
    if (!opts.settings) throw new Error("opts.settings is required");
  }
  /**
   * Get the current settings
   * @returns {Object} Current settings
   */
  get settings() {
    if (!this.opts.settings) this.opts.settings = {
      ...this.constructor.defaults
    };
    return this.opts.settings;
  }
  /**
   * Get the current adapter name
   * @returns {string} Current adapter name
   */
  get adapter_name() {
    let adapter_key = this.opts.model_config?.adapter || this.opts.adapter || this.settings.adapter || Object.keys(this.adapters)[0];
    if (!adapter_key || !this.adapters[adapter_key]) {
      console.warn(`Platform "${adapter_key}" not supported`);
      adapter_key = Object.keys(this.adapters)[0];
    }
    return adapter_key;
  }
  /**
   * Get adapter-specific settings.
   * @returns {Object} Settings for current adapter
   */
  get adapter_settings() {
    if (!this.settings[this.adapter_name]) this.settings[this.adapter_name] = {};
    return this.settings[this.adapter_name];
  }
  get adapter_config() {
    const base_config = this.adapters[this.adapter_name]?.defaults || {};
    return {
      ...base_config,
      ...this.adapter_settings,
      ...this.opts.adapter_config
    };
  }
  /**
   * Get available models.
   * @returns {Object} Map of model objects
   */
  get models() {
    return this.adapter.models;
  }
  /**
   * Get default model key.
   * @returns {string} Default model key
   */
  get default_model_key() {
    return this.adapter.constructor.defaults.default_model;
  }
  /**
   * Get the current model key
   * @returns {string} Current model key
   */
  get model_key() {
    return this.opts.model_key || this.adapter_config.model_key || this.settings.model_key || this.default_model_key;
  }
  /**
   * Get the current model configuration
   * @returns {Object} Combined base and custom model configuration
   */
  get model_config() {
    const model_key = this.model_key;
    const base_model_config = this.models[model_key] || {};
    return {
      ...this.adapter_config,
      ...base_model_config,
      ...this.opts.model_config
    };
  }
  get model_settings() {
    if (!this.settings[this.model_key]) this.settings[this.model_key] = {};
    return this.settings[this.model_key];
  }
  /**
   * Load the current adapter and transition to loaded state.
   * @async
   * @returns {Promise<void>}
   */
  async load() {
    this.set_state("loading");
    try {
      if (!this.adapter?.is_loaded) {
        await this.invoke_adapter_method("load");
      }
    } catch (err) {
      this.set_state("unloaded");
      if (!this.reload_model_timeout) {
        this.reload_model_timeout = setTimeout(async () => {
          this.reload_model_timeout = null;
          await this.load();
          this.set_state("loaded");
          this.notices?.show("Loaded model: " + this.model_key);
        }, 6e4);
      }
      throw new Error(`Failed to load model: ${err.message}`);
    }
    this.set_state("loaded");
  }
  /**
   * Unload the current adapter and transition to unloaded state.
   * @async
   * @returns {Promise<void>}
   */
  async unload() {
    if (this.adapter?.is_loaded) {
      this.set_state("unloading");
      await this.invoke_adapter_method("unload");
      this.set_state("unloaded");
    }
  }
  /**
   * Set the model's state.
   * @param {('unloaded'|'loading'|'loaded'|'unloading')} new_state - The new state
   * @throws {Error} If the state is invalid
   */
  set_state(new_state) {
    const valid_states = ["unloaded", "loading", "loaded", "unloading"];
    if (!valid_states.includes(new_state)) {
      throw new Error(`Invalid state: ${new_state}`);
    }
    this.state = new_state;
  }
  get is_loading() {
    return this.state === "loading";
  }
  get is_loaded() {
    return this.state === "loaded";
  }
  get is_unloading() {
    return this.state === "unloading";
  }
  get is_unloaded() {
    return this.state === "unloaded";
  }
  // ADAPTERS
  /**
   * Get the map of available adapters
   * @returns {Object} Map of adapter names to adapter classes
   */
  get adapters() {
    return this.opts.adapters || {};
  }
  /**
   * Load a specific adapter by name.
   * @async
   * @param {string} adapter_name - Name of the adapter to load
   * @throws {Error} If adapter not found or loading fails
   * @returns {Promise<void>}
   */
  async load_adapter(adapter_name) {
    this.set_adapter(adapter_name);
    if (!this._adapter.loaded) {
      this.set_state("loading");
      try {
        await this.invoke_adapter_method("load");
        this.set_state("loaded");
      } catch (err) {
        this.set_state("unloaded");
        throw new Error(`Failed to load adapter: ${err.message}`);
      }
    }
  }
  /**
   * Set an adapter instance by name without loading it.
   * @param {string} adapter_name - Name of the adapter to set
   * @throws {Error} If adapter not found
   */
  set_adapter(adapter_name) {
    const AdapterClass = this.adapters[adapter_name];
    if (!AdapterClass) {
      throw new Error(`Adapter "${adapter_name}" not found.`);
    }
    if (this._adapter?.constructor.name.toLowerCase() === adapter_name.toLowerCase()) {
      return;
    }
    this._adapter = new AdapterClass(this);
  }
  /**
   * Get the current active adapter instance
   * @returns {Object} The active adapter instance
   * @throws {Error} If adapter not found
   */
  get adapter() {
    const adapter_name = this.adapter_name;
    if (!adapter_name) {
      throw new Error(`Adapter not set for model.`);
    }
    if (!this._adapter) {
      this.load_adapter(adapter_name);
    }
    return this._adapter;
  }
  /**
   * Ensure the adapter is ready to execute a method.
   * @param {string} method - Name of the method to check
   * @throws {Error} If adapter not loaded or method not implemented
   */
  ensure_adapter_ready(method) {
    if (!this.adapter) {
      throw new Error("No adapter loaded.");
    }
    if (typeof this.adapter[method] !== "function") {
      throw new Error(`Adapter does not implement method: ${method}`);
    }
  }
  /**
   * Invoke a method on the current adapter.
   * @async
   * @param {string} method - Name of the method to call
   * @param {...any} args - Arguments to pass to the method
   * @returns {Promise<any>} Result from the adapter method
   * @throws {Error} If adapter not ready or method fails
   */
  async invoke_adapter_method(method, ...args) {
    this.ensure_adapter_ready(method);
    return await this.adapter[method](...args);
  }
  /**
   * Get platforms as dropdown options.
   * @returns {Array<Object>} Array of {value, name} option objects
   */
  get_platforms_as_options() {
    return Object.entries(this.adapters).map(([key, AdapterClass]) => ({ value: key, name: AdapterClass.defaults.description || key }));
  }
  // SETTINGS
  /**
   * Get the settings configuration schema
   * @returns {Object} Settings configuration object
   */
  get settings_config() {
    return this.process_settings_config({
      adapter: {
        name: "Model Platform",
        type: "dropdown",
        description: "Select a model platform to use with Smart Model.",
        options_callback: "get_platforms_as_options",
        is_scope: true,
        // trigger re-render of settings when changed
        callback: "adapter_changed",
        default: "default"
      }
    });
  }
  /**
   * Process settings configuration with conditionals and prefixes.
   * @param {Object} _settings_config - Raw settings configuration
   * @param {string} [prefix] - Optional prefix for setting keys
   * @returns {Object} Processed settings configuration
   */
  process_settings_config(_settings_config, prefix = null) {
    return Object.entries(_settings_config).reduce((acc, [key, val]) => {
      const new_key = (prefix ? prefix + "." : "") + this.process_setting_key(key);
      acc[new_key] = val;
      return acc;
    }, {});
  }
  /**
   * Process an individual setting key.
   * Example: replace placeholders with actual adapter names.
   * @param {string} key - The setting key with placeholders.
   * @returns {string} Processed setting key.
   */
  process_setting_key(key) {
    return key.replace(/\[ADAPTER\]/g, this.adapter_name);
  }
  re_render_settings() {
    if (typeof this.opts.re_render_settings === "function") this.opts.re_render_settings();
    else console.warn("re_render_settings is not a function (must be passed in model opts)");
  }
  /**
   * Reload model.
   */
  reload_model() {
    if (typeof this.opts.reload_model === "function") this.opts.reload_model();
    else console.warn("reload_model is not a function (must be passed in model opts)");
  }
  adapter_changed() {
    this.reload_model();
    this.re_render_settings();
  }
  model_changed() {
    this.reload_model();
    this.re_render_settings();
  }
};

// node_modules/smart-chat-model/smart_chat_model.js
var SmartChatModel2 = class extends SmartModel2 {
  scope_name = "smart_chat_model";
  static defaults = {
    adapter: "openai"
  };
  /**
   * Create a SmartChatModel instance.
   * @param {Object} opts - Configuration options
   * @param {string} opts.adapter - Adapter to use
   * @param {Object} opts.adapters - Map of adapter names to adapter classes
   * @param {Object} opts.settings - Model settings configuration
   */
  constructor(opts = {}) {
    super(opts);
  }
  /**
   * Get available models.
   * @returns {Object} Map of model objects
   */
  get models() {
    return this.adapter.models;
  }
  get can_stream() {
    return this.adapter.constructor.defaults.streaming;
  }
  get can_use_tools() {
    return this.adapter.constructor.defaults.can_use_tools;
  }
  /**
   * Complete a chat request.
   * @param {Object} req - Request parameters
   * @returns {Promise<Object>} Completion result
   */
  async complete(req) {
    return await this.invoke_adapter_method("complete", req);
  }
  /**
   * Stream chat responses.
   * @param {Object} req - Request parameters
   * @param {Object} handlers - Event handlers for streaming
   * @param {Function} handlers.chunk - Handler for chunks: receives response object
   * @param {Function} handlers.error - Handler for errors: receives error object
   * @param {Function} handlers.done - Handler for completion: receives final response object
   * @returns {Promise<string>} Complete response text
   */
  async stream(req, handlers = {}) {
    return await this.invoke_adapter_method("stream", req, handlers);
  }
  /**
   * Stop active stream.
   */
  stop_stream() {
    this.invoke_adapter_method("stop_stream");
  }
  /**
   * Count tokens in input text.
   * @param {string|Object} input - Text to count tokens for
   * @returns {Promise<number>} Token count
   */
  async count_tokens(input) {
    return await this.invoke_adapter_method("count_tokens", input);
  }
  /**
   * Test if API key is valid.
   * @returns {Promise<boolean>} True if API key is valid
   */
  async test_api_key() {
    await this.invoke_adapter_method("test_api_key");
    this.re_render_settings();
  }
  /**
   * Get default model key.
   * @returns {string} Default model key
   */
  get default_model_key() {
    return this.adapter.constructor.defaults.default_model;
  }
  /**
   * Get current settings.
   * @returns {Object} Settings object
   */
  get settings() {
    return this.opts.settings;
  }
  /**
   * Get settings configuration.
   * @returns {Object} Settings configuration object
   */
  get settings_config() {
    const _settings_config = {
      adapter: {
        name: "Chat Model Platform",
        type: "dropdown",
        description: "Select a platform/provider for chat models.",
        options_callback: "get_platforms_as_options",
        is_scope: true,
        // trigger re-render of settings when changed
        callback: "adapter_changed"
      },
      // Merge adapter-specific settings
      ...this.adapter.settings_config || {}
    };
    return this.process_settings_config(_settings_config);
  }
  /**
   * Process setting key.
   * @param {string} key - Setting key
   * @returns {string} Processed key
   */
  process_setting_key(key) {
    return key.replace(/\[CHAT_ADAPTER\]/g, this.adapter_name);
  }
  /**
   * Validate the adapter configuration.
   * @returns {Object} Validation result with 'valid' and 'message'.
   */
  validate_config() {
    return this.adapter.validate_config();
  }
};

// node_modules/smart-http-request/smart_http_request.js
var SmartHttpRequest2 = class {
  /**
   * @param {object} opts - Options for the SmartHttpRequest class
   * @param {SmartHttpRequestAdapter} opts.adapter - The adapter constructor to use for making HTTP requests
   * @param {Obsidian.requestUrl} opts.obsidian_request_adapter - For use with Obsidian adapter
   */
  constructor(opts = {}) {
    this.opts = opts;
    if (!opts.adapter) throw new Error("HttpRequestAdapter is required");
    this.adapter = new opts.adapter(this);
  }
  /**
   * Returns a well-formed response object
   * @param {object} request_params - Parameters for the HTTP request
   * @param {string} request_params.url - The URL to make the request to
   * @param {string} [request_params.method='GET'] - The HTTP method to use
   * @param {object} [request_params.headers] - Headers to include in the request
   * @param {*} [request_params.body] - The body of the request (for POST, PUT, etc.)
   * @returns {SmartHttpResponseAdapter} instance of the SmartHttpResponseAdapter class
   * @example
   * const response = await smart_http_request.request({
   *   url: 'https://api.example.com/data',
   *   method: 'GET',
   *   headers: { 'Content-Type': 'application/json' }
   * });
   * console.log(await response.json());
   */
  async request(request_params) {
    return await this.adapter.request(request_params);
  }
};

// node_modules/smart-http-request/adapters/_adapter.js
var SmartHttpRequestAdapter2 = class {
  constructor(main) {
    this.main = main;
  }
  async request(request_params) {
    throw new Error("request not implemented");
  }
};
var SmartHttpResponseAdapter2 = class {
  constructor(response) {
    this.response = response;
  }
  async headers() {
    throw new Error("headers not implemented");
  }
  async json() {
    throw new Error("json not implemented");
  }
  async status() {
    throw new Error("status not implemented");
  }
  async text() {
    throw new Error("text not implemented");
  }
};

// node_modules/smart-http-request/adapters/obsidian.js
var SmartHttpObsidianRequestAdapter2 = class extends SmartHttpRequestAdapter2 {
  async request(request_params) {
    let response;
    try {
      if (!this.main.opts.obsidian_request_url) {
        throw new Error("obsidian_request_url is required in SmartHttp constructor opts");
      }
      response = await this.main.opts.obsidian_request_url({ ...request_params, throw: false });
      if (response.status === 400) throw new Error("Obsidian request failed");
      return new SmartHttpObsidianResponseAdapter2(response);
    } catch (error) {
      console.error("Error in SmartHttpObsidianRequestAdapter.request():");
      console.error(JSON.stringify(request_params, null, 2));
      console.error(response);
      console.error(error);
      return null;
    }
  }
};
var SmartHttpObsidianResponseAdapter2 = class extends SmartHttpResponseAdapter2 {
  async status() {
    return this.response.status;
  }
  async json() {
    return await this.response.json;
  }
  async text() {
    return await this.response.text;
  }
  async headers() {
    return this.response.headers;
  }
};

// node_modules/smart-http-request/adapters/fetch.js
var SmartHttpRequestFetchAdapter2 = class extends SmartHttpRequestAdapter2 {
  async request(request_params) {
    const { url, ...opts } = request_params;
    const resp = await fetch(url, opts);
    return new SmartHttpResponseFetchAdapter2(resp);
  }
};
var SmartHttpResponseFetchAdapter2 = class extends SmartHttpResponseAdapter2 {
  async headers() {
    return this.response.headers;
  }
  async json() {
    if (!this._json) {
      this._json = await this.response.json();
    }
    return this._json;
  }
  async status() {
    return this.response.status;
  }
  async text() {
    if (!this._text) {
      this._text = await this.response.text();
    }
    return this._text;
  }
};

// node_modules/smart-chat-model/streamer.js
var SmartStreamer2 = class {
  constructor(url, options = {}) {
    const {
      method = "GET",
      headers = {},
      body = null,
      withCredentials = false
    } = options;
    this.url = url;
    this.method = method;
    this.headers = headers;
    this.body = body;
    this.withCredentials = withCredentials;
    this.listeners = {};
    this.readyState = this.CONNECTING;
    this.progress = 0;
    this.chunk = "";
    this.last_event_id = "";
    this.xhr = null;
    this.FIELD_SEPARATOR = ":";
    this.INITIALIZING = -1;
    this.CONNECTING = 0;
    this.OPEN = 1;
    this.CLOSED = 2;
    this.chunk_accumulator = "";
    this.chunk_splitting_regex = options.chunk_splitting_regex || /(\r\n|\n|\r)/g;
  }
  /**
   * Adds an event listener for the specified event type.
   *
   * @param {string} type - The type of the event.
   * @param {Function} listener - The listener function to be called when the event is triggered.
   */
  addEventListener(type, listener) {
    if (!this.listeners[type]) this.listeners[type] = [];
    if (!this.listeners[type].includes(listener)) this.listeners[type].push(listener);
  }
  /**
   * Removes an event listener from the SmartStreamer instance.
   *
   * @param {string} type - The type of event to remove the listener from.
   * @param {Function} listener - The listener function to remove.
   */
  removeEventListener(type, listener) {
    if (!this.listeners[type]) return;
    this.listeners[type] = this.listeners[type].filter((callback) => callback !== listener);
    if (this.listeners[type].length === 0) delete this.listeners[type];
  }
  /**
   * Dispatches an event to the appropriate event handlers.
   *
   * @param {Event} event - The event to be dispatched.
   * @returns {boolean} - Returns true if the event was successfully dispatched, false otherwise.
   */
  dispatchEvent(event) {
    if (!event) return true;
    event.source = this;
    const onHandler = "on" + event.type;
    if (Object.prototype.hasOwnProperty.call(this, onHandler)) {
      this[onHandler].call(this, event);
      if (event.defaultPrevented) return false;
    }
    if (this.listeners[event.type]) {
      this.listeners[event.type].forEach((callback) => {
        callback(event);
        return !event.defaultPrevented;
      });
    }
    return true;
  }
  /**
   * Initiates the streaming process.
   */
  stream() {
    this.#setReadyState(this.CONNECTING);
    this.xhr = new XMLHttpRequest();
    this.xhr.addEventListener("progress", this.#onStreamProgress.bind(this));
    this.xhr.addEventListener("load", this.#onStreamLoaded.bind(this));
    this.xhr.addEventListener("readystatechange", this.#checkStreamClosed.bind(this));
    this.xhr.addEventListener("error", this.#onStreamFailure.bind(this));
    this.xhr.addEventListener("abort", this.#onStreamAbort.bind(this));
    this.xhr.open(this.method, this.url);
    for (const header in this.headers) {
      this.xhr.setRequestHeader(header, this.headers[header]);
    }
    if (this.last_event_id) this.xhr.setRequestHeader("Last-Event-ID", this.last_event_id);
    this.xhr.withCredentials = this.withCredentials;
    this.xhr.send(this.body);
  }
  /**
   * Ends the streamer connection.
   * Aborts the current XHR request and sets the ready state to CLOSED.
   */
  end() {
    if (this.readyState === this.CLOSED) return;
    this.xhr.abort();
    this.xhr = null;
    this.#setReadyState(this.CLOSED);
  }
  // private methods
  #setReadyState(state) {
    const event = new CustomEvent("readyStateChange");
    event.readyState = state;
    this.readyState = state;
    this.dispatchEvent(event);
  }
  #onStreamFailure(e) {
    const event = new CustomEvent("error");
    event.data = e.currentTarget.response;
    this.dispatchEvent(event);
    this.end();
  }
  #onStreamAbort(e) {
    const event = new CustomEvent("abort");
    this.end();
  }
  #onStreamProgress(e) {
    if (!this.xhr) return;
    if (this.xhr.status !== 200) {
      this.#onStreamFailure(e);
      return;
    }
    if (this.readyState === this.CONNECTING) {
      this.dispatchEvent(new CustomEvent("open"));
      this.#setReadyState(this.OPEN);
    }
    const data = this.xhr.responseText.substring(this.progress);
    this.progress += data.length;
    const parts = data.split(this.chunk_splitting_regex);
    parts.forEach((part, index) => {
      if (part.trim().length === 0) {
        if (this.chunk) {
          this.dispatchEvent(this.#parseEventChunk(this.chunk.trim()));
          this.chunk = "";
        }
      } else {
        this.chunk += part;
        if (index === parts.length - 1 && this.xhr.readyState === XMLHttpRequest.DONE) {
          this.dispatchEvent(this.#parseEventChunk(this.chunk.trim()));
          this.chunk = "";
        }
      }
    });
  }
  #onStreamLoaded(e) {
    this.#onStreamProgress(e);
    this.dispatchEvent(this.#parseEventChunk(this.chunk));
    this.chunk = "";
  }
  #parseEventChunk(chunk) {
    if (!chunk) return console.log("no chunk");
    const event = new CustomEvent("message");
    event.data = chunk;
    event.last_event_id = this.last_event_id;
    return event;
  }
  #checkStreamClosed() {
    if (!this.xhr) return;
    if (this.xhr.readyState === XMLHttpRequest.DONE) this.#setReadyState(this.CLOSED);
  }
};

// node_modules/smart-model/adapters/_adapter.js
var SmartModelAdapter2 = class {
  /**
   * Create a SmartModelAdapter instance.
   * @param {SmartModel} model - The parent SmartModel instance
   */
  constructor(model) {
    this.model = model;
    this.state = "unloaded";
  }
  /**
   * Load the adapter.
   * @async
   * @returns {Promise<void>}
   */
  async load() {
    this.set_state("loaded");
  }
  /**
   * Unload the adapter.
   * @returns {void}
   */
  unload() {
    this.set_state("unloaded");
  }
  /**
   * Get all settings.
   * @returns {Object} All settings
   */
  get settings() {
    return this.model.settings;
  }
  /**
   * Get the current model key.
   * @returns {string} Current model identifier
   */
  get model_key() {
    return this.model.model_key;
  }
  /**
   * Get the current model configuration.
   * @returns {Object} Model configuration
   */
  get model_config() {
    return this.model.model_config;
  }
  /**
   * Get model-specific settings.
   * @returns {Object} Settings for current model
   */
  get model_settings() {
    return this.model.model_settings;
  }
  /**
   * Get adapter-specific configuration.
   * @returns {Object} Adapter configuration
   */
  get adapter_config() {
    return this.model.adapter_config;
  }
  /**
   * Get adapter-specific settings.
   * @returns {Object} Adapter settings
   */
  get adapter_settings() {
    return this.model.adapter_settings;
  }
  /**
   * Get the models.
   * @returns {Object} Map of model objects
   */
  get models() {
    if (typeof this.adapter_config.models === "object" && Object.keys(this.adapter_config.models || {}).length > 0) return this.adapter_config.models;
    else {
      return {};
    }
  }
  /**
   * Get available models from the API.
   * @abstract
   * @param {boolean} [refresh=false] - Whether to refresh cached models
   * @returns {Promise<Object>} Map of model objects
   */
  async get_models(refresh = false) {
    throw new Error("get_models not implemented");
  }
  /**
   * Validate the parameters for get_models.
   * @returns {boolean|Array<Object>} True if parameters are valid, otherwise an array of error objects
   */
  validate_get_models_params() {
    return true;
  }
  /**
   * Get available models as dropdown options synchronously.
   * @returns {Array<Object>} Array of model options.
   */
  get_models_as_options() {
    const models = this.models;
    const params_valid = this.validate_get_models_params();
    if (params_valid !== true) return params_valid;
    if (!Object.keys(models || {}).length) {
      this.get_models(true);
      return [{ value: "", name: "No models currently available" }];
    }
    return Object.entries(models).map(([id, model]) => ({ value: id, name: model.name || id })).sort((a, b) => a.name.localeCompare(b.name));
  }
  /**
   * Set the adapter's state.
   * @deprecated should be handled in SmartModel (only handle once)
   * @param {('unloaded'|'loading'|'loaded'|'unloading')} new_state - The new state
   * @throws {Error} If the state is invalid
   */
  set_state(new_state) {
    const valid_states = ["unloaded", "loading", "loaded", "unloading"];
    if (!valid_states.includes(new_state)) {
      throw new Error(`Invalid state: ${new_state}`);
    }
    this.state = new_state;
  }
  // Replace individual state getters/setters with a unified state management
  get is_loading() {
    return this.state === "loading";
  }
  get is_loaded() {
    return this.state === "loaded";
  }
  get is_unloading() {
    return this.state === "unloading";
  }
  get is_unloaded() {
    return this.state === "unloaded";
  }
};

// node_modules/smart-chat-model/adapters/_adapter.js
var SmartChatModelAdapter2 = class extends SmartModelAdapter2 {
  /**
   * @override in sub-class with adapter-specific default configurations
   * @property {string} id - The adapter identifier
   * @property {string} description - Human-readable description
   * @property {string} type - Adapter type ("API")
   * @property {string} endpoint - API endpoint
   * @property {boolean} streaming - Whether streaming is supported
   * @property {string} adapter - Adapter identifier
   * @property {string} models_endpoint - Endpoint for retrieving models
   * @property {string} default_model - Default model to use
   * @property {string} signup_url - URL for API key signup
   */
  static defaults = {};
  /**
   * Create a SmartChatModelAdapter instance.
   * @param {SmartChatModel} model - The parent SmartChatModel instance
   */
  constructor(model) {
    super(model);
    this.smart_chat = model;
    this.main = model;
  }
  /**
   * Complete a chat request.
   * @abstract
   * @param {Object} req - Request parameters
   * @returns {Promise<Object>} Completion result
   */
  async complete(req) {
    throw new Error("complete not implemented");
  }
  /**
   * Count tokens in input text.
   * @abstract
   * @param {string|Object} input - Text to count tokens for
   * @returns {Promise<number>} Token count
   */
  async count_tokens(input) {
    throw new Error("count_tokens not implemented");
  }
  /**
   * Stream chat responses.
   * @abstract
   * @param {Object} req - Request parameters
   * @param {Object} handlers - Event handlers for streaming
   * @returns {Promise<string>} Complete response text
   */
  async stream(req, handlers = {}) {
    throw new Error("stream not implemented");
  }
  /**
   * Test if API key is valid.
   * @abstract
   * @returns {Promise<boolean>} True if API key is valid
   */
  async test_api_key() {
    throw new Error("test_api_key not implemented");
  }
  /**
   * Refresh available models.
   */
  refresh_models() {
    console.log("refresh_models");
    this.get_models(true);
  }
  /**
   * Get settings configuration.
   * @returns {Object} Settings configuration object
   */
  get settings_config() {
    return {
      "[CHAT_ADAPTER].model_key": {
        name: "Chat Model",
        type: "dropdown",
        description: "Select a chat model.",
        options_callback: "adapter.get_models_as_options",
        callback: "reload_model",
        default: this.constructor.defaults.default_model
      },
      "[CHAT_ADAPTER].refresh_models": {
        name: "Refresh Models",
        type: "button",
        description: "Refresh the list of available models.",
        callback: "adapter.refresh_models"
      }
    };
  }
  /**
   * Validate the adapter configuration.
   * @abstract
   * @returns {Object} { valid: boolean, message: string }
   */
  validate_config() {
    throw new Error("validate_config not implemented");
  }
  get can_use_tools() {
    return this.model_config?.can_use_tools || false;
  }
};

// node_modules/smart-chat-model/adapters/_api.js
var SmartChatModelApiAdapter2 = class extends SmartChatModelAdapter2 {
  /**
   * Get the request adapter class.
   * @returns {SmartChatModelRequestAdapter} The request adapter class
   */
  get req_adapter() {
    return SmartChatModelRequestAdapter2;
  }
  /**
   * Get the response adapter class.
   * @returns {SmartChatModelResponseAdapter} The response adapter class
   */
  get res_adapter() {
    return SmartChatModelResponseAdapter2;
  }
  /**
   * Get or initialize the HTTP adapter.
   * @returns {SmartHttpRequest} The HTTP adapter instance
   */
  get http_adapter() {
    if (!this._http_adapter) {
      if (this.model.opts.http_adapter) this._http_adapter = this.model.opts.http_adapter;
      else this._http_adapter = new SmartHttpRequest2({ adapter: SmartHttpRequestFetchAdapter2 });
    }
    return this._http_adapter;
  }
  /**
   * Get the settings configuration for the API adapter.
   * @returns {Object} Settings configuration object with API key and other settings
   */
  get settings_config() {
    return {
      ...super.settings_config,
      "[CHAT_ADAPTER].api_key": {
        name: "API Key",
        type: "password",
        description: "Enter your API key for the chat model platform.",
        callback: "test_api_key",
        is_scope: true
        // trigger re-render of settings when changed (reload models dropdown)
      }
    };
  }
  /**
   * Count tokens in the input text.
   * @abstract
   * @param {string|Object} input - Text or message object to count tokens for
   * @returns {Promise<number>} Number of tokens in the input
   */
  async count_tokens(input) {
    throw new Error("count_tokens not implemented");
  }
  /**
   * Get the parameters for requesting available models.
   * @returns {Object} Request parameters for models endpoint
   */
  get models_request_params() {
    return {
      url: this.models_endpoint,
      method: this.models_endpoint_method,
      headers: {
        "Authorization": `Bearer ${this.api_key}`
      }
    };
  }
  /**
   * Validate parameters required for getting models.
   * @returns {true|Array<Object>} True if valid, array of error objects if invalid
   */
  validate_get_models_params() {
    if (!this.adapter_config.models_endpoint) {
      const err_msg = `${this.model.adapter_name} models endpoint required to retrieve models`;
      console.warn(err_msg);
      return [{ value: "", name: err_msg }];
    }
    if (!this.api_key) {
      const err_msg = `${this.model.adapter_name} API key required to retrieve models`;
      console.warn(err_msg);
      return [{ value: "", name: err_msg }];
    }
    return true;
  }
  /**
   * Get available models from the API.
   * @param {boolean} [refresh=false] - Whether to refresh cached models
   * @returns {Promise<Object>} Map of model objects
   */
  async get_models(refresh = false) {
    if (!refresh && this.adapter_config?.models && typeof this.adapter_config.models === "object" && Object.keys(this.adapter_config.models).length > 0) return this.adapter_config.models;
    try {
      const response = await this.http_adapter.request(this.models_request_params);
      const model_data = this.parse_model_data(await response.json());
      this.adapter_settings.models = model_data;
      this.model.re_render_settings();
      return model_data;
    } catch (error) {
      console.error("Failed to fetch model data:", error);
      return { "_": { id: `Failed to fetch models from ${this.model.adapter_name}` } };
    }
  }
  /**
   * Parses the raw model data from OpenAI API and transforms it into a more usable format.
   * @param {Object} model_data - The raw model data received from OpenAI API.
   * @returns {Array<Object>} An array of parsed model objects with the following properties:
   *   @property {string} model_name - The name/ID of the model as returned by the API.
   *   @property {string} id - The id used to identify the model (usually same as model_name).
   *   @property {boolean} multimodal - Indicates if the model supports multimodal inputs.
   *   @property {number} [max_input_tokens] - The maximum number of input tokens the model can process.
   *   @property {string} [description] - A description of the model's context and output capabilities.
   */
  parse_model_data(model_data) {
    throw new Error("parse_model_data not implemented");
  }
  /**
   * Complete a chat request.
   * @param {Object} req - Request parameters
   * @returns {Promise<Object>} Completion response in OpenAI format
   */
  async complete(req) {
    const _req = new this.req_adapter(this, {
      ...req,
      stream: false
    });
    const request_params = _req.to_platform();
    const http_resp = await this.http_adapter.request(request_params);
    if (!http_resp) return null;
    const _res = new this.res_adapter(this, await http_resp.json());
    try {
      return _res.to_openai();
    } catch (error) {
      console.error("Error in SmartChatModelApiAdapter.complete():", error);
      console.error(http_resp);
      return null;
    }
  }
  // STREAMING
  /**
  * Stream chat responses.
  * @param {Object} req - Request parameters
  * @param {Object} handlers - Event handlers for streaming
  * @param {Function} handlers.chunk - Handler for response objects
  * @param {Function} handlers.error - Handler for errors
  * @param {Function} handlers.done - Handler for completion
  * @returns {Promise<Object>} Complete response object
  */
  async stream(req, handlers = {}) {
    const _req = new this.req_adapter(this, req);
    const request_params = _req.to_platform(true);
    if (this.streaming_chunk_splitting_regex) request_params.chunk_splitting_regex = this.streaming_chunk_splitting_regex;
    return await new Promise((resolve, reject) => {
      try {
        this.active_stream = new SmartStreamer2(this.endpoint_streaming, request_params);
        const resp_adapter = new this.res_adapter(this);
        this.active_stream.addEventListener("message", async (e) => {
          if (this.is_end_of_stream(e)) {
            await resp_adapter.handle_chunk(e.data);
            this.stop_stream();
            const final_resp = resp_adapter.to_openai();
            handlers.done && await handlers.done(final_resp);
            resolve(final_resp);
            return;
          }
          try {
            resp_adapter.handle_chunk(e.data);
            handlers.chunk && await handlers.chunk(resp_adapter.to_openai());
          } catch (error) {
            console.error("Error processing stream chunk:", error);
            handlers.error && handlers.error(e.data);
            this.stop_stream();
            reject(error);
          }
        });
        this.active_stream.addEventListener("error", (e) => {
          console.error("Stream error:", e);
          handlers.error && handlers.error("*API Error. See console logs for details.*");
          this.stop_stream();
          reject(e);
        });
        this.active_stream.stream();
      } catch (err) {
        console.error("Failed to start stream:", err);
        handlers.error && handlers.error("*API Error. See console logs for details.*");
        this.stop_stream();
        reject(err);
      }
    });
  }
  /**
   * Check if a stream event indicates end of stream.
   * @param {Event} event - Stream event
   * @returns {boolean} True if end of stream
   */
  is_end_of_stream(event) {
    return event.data === "data: [DONE]";
  }
  /**
   * Stop active stream.
   */
  stop_stream() {
    if (this.active_stream) {
      this.active_stream.end();
      this.active_stream = null;
    }
  }
  /**
   * Validate Anthropic adapter configuration.
   * @returns {Object} { valid: boolean, message: string }
   */
  validate_config() {
    if (!this.adapter_config.model_key || this.adapter_config.model_key === "undefined") return { valid: false, message: "No model selected." };
    if (!this.api_key) {
      return { valid: false, message: "API key is missing." };
    }
    if (!this.can_use_tools) {
      return { valid: false, message: "Selected model does not support tools." };
    }
    return { valid: true, message: "Configuration is valid." };
  }
  /**
   * Get the API key.
   * @returns {string} The API key.
   */
  get api_key() {
    return this.main.opts.api_key || this.adapter_config?.api_key;
  }
  /**
  
     * Get the number of choices.
     * @returns {number} The number of choices.
     */
  get choices() {
    return this.adapter_config.choices;
  }
  get models_endpoint() {
    return this.adapter_config.models_endpoint;
  }
  get models_endpoint_method() {
    return "POST";
  }
  /**
   * Get the endpoint URL.
   * @returns {string} The endpoint URL.
   */
  get endpoint() {
    return this.adapter_config.endpoint;
  }
  /**
   * Get the streaming endpoint URL.
   * @returns {string} The streaming endpoint URL.
   */
  get endpoint_streaming() {
    return this.adapter_config.endpoint_streaming || this.endpoint;
  }
  /**
   * Get the maximum output tokens.
   * @returns {number} The maximum output tokens.
   */
  get max_output_tokens() {
    return this.adapter_config.max_output_tokens || 3e3;
  }
  /**
   * Get the temperature.
   * @returns {number} The temperature.
   */
  get temperature() {
    return this.adapter_config.temperature;
  }
};
var SmartChatModelRequestAdapter2 = class {
  /**
   * @constructor
   * @param {SmartChatModelAdapter} adapter - The SmartChatModelAdapter instance
   * @param {Object} req - The incoming request object
   */
  constructor(adapter, req = {}) {
    this.adapter = adapter;
    this._req = req;
  }
  /**
   * Get the messages array from the request
   * @returns {Array<Object>} Array of message objects
   */
  get messages() {
    return this._req.messages || [];
  }
  /**
   * Get the model identifier
   * @returns {string} Model ID
   */
  get model() {
    return this._req.model || this.adapter.model_config.id;
  }
  /**
   * Get the temperature setting
   * @returns {number} Temperature value
   */
  get temperature() {
    return this._req.temperature;
  }
  /**
   * Get the maximum tokens setting
   * @returns {number} Max tokens value
   */
  get max_tokens() {
    return this._req.max_tokens || this.adapter.model_config.max_output_tokens;
  }
  /**
   * Get the streaming flag
   * @returns {boolean} Whether to stream responses
   */
  get stream() {
    return this._req.stream;
  }
  /**
   * Get the tools array
   * @returns {Array<Object>|null} Array of tool objects or null
   */
  get tools() {
    return this._req.tools || null;
  }
  /**
   * Get the tool choice setting
   * @returns {string|Object|null} Tool choice configuration
   */
  get tool_choice() {
    return this._req.tool_choice || null;
  }
  get frequency_penalty() {
    return this._req.frequency_penalty;
  }
  get presence_penalty() {
    return this._req.presence_penalty;
  }
  get top_p() {
    return this._req.top_p;
  }
  /**
   * Get request headers
   * @returns {Object} Headers object
   */
  get_headers() {
    const headers = {
      "Content-Type": "application/json",
      ...this.adapter.adapter_config.headers || {}
    };
    if (this.adapter.adapter_config.api_key_header !== "none") {
      if (this.adapter.adapter_config.api_key_header) {
        headers[this.adapter.adapter_config.api_key_header] = this.adapter.api_key;
      } else if (this.adapter.api_key) {
        headers["Authorization"] = `Bearer ${this.adapter.api_key}`;
      }
    }
    return headers;
  }
  /**
   * Convert request to platform-specific format
   * @returns {Object} Platform-specific request parameters
   */
  to_platform(streaming = false) {
    return this.to_openai(streaming);
  }
  /**
   * Convert request to OpenAI format
   * @returns {Object} Request parameters in OpenAI format
   */
  to_openai(streaming = false) {
    const body = {
      messages: this._transform_messages_to_openai(),
      model: this.model,
      max_tokens: this.max_tokens,
      temperature: this.temperature,
      stream: streaming,
      ...this.tools && { tools: this._transform_tools_to_openai() }
    };
    if (body.tools?.length > 0 && this.tool_choice && this.tool_choice !== "none") {
      body.tool_choice = this.tool_choice;
    }
    if (this.model?.startsWith("o1-")) {
      body.messages = body.messages.filter((m) => m.role !== "system");
      delete body.temperature;
    }
    if (typeof this._req.top_p === "number") body.top_p = this._req.top_p;
    if (typeof this._req.presence_penalty === "number") body.presence_penalty = this._req.presence_penalty;
    if (typeof this._req.frequency_penalty === "number") body.frequency_penalty = this._req.frequency_penalty;
    return {
      url: this.adapter.endpoint,
      method: "POST",
      headers: this.get_headers(),
      body: JSON.stringify(body)
    };
  }
  /**
   * Transform messages to OpenAI format
   * @returns {Array<Object>} Transformed messages array
   * @private
   */
  _transform_messages_to_openai() {
    return this.messages.map((message) => this._transform_single_message_to_openai(message));
  }
  /**
   * Transform a single message to OpenAI format
   * @param {Object} message - Message object to transform
   * @returns {Object} Transformed message object
   * @private
   */
  _transform_single_message_to_openai(message) {
    const transformed = {
      role: this._get_openai_role(message.role),
      content: this._get_openai_content(message)
    };
    if (message.name) transformed.name = message.name;
    if (message.tool_calls) transformed.tool_calls = this._transform_tool_calls_to_openai(message.tool_calls);
    if (message.image_url) transformed.image_url = message.image_url;
    if (message.tool_call_id) transformed.tool_call_id = message.tool_call_id;
    return transformed;
  }
  /**
   * Get the OpenAI role for a given role.
   * @param {string} role - The role to transform.
   * @returns {string} The transformed role.
   * @private
   */
  _get_openai_role(role) {
    return role;
  }
  /**
   * Get the OpenAI content for a given content.
   * @param {string} content - The content to transform.
   * @returns {string} The transformed content.
   * @private
   */
  _get_openai_content(message) {
    return message.content;
  }
  /**
   * Transform tool calls to OpenAI format.
   * @param {Array} tool_calls - Array of tool call objects.
   * @returns {Array} Transformed tool calls array.
   * @private
   */
  _transform_tool_calls_to_openai(tool_calls) {
    return tool_calls.map((tool_call) => ({
      id: tool_call.id,
      type: tool_call.type,
      function: {
        name: tool_call.function.name,
        arguments: tool_call.function.arguments
      }
    }));
  }
  /**
   * Transform tools to OpenAI format.
   * @returns {Array} Transformed tools array.
   * @private
   */
  _transform_tools_to_openai() {
    return this.tools.map((tool2) => ({
      type: tool2.type,
      function: {
        name: tool2.function.name,
        description: tool2.function.description,
        parameters: tool2.function.parameters
      }
    }));
  }
};
var SmartChatModelResponseAdapter2 = class {
  // must be getter to prevent erroneous assignment
  static get platform_res() {
    return {
      id: "",
      object: "chat.completion",
      created: 0,
      model: "",
      choices: [],
      usage: {}
    };
  }
  /**
   * @constructor
   * @param {SmartChatModelAdapter} adapter - The SmartChatModelAdapter instance
   * @param {Object} res - The response object
   */
  constructor(adapter, res) {
    this.adapter = adapter;
    this._res = res || this.constructor.platform_res;
  }
  /**
   * Get response ID
   * @returns {string|null} Response ID
   */
  get id() {
    return this._res.id || null;
  }
  /**
   * Get response object type
   * @returns {string|null} Object type
   */
  get object() {
    return this._res.object || null;
  }
  /**
   * Get creation timestamp
   * @returns {number|null} Creation timestamp
   */
  get created() {
    return this._res.created || null;
  }
  /**
   * Get response choices
   * @returns {Array<Object>} Array of choice objects
   */
  get choices() {
    return this._res.choices || [];
  }
  /**
   * Get first tool call if present
   * @returns {Object|null} Tool call object
   */
  get tool_call() {
    return this.message.tool_calls?.[0] || null;
  }
  /**
   * Get tool name from first tool call
   * @returns {string|null} Tool name
   */
  get tool_name() {
    return this.tool_call?.tool_name || null;
  }
  /**
   * Get tool call parameters
   * @returns {Object|null} Tool parameters
   */
  get tool_call_content() {
    return this.tool_call?.parameters || null;
  }
  /**
   * Get token usage statistics
   * @returns {Object|null} Usage statistics
   */
  get usage() {
    return this._res.usage || null;
  }
  get error() {
    return this._res.error || null;
  }
  /**
   * Convert response to OpenAI format
   * @returns {Object} Response in OpenAI format
   */
  to_openai() {
    const res = {
      id: this.id,
      object: this.object,
      created: this.created,
      choices: this._transform_choices_to_openai(),
      usage: this._transform_usage_to_openai(),
      raw: this._res
    };
    if (this.error) res.error = this.error;
    return res;
  }
  /**
   * Parse chunk adds delta to content as expected output format
   */
  handle_chunk(chunk) {
    if (chunk === "data: [DONE]") return;
    chunk = JSON.parse(chunk.split("data: ")[1] || "{}");
    if (Object.keys(chunk).length === 0) return;
    if (!this._res.choices[0]) {
      this._res.choices.push({
        message: {
          index: 0,
          role: "assistant",
          content: ""
        }
      });
    }
    if (!this._res.id) {
      this._res.id = chunk.id;
    }
    if (chunk.choices?.[0]?.delta?.content) {
      this._res.choices[0].message.content += chunk.choices[0].delta.content;
    }
    if (chunk.choices?.[0]?.delta?.tool_calls) {
      if (!this._res.choices[0].message.tool_calls) {
        this._res.choices[0].message.tool_calls = [{
          id: "",
          type: "function",
          function: {
            name: "",
            arguments: ""
          }
        }];
      }
      if (chunk.choices[0].delta.tool_calls[0].id) {
        this._res.choices[0].message.tool_calls[0].id += chunk.choices[0].delta.tool_calls[0].id;
      }
      if (chunk.choices[0].delta.tool_calls[0].function.name) {
        this._res.choices[0].message.tool_calls[0].function.name += chunk.choices[0].delta.tool_calls[0].function.name;
      }
      if (chunk.choices[0].delta.tool_calls[0].function.arguments) {
        this._res.choices[0].message.tool_calls[0].function.arguments += chunk.choices[0].delta.tool_calls[0].function.arguments;
      }
    }
  }
  /**
   * Transform choices to OpenAI format.
   * @returns {Array} Transformed choices array.
   * @private
   */
  _transform_choices_to_openai() {
    return this.choices.map((choice) => ({
      index: choice.index,
      message: this._transform_message_to_openai(choice.message),
      finish_reason: this._get_openai_finish_reason(choice.finish_reason)
    }));
  }
  /**
   * Transform a single message to OpenAI format.
   * @param {Object} message - The message object to transform.
   * @returns {Object} Transformed message object.
   * @private
   */
  _transform_message_to_openai(message = {}) {
    const transformed = {
      role: this._get_openai_role(message.role),
      content: this._get_openai_content(message)
    };
    if (message.name) transformed.name = message.name;
    if (message.tool_calls) transformed.tool_calls = this._transform_tool_calls_to_openai(message.tool_calls);
    if (message.image_url) transformed.image_url = message.image_url;
    return transformed;
  }
  /**
   * Get the OpenAI role for a given role.
   * @param {string} role - The role to transform.
   * @returns {string} The transformed role.
   * @private
   */
  _get_openai_role(role) {
    return role;
  }
  /**
   * Get the OpenAI content for a given content.
   * @param {string} content - The content to transform.
   * @returns {string} The transformed content.
   * @private
   */
  _get_openai_content(message) {
    return message.content;
  }
  /**
   * Get the OpenAI finish reason for a given finish reason.
   * @param {string} finish_reason - The finish reason to transform.
   * @returns {string} The transformed finish reason.
   * @private
   */
  _get_openai_finish_reason(finish_reason) {
    return finish_reason;
  }
  /**
   * Transform usage to OpenAI format.
   * @returns {Object} Transformed usage object.
   * @private
   */
  _transform_usage_to_openai() {
    return this.usage;
  }
  /**
   * Transform tool calls to OpenAI format.
   * @param {Array} tool_calls - Array of tool call objects.
   * @returns {Array} Transformed tool calls array.
   * @private
   */
  _transform_tool_calls_to_openai(tool_calls) {
    return tool_calls.map((tool_call) => ({
      id: tool_call.id,
      type: tool_call.type,
      function: {
        name: tool_call.function.name,
        arguments: tool_call.function.arguments
      }
    }));
  }
};

// node_modules/smart-chat-model/adapters/anthropic.js
var SmartChatModelAnthropicAdapter2 = class extends SmartChatModelApiAdapter2 {
  static key = "anthropic";
  static defaults = {
    description: "Anthropic Claude",
    type: "API",
    endpoint: "https://api.anthropic.com/v1/messages",
    // streaming: false,
    streaming: true,
    api_key_header: "x-api-key",
    headers: {
      "anthropic-version": "2023-06-01",
      "anthropic-beta": "tools-2024-04-04",
      "anthropic-dangerous-direct-browser-access": true
    },
    adapter: "Anthropic",
    models_endpoint: false,
    default_model: "claude-3-5-sonnet-latest",
    signup_url: "https://console.anthropic.com/login?returnTo=%2Fsettings%2Fkeys",
    can_use_tools: true
  };
  /**
   * Get request adapter class
   * @returns {typeof SmartChatModelAnthropicRequestAdapter} Request adapter class
   */
  get req_adapter() {
    return SmartChatModelAnthropicRequestAdapter2;
  }
  /**
   * Get response adapter class
   * @returns {typeof SmartChatModelAnthropicResponseAdapter} Response adapter class
   */
  res_adapter = SmartChatModelAnthropicResponseAdapter2;
  /**
   * Validate parameters for getting models
   * @returns {boolean} Always true since models are hardcoded
   */
  validate_get_models_params() {
    return true;
  }
  /**
   * Get available models (hardcoded list)
   * @returns {Promise<Object>} Map of model objects
   */
  get_models() {
    return Promise.resolve(this.models);
  }
  is_end_of_stream(event) {
    return event.data.includes("message_stop");
  }
  /**
   * Get hardcoded list of available models
   * @returns {Object} Map of model objects with capabilities and limits
   */
  get models() {
    return {
      // ── Claude 4 family ──────────────────────────────────────────────────────
      "claude-opus-4-20250514": {
        name: "Claude Opus 4 (2025-05-14)",
        id: "claude-opus-4-20250514",
        model_name: "claude-opus-4-20250514",
        description: "Anthropic's Claude Opus 4 (2025-05-14)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      "claude-sonnet-4-20250514": {
        name: "Claude Sonnet 4 (2025-05-14)",
        id: "claude-sonnet-4-20250514",
        model_name: "claude-sonnet-4-20250514",
        description: "Anthropic's Claude Sonnet 4 (2025-05-14)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      // ── Claude 3.7 family ───────────────────────────────────────────────────
      "claude-3-7-sonnet-latest": {
        name: "Claude 3.7 Sonnet (Latest)",
        id: "claude-3-7-sonnet-latest",
        model_name: "claude-3-7-sonnet-latest",
        description: "Anthropic's Claude Sonnet 3.7 (Latest)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      "claude-3-7-sonnet-20250219": {
        name: "Claude 3.7 Sonnet (2025-02-19)",
        id: "claude-3-7-sonnet-20250219",
        model_name: "claude-3-7-sonnet-20250219",
        description: "Anthropic's Claude Sonnet 3.7 (2025-02-19)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      // ── Claude 3.5 family ───────────────────────────────────────────────────
      "claude-3-5-sonnet-latest": {
        name: "Claude 3.5 Sonnet (Latest)",
        id: "claude-3-5-sonnet-latest",
        model_name: "claude-3.5-sonnet-latest",
        description: "Anthropic's Claude Sonnet 3.5 (Latest)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      "claude-3-5-sonnet-20241022": {
        name: "Claude 3.5 Sonnet (2024-10-22)",
        id: "claude-3-5-sonnet-20241022",
        model_name: "claude-3-5-sonnet-20241022",
        description: "Anthropic's Claude Sonnet 3.5 (2024-10-22)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      "claude-3.5-sonnet-20240620": {
        // kept original id typo for backward compatibility
        name: "Claude 3.5 Sonnet (2024-06-20)",
        id: "claude-3.5-sonnet-20240620",
        model_name: "claude-3.5-sonnet-20240620",
        description: "Anthropic's Claude Sonnet 3.5 (2024-06-20)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      "claude-3-5-haiku-latest": {
        name: "Claude 3.5 Haiku (Latest)",
        id: "claude-3-5-haiku-latest",
        model_name: "claude-3.5-haiku-latest",
        description: "Anthropic's Claude Haiku 3.5 (Latest)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3
      },
      "claude-3-5-haiku-20241022": {
        name: "Claude 3.5 Haiku (2024-10-22)",
        id: "claude-3-5-haiku-20241022",
        model_name: "claude-3-5-haiku-20241022",
        description: "Anthropic's Claude Haiku 3.5 (2024-10-22)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3
      },
      // ── Claude 3 family ─────────────────────────────────────────────────────
      "claude-3-opus-latest": {
        name: "Claude 3 Opus (Latest)",
        id: "claude-3-opus-latest",
        model_name: "claude-3-opus-latest",
        description: "Anthropic's Claude Opus 3 (Latest)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      "claude-3-opus-20240229": {
        name: "Claude 3 Opus (2024-02-29)",
        id: "claude-3-opus-20240229",
        model_name: "claude-3-opus-20240229",
        description: "Anthropic's Claude Opus 3 (2024-02-29)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      "claude-3-sonnet-20240229": {
        name: "Claude 3 Sonnet (2024-02-29)",
        id: "claude-3-sonnet-20240229",
        model_name: "claude-3-sonnet-20240229",
        description: "Anthropic's Claude Sonnet 3 (2024-02-29)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      },
      "claude-3-haiku-20240307": {
        name: "Claude 3 Haiku (2024-03-07)",
        id: "claude-3-haiku-20240307",
        model_name: "claude-3-haiku-20240307",
        description: "Anthropic's Claude Haiku 3 (2024-03-07)",
        max_input_tokens: 2e5,
        max_output_tokens: 4e3,
        multimodal: true
      }
    };
  }
};
var SmartChatModelAnthropicRequestAdapter2 = class extends SmartChatModelRequestAdapter2 {
  /**
   * Convert request to Anthropic format
   * @returns {Object} Request parameters in Anthropic format
   */
  to_platform(streaming = false) {
    return this.to_anthropic(streaming);
  }
  /**
   * Convert request to Anthropic format
   * @returns {Object} Request parameters in Anthropic format
   */
  to_anthropic(streaming = false) {
    this.anthropic_body = {
      model: this.model,
      max_tokens: this.max_tokens,
      temperature: this.temperature,
      stream: streaming
    };
    this.anthropic_body.messages = this._transform_messages_to_anthropic();
    if (this.tools) {
      this.anthropic_body.tools = this._transform_tools_to_anthropic();
    }
    if (this.tool_choice) {
      if (this.tool_choice === "auto") {
        this.anthropic_body.tool_choice = { type: "auto" };
      } else if (typeof this.tool_choice === "object" && this.tool_choice.function) {
        this.anthropic_body.tool_choice = { type: "tool", name: this.tool_choice.function.name };
      }
    }
    return {
      url: this.adapter.endpoint,
      method: "POST",
      headers: this.get_headers(),
      body: JSON.stringify(this.anthropic_body)
    };
  }
  /**
   * Transform messages to Anthropic format
   * @returns {Array<Object>} Messages in Anthropic format
   * @private
   */
  _transform_messages_to_anthropic() {
    let anthropic_messages = [];
    for (const message of this.messages) {
      if (message.role === "system") {
        if (!this.anthropic_body.system) this.anthropic_body.system = "";
        else this.anthropic_body.system += "\n\n";
        this.anthropic_body.system += Array.isArray(message.content) ? message.content.map((part) => part.text).join("\n") : message.content;
      } else if (message.role === "tool") {
        const msg = {
          role: "user",
          content: [
            {
              type: "tool_result",
              tool_use_id: message.tool_call_id,
              content: message.content
            }
          ]
        };
        anthropic_messages.push(msg);
      } else {
        const msg = {
          role: this._get_anthropic_role(message.role),
          content: this._get_anthropic_content(message.content)
        };
        if (message.tool_calls?.length > 0) msg.content = this._transform_tool_calls_to_content(message.tool_calls);
        anthropic_messages.push(msg);
      }
    }
    return anthropic_messages;
  }
  /**
   * Transform tool calls to Anthropic format
   * @param {Array<Object>} tool_calls - Tool calls
   * @returns {Array<Object>} Tool calls in Anthropic format
   * @private
   */
  _transform_tool_calls_to_content(tool_calls) {
    return tool_calls.map((tool_call) => ({
      type: "tool_use",
      id: tool_call.id,
      name: tool_call.function.name,
      input: JSON.parse(tool_call.function.arguments)
    }));
  }
  /**
   * Transform role to Anthropic format
   * @param {string} role - Original role
   * @returns {string} Role in Anthropic format
   * @private
   */
  _get_anthropic_role(role) {
    const role_map = {
      function: "assistant",
      // Anthropic doesn't have a function role, so we'll treat it as assistant
      tool: "user"
    };
    return role_map[role] || role;
  }
  /**
   * Transform content to Anthropic format
   * @param {string|Array} content - Original content
   * @returns {string|Array} Content in Anthropic format
   * @private
   */
  _get_anthropic_content(content) {
    if (Array.isArray(content)) {
      return content.map((item) => {
        if (item.type === "text") return { type: "text", text: item.text };
        if (item.type === "image_url") {
          return {
            type: "image",
            source: {
              type: "base64",
              media_type: item.image_url.url.split(";")[0].split(":")[1],
              data: item.image_url.url.split(",")[1]
            }
          };
        }
        if (item.type === "file" && item.file?.filename?.toLowerCase().endsWith(".pdf")) {
          if (item.file?.file_data) {
            return {
              type: "document",
              source: {
                type: "base64",
                media_type: "application/pdf",
                data: item.file.file_data.split(",")[1]
              }
            };
          }
        }
        return item;
      });
    }
    return content;
  }
  /**
   * Transform tools to Anthropic format
   * @returns {Array<Object>} Tools in Anthropic format
   * @private
   */
  _transform_tools_to_anthropic() {
    if (!this.tools) return void 0;
    return this.tools.map((tool2) => ({
      name: tool2.function.name,
      description: tool2.function.description,
      input_schema: tool2.function.parameters
    }));
  }
};
var SmartChatModelAnthropicResponseAdapter2 = class extends SmartChatModelResponseAdapter2 {
  static get platform_res() {
    return {
      content: [],
      id: "",
      model: "",
      role: "assistant",
      stop_reason: null,
      stop_sequence: null,
      type: "message",
      usage: {
        input_tokens: 0,
        output_tokens: 0
      }
    };
  }
  /**
   * Convert response to OpenAI format
   * @returns {Object} Response in OpenAI format
   */
  to_openai() {
    return {
      id: this._res.id,
      object: "chat.completion",
      created: Date.now(),
      choices: [
        {
          index: 0,
          message: this._transform_message_to_openai(),
          finish_reason: this._get_openai_finish_reason(this._res.stop_reason)
        }
      ],
      usage: this._transform_usage_to_openai()
    };
  }
  /**
   * Transform message to OpenAI format
   * @returns {Object} Message in OpenAI format
   * @private
   */
  _transform_message_to_openai() {
    const message = {
      role: "assistant",
      content: "",
      tool_calls: []
    };
    if (Array.isArray(this._res.content)) {
      for (const content of this._res.content) {
        if (content.type === "text") {
          message.content += (message.content ? "\n\n" : "") + content.text;
        } else if (content.type === "tool_use") {
          message.tool_calls.push({
            id: content.id,
            type: "function",
            function: {
              name: content.name,
              arguments: JSON.stringify(content.input)
            }
          });
        }
      }
    } else {
      message.content = this._res.content;
    }
    if (message.tool_calls.length === 0) {
      delete message.tool_calls;
    }
    return message;
  }
  /**
   * Transform finish reason to OpenAI format
   * @param {string} stop_reason - Original finish reason
   * @returns {string} Finish reason in OpenAI format
   * @private
   */
  _get_openai_finish_reason(stop_reason) {
    const reason_map = {
      "end_turn": "stop",
      "max_tokens": "length",
      "tool_use": "function_call"
    };
    return reason_map[stop_reason] || stop_reason;
  }
  /**
   * Transform usage statistics to OpenAI format
   * @returns {Object} Usage statistics in OpenAI format
   * @private
   */
  _transform_usage_to_openai() {
    if (!this._res.usage) {
      return {
        prompt_tokens: 0,
        completion_tokens: 0,
        total_tokens: 0
      };
    }
    return {
      prompt_tokens: this._res.usage.input_tokens || 0,
      completion_tokens: this._res.usage.output_tokens || 0,
      total_tokens: (this._res.usage.input_tokens || 0) + (this._res.usage.output_tokens || 0)
    };
  }
  handle_chunk(chunk) {
    if (!chunk.startsWith("data: ")) return;
    chunk = JSON.parse(chunk.slice(6));
    if (!this._res.content.length) {
      this._res.content = [
        {
          type: "text",
          text: ""
        }
      ];
    }
    if (chunk.message?.id) {
      this._res.id = chunk.message.id;
    }
    if (chunk.message?.model) {
      this._res.model = chunk.message.model;
    }
    if (chunk.message?.role) {
      this._res.role = chunk.message.role;
    }
    if (chunk.delta?.type === "text_delta") {
      this._res.content[0].text += chunk.delta.text;
    }
    if (chunk.delta?.stop_reason) {
      this._res.stop_reason = chunk.delta.stop_reason;
    }
    if (chunk.usage) {
      this._res.usage = {
        ...this._res.usage,
        ...chunk.usage
      };
    }
  }
};

// node_modules/smart-chat-model/adapters/openai.js
var EXCLUDED_PREFIXES2 = [
  "text-",
  "davinci",
  "babbage",
  "ada",
  "curie",
  "dall-e",
  "whisper",
  "omni",
  "tts",
  "gpt-4o-mini-tts",
  "computer-use",
  "codex",
  "gpt-4o-transcribe",
  "gpt-4o-mini-transcribe",
  "gpt-4o-mini-realtime",
  "gpt-4o-realtime",
  "o4-mini-deep-research",
  "o3-deep-research",
  "gpt-image"
];
var SmartChatModelOpenaiAdapter2 = class extends SmartChatModelApiAdapter2 {
  static key = "openai";
  static defaults = {
    description: "OpenAI",
    type: "API",
    endpoint: "https://api.openai.com/v1/chat/completions",
    streaming: true,
    models_endpoint: "https://api.openai.com/v1/models",
    default_model: "gpt-4.1-mini",
    signup_url: "https://platform.openai.com/api-keys",
    can_use_tools: true
  };
  res_adapter = SmartChatModelOpenaiResponseAdapter2;
  /**
   * Parse model data from OpenAI API response.
   * Filters for GPT models and adds context window information.
   * @param {Object} model_data - Raw model data from OpenAI
   * @returns {Object} Map of model objects with capabilities and limits
   */
  parse_model_data(model_data) {
    return model_data.data.filter((model) => !EXCLUDED_PREFIXES2.some((m) => model.id.startsWith(m)) && !model.id.includes("-instruct")).reduce((acc, model) => {
      const out = {
        model_name: model.id,
        id: model.id,
        multimodal: true,
        can_use_tools: true,
        max_input_tokens: get_max_input_tokens2(model.id)
      };
      acc[model.id] = out;
      return acc;
    }, {});
  }
  /**
   * Override the HTTP method for fetching models.
   */
  models_endpoint_method = "GET";
  /**
   * Test the API key by attempting to fetch models.
   * @returns {Promise<boolean>} True if API key is valid
   */
  async test_api_key() {
    const models = await this.get_models();
    return models.length > 0;
  }
  /**
   * Get settings configuration for OpenAI adapter.
   * Adds image resolution setting for multimodal models.
   * @returns {Object} Settings configuration object
   */
  get settings_config() {
    const config = super.settings_config;
    if (this.adapter?.model_config?.multimodal) {
      config["[CHAT_ADAPTER].image_resolution"] = {
        name: "Image Resolution",
        type: "dropdown",
        description: "Select the image resolution for the chat model.",
        option_1: "low",
        option_2: "high",
        default: "low"
      };
    }
    config["[CHAT_ADAPTER].open_ai_note"] = {
      name: "Note about using OpenAI",
      type: "html",
      value: "<b>OpenAI models:</b> Some models require extra verification steps in your OpenAI account for them to appear in the model list."
    };
    return config;
  }
};
function get_max_input_tokens2(model_id) {
  if (model_id.startsWith("gpt-4.1")) {
    return 1e6;
  }
  if (model_id.startsWith("o")) {
    return 2e5;
  }
  if (model_id.startsWith("gpt-4o") || model_id.startsWith("gpt-4.5") || model_id.startsWith("gpt-4-turbo")) {
    return 128e3;
  }
  if (model_id.startsWith("gpt-4")) {
    return 8192;
  }
  if (model_id.startsWith("gpt-3")) {
    return 16385;
  }
  return 8e3;
}
var SmartChatModelOpenaiResponseAdapter2 = class extends SmartChatModelResponseAdapter2 {
};

// node_modules/smart-chat-model/adapters/azure.js
var SmartChatModelAzureAdapter2 = class extends SmartChatModelOpenaiAdapter2 {
  static key = "azure";
  static defaults = {
    description: "Azure OpenAI",
    type: "API",
    adapter: "AzureOpenAI",
    streaming: true,
    api_key_header: "api-key",
    azure_resource_name: "",
    azure_deployment_name: "",
    azure_api_version: "2024-10-01-preview",
    default_model: "gpt-35-turbo",
    signup_url: "https://learn.microsoft.com/azure/cognitive-services/openai/quickstart?tabs=command-line",
    models_endpoint: "https://{azure_resource_name}.openai.azure.com/openai/deployments?api-version={azure_api_version}",
    can_use_tools: true
  };
  /**
   * Override the settings configuration to include Azure-specific fields.
   */
  get settings_config() {
    return {
      ...super.settings_config,
      "[CHAT_ADAPTER].azure_resource_name": {
        name: "Azure Resource Name",
        type: "text",
        description: "The name of your Azure OpenAI resource (e.g. 'my-azure-openai').",
        default: ""
      },
      "[CHAT_ADAPTER].azure_deployment_name": {
        name: "Azure Deployment Name",
        type: "text",
        description: "The name of your specific model deployment (e.g. 'gpt35-deployment').",
        default: ""
      },
      "[CHAT_ADAPTER].azure_api_version": {
        name: "Azure API Version",
        type: "text",
        description: "The API version for Azure OpenAI (e.g. '2024-10-01-preview').",
        default: "2024-10-01-preview"
      }
    };
  }
  /**
   * Build the endpoint dynamically based on Azure settings.
   * Example:
   *  https://<RESOURCE>.openai.azure.com/openai/deployments/<DEPLOYMENT>/chat/completions?api-version=2023-05-15
   */
  get endpoint() {
    const { azure_resource_name, azure_deployment_name, azure_api_version } = this.adapter_config;
    return `https://${azure_resource_name}.openai.azure.com/openai/deployments/${azure_deployment_name}/chat/completions?api-version=${azure_api_version}`;
  }
  /**
   * For streaming, we can reuse the same endpoint. 
   * The request body includes `stream: true` which the base class uses.
   */
  get endpoint_streaming() {
    return this.endpoint;
  }
  /**
   * The models endpoint for retrieving a list of your deployments.
   * E.g.:
   *   https://<RESOURCE>.openai.azure.com/openai/deployments?api-version=2023-05-15
   */
  get models_endpoint() {
    const { azure_resource_name, azure_api_version } = this.adapter_config;
    return `https://${azure_resource_name}.openai.azure.com/openai/deployments?api-version=${azure_api_version}`;
  }
  /**
   * Azure returns a list of deployments in the shape:
   * {
   *   "object": "list",
   *   "data": [
   *     {
   *       "id": "mydeployment",
   *       "model": "gpt-35-turbo",
   *       "status": "succeeded",
   *       "createdAt": ...
   *       "updatedAt": ...
   *       ...
   *     },
   *     ...
   *   ]
   * }
   * We'll parse them into a dictionary keyed by deployment ID.
   */
  parse_model_data(model_data) {
    if (model_data.object !== "list" || !Array.isArray(model_data.data)) {
      return { "_": { id: "No deployments found." } };
    }
    const parsed = {};
    for (const d of model_data.data) {
      parsed[d.id] = {
        model_name: d.id,
        id: d.id,
        raw: d,
        // You can add more details if you want:
        description: `Model: ${d.model}, Status: ${d.status}`,
        // Hard to guess tokens; omit or guess:
        max_input_tokens: 4e3
      };
    }
    return parsed;
  }
  /**
   * Validate the Azure configuration fields.
   */
  validate_config() {
    const { azure_resource_name, azure_deployment_name, azure_api_version } = this.adapter_config;
    if (!azure_resource_name) {
      return { valid: false, message: "Azure resource name is missing." };
    }
    if (!azure_deployment_name) {
      return { valid: false, message: "Azure deployment name is missing." };
    }
    if (!azure_api_version) {
      return { valid: false, message: "Azure API version is missing." };
    }
    if (!this.api_key) {
      return { valid: false, message: "Azure OpenAI API key is missing." };
    }
    return { valid: true, message: "Configuration is valid." };
  }
};

// node_modules/smart-chat-model/adapters/google.js
var SmartChatModelGeminiAdapter2 = class extends SmartChatModelApiAdapter2 {
  static key = "gemini";
  static defaults = {
    description: "Google Gemini",
    type: "API",
    api_key_header: "none",
    endpoint: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:generateContent",
    endpoint_streaming: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:streamGenerateContent",
    streaming: true,
    adapter: "Gemini",
    models_endpoint: "https://generativelanguage.googleapis.com/v1beta/models",
    default_model: "gemini-1.5-pro",
    signup_url: "https://ai.google.dev/",
    can_use_tools: true
  };
  streaming_chunk_splitting_regex = /(\r\n|\n|\r){2}/g;
  // handle Google's BS (split on double newlines only)
  /**
   * Get request adapter class
   */
  req_adapter = SmartChatModelGeminiRequestAdapter2;
  /**
   * Get response adapter class
   */
  res_adapter = SmartChatModelGeminiResponseAdapter2;
  /**
   * Uses Gemini's dedicated token counting endpoint
   */
  async count_tokens(input) {
    const req = {
      url: `https://generativelanguage.googleapis.com/v1beta/models/${this.model_key}:countTokens?key=${this.api_key}`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(this.prepare_token_count_body(input))
    };
    const resp = await this.http_adapter.request(req);
    return resp.json.totalTokens;
  }
  /**
   * Formats input for token counting based on type
   * @private
   */
  prepare_token_count_body(input) {
    if (typeof input === "string") {
      return { contents: [{ parts: [{ text: input }] }] };
    } else if (Array.isArray(input)) {
      return { contents: input.map((msg) => this.transform_message_for_token_count(msg)) };
    } else if (typeof input === "object") {
      return { contents: [this.transform_message_for_token_count(input)] };
    }
    throw new Error("Invalid input for count_tokens");
  }
  /**
   * Transforms message for token counting, handling text and images
   * @private
   */
  transform_message_for_token_count(message) {
    return {
      role: message.role === "assistant" ? "model" : message.role,
      parts: Array.isArray(message.content) ? message.content.map((part) => {
        if (part.type === "text") return { text: part.text };
        if (part.type === "image_url") return {
          inline_data: {
            mime_type: part.image_url.url.split(";")[0].split(":")[1],
            data: part.image_url.url.split(",")[1]
          }
        };
        return part;
      }) : [{ text: message.content }]
    };
  }
  /**
   * Builds endpoint URLs with model and API key
   */
  get endpoint() {
    return `https://generativelanguage.googleapis.com/v1beta/models/${this.model_key}:generateContent?key=${this.api_key}`;
  }
  get endpoint_streaming() {
    return `https://generativelanguage.googleapis.com/v1beta/models/${this.model_key}:streamGenerateContent?key=${this.api_key}`;
  }
  // /**
  //  * Extracts text from Gemini's streaming format
  //  */
  // get_text_chunk_from_stream(event) {
  //   const data = JSON.parse(event.data);
  //   return data.candidates[0]?.content?.parts[0]?.text || '';
  // }
  /**
   * Get models endpoint URL with API key
   * @returns {string} Complete models endpoint URL
   */
  get models_endpoint() {
    return `${this.constructor.defaults.models_endpoint}?key=${this.api_key}`;
  }
  /**
   * Get HTTP method for models endpoint
   * @returns {string} HTTP method ("GET")
   */
  get models_endpoint_method() {
    return "GET";
  }
  get models_request_params() {
    return {
      url: this.models_endpoint,
      method: this.models_endpoint_method
    };
  }
  /**
   * Parse model data from Gemini API response
   * @param {Object} model_data - Raw model data from API
   * @returns {Object} Map of model objects with capabilities and limits
   */
  parse_model_data(model_data) {
    return model_data.models.filter((model) => model.name.startsWith("models/gemini")).reduce((acc, model) => {
      const out = {
        model_name: model.name.split("/").pop(),
        id: model.name.split("/").pop(),
        max_input_tokens: model.inputTokenLimit,
        max_output_tokens: model.maxOutputTokens,
        description: model.description,
        multimodal: model.name.includes("vision") || model.description.includes("multimodal"),
        raw: model
      };
      acc[model.name.split("/").pop()] = out;
      return acc;
    }, {});
  }
  is_end_of_stream(event) {
    return event.data.includes('"finishReason"');
    return false;
  }
};
var SmartChatModelGeminiRequestAdapter2 = class extends SmartChatModelRequestAdapter2 {
  to_platform(streaming = false) {
    return this.to_gemini(streaming);
  }
  to_gemini(streaming = false) {
    const gemini_body = {
      contents: this._transform_messages_to_gemini(),
      generationConfig: {
        temperature: this.temperature,
        maxOutputTokens: this.max_tokens,
        topK: this._req.topK || 1,
        topP: this._req.topP || 1,
        stopSequences: this._req.stop || []
      },
      safetySettings: [
        {
          category: "HARM_CATEGORY_HARASSMENT",
          threshold: "BLOCK_NONE"
        },
        {
          category: "HARM_CATEGORY_HATE_SPEECH",
          threshold: "BLOCK_NONE"
        },
        {
          category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
          threshold: "BLOCK_NONE"
        },
        {
          category: "HARM_CATEGORY_DANGEROUS_CONTENT",
          threshold: "BLOCK_NONE"
        }
      ]
    };
    if (this.tools) gemini_body.tools = this._transform_tools_to_gemini();
    if (gemini_body.tools && this.tool_choice !== "none") gemini_body.tool_config = this._transform_tool_choice_to_gemini();
    return {
      url: streaming ? this.adapter.endpoint_streaming : this.adapter.endpoint,
      method: "POST",
      headers: this.get_headers(),
      body: JSON.stringify(gemini_body)
    };
  }
  _transform_messages_to_gemini() {
    let gemini_messages = [];
    let system_message = "";
    for (const message of this.messages) {
      if (message.role === "system") {
        system_message += message.content + "\n";
      } else {
        gemini_messages.push({
          role: this._get_gemini_role(message.role),
          parts: this._transform_content_to_gemini(message.content)
        });
      }
    }
    if (system_message) {
      gemini_messages.unshift({
        role: "user",
        parts: [{ text: system_message.trim() }]
      });
    }
    return gemini_messages;
  }
  _get_gemini_role(role) {
    const role_map = {
      user: "user",
      assistant: "model",
      function: "model"
      // Gemini doesn't have a function role, so we'll treat it as model
    };
    return role_map[role] || role;
  }
  _transform_content_to_gemini(content) {
    if (Array.isArray(content)) {
      return content.map((part) => {
        if (part.type === "text") return { text: part.text };
        if (part.type === "image_url") {
          return {
            inline_data: {
              mime_type: part.image_url.url.split(";")[0].split(":")[1],
              data: part.image_url.url.split(",")[1]
            }
          };
        }
        if (part.type === "file" && part.file?.filename?.toLowerCase().endsWith(".pdf")) {
          if (part.file?.file_data) {
            return {
              inline_data: {
                mime_type: "application/pdf",
                data: part.file.file_data.split(",")[1]
              }
            };
          }
        }
        return part;
      });
    }
    return [{ text: content }];
  }
  _transform_tools_to_gemini() {
    return [{
      function_declarations: this.tools.map((tool2) => ({
        name: tool2.function.name,
        description: tool2.function.description,
        parameters: tool2.function.parameters
      }))
    }];
  }
  _transform_tool_choice_to_gemini() {
    return {
      function_calling_config: {
        mode: "ANY",
        allowed_function_names: this.tools.map((tool2) => tool2.function.name)
      }
    };
  }
};
var SmartChatModelGeminiResponseAdapter2 = class extends SmartChatModelResponseAdapter2 {
  static get platform_res() {
    return {
      candidates: [{
        content: {
          parts: [
            {
              text: ""
            }
          ],
          role: ""
        },
        finishReason: ""
      }],
      promptFeedback: {},
      usageMetadata: {}
    };
  }
  to_openai() {
    const first_candidate = this._res.candidates[0];
    if (!this._res.id) this._res.id = "gemini-" + Date.now().toString();
    return {
      id: this._res.id,
      object: "chat.completion",
      created: Date.now(),
      model: this.adapter.model_key,
      choices: [{
        index: 0,
        message: first_candidate?.content ? this._transform_message_to_openai(first_candidate.content) : "",
        finish_reason: this._get_openai_finish_reason(first_candidate.finishReason)
      }],
      usage: this._transform_usage_to_openai()
    };
  }
  _transform_message_to_openai(content) {
    const message = {
      role: "assistant",
      content: content.parts.filter((part) => part.text).map((part) => part.text).join("")
    };
    const function_call = content.parts.find((part) => part.functionCall);
    if (function_call) {
      message.tool_calls = [{
        type: "function",
        function: {
          name: function_call.functionCall.name,
          arguments: JSON.stringify(function_call.functionCall.args)
        }
      }];
    }
    return message;
  }
  _get_openai_finish_reason(finish_reason) {
    const reason_map = {
      "STOP": "stop",
      "MAX_TOKENS": "length",
      "SAFETY": "content_filter",
      "RECITATION": "content_filter",
      "OTHER": "null"
    };
    return reason_map[finish_reason] || finish_reason.toLowerCase();
  }
  _transform_usage_to_openai() {
    if (!this._res.usageMetadata) {
      return {
        prompt_tokens: null,
        completion_tokens: null,
        total_tokens: null
      };
    }
    return {
      prompt_tokens: this._res.usageMetadata.promptTokenCount || null,
      completion_tokens: this._res.usageMetadata.candidatesTokenCount || null,
      total_tokens: this._res.usageMetadata.totalTokenCount || null
    };
  }
  handle_chunk(chunk) {
    let chunk_trimmed = chunk.trim();
    if (["[", ","].includes(chunk_trimmed[0])) chunk_trimmed = chunk_trimmed.slice(1);
    if (["]", ","].includes(chunk_trimmed[chunk_trimmed.length - 1])) chunk_trimmed = chunk_trimmed.slice(0, -1);
    const data = JSON.parse(chunk_trimmed);
    if (data.candidates?.[0]?.content?.parts?.[0]?.text?.length) {
      this._res.candidates[0].content.parts[0].text += data.candidates[0].content.parts[0].text;
    }
    if (data.candidates?.[0]?.content?.role?.length) {
      this._res.candidates[0].content.role = data.candidates[0].content.role;
    }
    if (data.candidates?.[0]?.finishReason?.length) {
      this._res.candidates[0].finishReason += data.candidates[0].finishReason;
    }
    if (data.promptFeedback) {
      this._res.promptFeedback = {
        ...this._res.promptFeedback || {},
        ...data.promptFeedback
      };
    }
    if (data.usageMetadata) {
      this._res.usageMetadata = {
        ...this._res.usageMetadata || {},
        ...data.usageMetadata
      };
    }
    if (data.candidates?.[0]?.content?.parts?.[0]?.functionCall) {
      if (!this._res.candidates[0].content.parts[0].functionCall) {
        this._res.candidates[0].content.parts[0].functionCall = {
          name: "",
          args: {}
        };
      }
      this._res.candidates[0].content.parts[0].functionCall.name += data.candidates[0].content.parts[0].functionCall.name;
      if (data.candidates[0].content.parts[0].functionCall.args) {
        Object.entries(data.candidates[0].content.parts[0].functionCall.args).forEach(([key, value]) => {
          if (!this._res.candidates[0].content.parts[0].functionCall.args[key]) {
            this._res.candidates[0].content.parts[0].functionCall.args[key] = "";
          }
          this._res.candidates[0].content.parts[0].functionCall.args[key] += value;
        });
      }
    }
  }
};

// node_modules/smart-chat-model/adapters/open_router.js
var SmartChatModelOpenRouterAdapter2 = class extends SmartChatModelApiAdapter2 {
  static key = "open_router";
  static defaults = {
    description: "Open Router",
    type: "API",
    endpoint: "https://openrouter.ai/api/v1/chat/completions",
    streaming: true,
    adapter: "OpenRouter",
    models_endpoint: "https://openrouter.ai/api/v1/models",
    default_model: "mistralai/mistral-7b-instruct:free",
    signup_url: "https://accounts.openrouter.ai/sign-up?redirect_url=https%3A%2F%2Fopenrouter.ai%2Fkeys",
    can_use_tools: true
  };
  /**
   * Get request adapter class
   * @returns {typeof SmartChatModelOpenRouterRequestAdapter} Request adapter class
   */
  get req_adapter() {
    return SmartChatModelOpenRouterRequestAdapter2;
  }
  /**
   * Get response adapter class
   * @returns {typeof SmartChatModelOpenRouterResponseAdapter} Response adapter class
   */
  get res_adapter() {
    return SmartChatModelOpenRouterResponseAdapter2;
  }
  /**
   * Get API key from various sources
   * @returns {string|undefined} API key if available
   */
  get api_key() {
    return this.main.opts.api_key || this.adapter_settings?.api_key || "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";
  }
  /**
   * Count tokens in input text (rough estimate)
   * @param {string|Object} input - Text to count tokens for
   * @returns {Promise<number>} Estimated token count
   */
  async count_tokens(input) {
    const text = typeof input === "string" ? input : JSON.stringify(input);
    return Math.ceil(text.length / 4);
  }
  get models_request_params() {
    return {
      url: this.models_endpoint,
      method: "GET"
    };
  }
  /**
   * Parse model data from OpenRouter API response
   * @param {Object} model_data - Raw model data
   * @returns {Object} Map of model objects with capabilities and limits
   */
  parse_model_data(model_data) {
    if (model_data.data) {
      model_data = model_data.data;
    }
    if (model_data.error) throw new Error(model_data.error);
    return model_data.reduce((acc, model) => {
      acc[model.id] = {
        model_name: model.id,
        id: model.id,
        max_input_tokens: model.context_length,
        description: model.name,
        can_use_tools: model.description.includes("tool use") || model.description.includes("function call"),
        multimodal: model.architecture.modality === "multimodal",
        raw: model
      };
      return acc;
    }, {});
  }
};
var SmartChatModelOpenRouterRequestAdapter2 = class extends SmartChatModelRequestAdapter2 {
  to_platform(stream = false) {
    const req = this.to_openai(stream);
    return req;
  }
  _get_openai_content(message) {
    if (message.role === "user") {
      if (Array.isArray(message.content) && message.content.every((part) => part.type === "text")) {
        return message.content.map((part) => part.text).join("\n");
      }
    }
    return message.content;
  }
};
var SmartChatModelOpenRouterResponseAdapter2 = class extends SmartChatModelResponseAdapter2 {
  static get platform_res() {
    return {
      id: "",
      object: "chat.completion",
      created: 0,
      model: "",
      choices: [],
      usage: {}
    };
  }
  to_platform() {
    return this.to_openai();
  }
  get object() {
    return "chat.completion";
  }
  get error() {
    if (!this._res.error) return null;
    const error = this._res.error;
    if (!error.message) error.message = "";
    if (this._res.error.metadata?.raw) {
      if (typeof this._res.error.metadata.raw === "string") {
        error.message += `

${this._res.error.metadata.raw}`;
      } else {
        error.message += `

${JSON.stringify(this._res.error.metadata.raw, null, 2)}`;
      }
    }
    return error;
  }
};

// node_modules/smart-chat-model/adapters/lm_studio.js
var SmartChatModelLmStudioAdapter2 = class extends SmartChatModelApiAdapter2 {
  static key = "lm_studio";
  /** @type {import('./_adapter.js').SmartChatModelAdapter['constructor']['defaults']} */
  static defaults = {
    description: "LM Studio (OpenAI\u2011compatible)",
    type: "API",
    endpoint: "http://localhost:1234/v1/chat/completions",
    streaming: true,
    adapter: "LM_Studio_OpenAI_Compat",
    models_endpoint: "http://localhost:1234/v1/models",
    default_model: "",
    signup_url: "https://lmstudio.ai/docs/api/openai-api",
    can_use_tools: true,
    api_key: "no api key required"
  };
  /* ------------------------------------------------------------------ *
   *  Request / Response classes
   * ------------------------------------------------------------------ */
  get req_adapter() {
    return SmartChatModelLmStudioRequestAdapter2;
  }
  get res_adapter() {
    return SmartChatModelLmStudioResponseAdapter2;
  }
  /* ------------------------------------------------------------------ *
   *  Settings
   * ------------------------------------------------------------------ */
  /**
   * Extend the base settings with a read‑only HTML block that reminds the
   * user to enable CORS inside LM Studio. The Smart View renderer treats
   * `type: "html"` as a static fragment, so no extra runtime logic is needed.
   */
  get settings_config() {
    const config = super.settings_config;
    delete config["[CHAT_ADAPTER].api_key"];
    return {
      ...config,
      "[CHAT_ADAPTER].cors_instructions": {
        /* visible only when this adapter is selected */
        name: "CORS required",
        type: "html",
        value: "<p>Before sending requests from the browser you must enable CORS inside LM Studio:</p><p>Open the LM Studio application, choose <strong>Settings > OpenAI API Compatible</strong> and enable <strong>Allow Cross\u2011Origin Requests (CORS)</strong>. Restart the server afterwards.</p><p>With CORS enabled the local endpoint <code>http://localhost:1234</code> becomes reachable from web contexts.</p>"
      }
    };
  }
  /* ------------------------------------------------------------------ *
   *  Model list helpers
   * ------------------------------------------------------------------ */
  /**
   * LM Studio returns an OpenAI‑style list; normalise to the project shape.
   */
  parse_model_data(model_data) {
    if (model_data.object !== "list" || !Array.isArray(model_data.data)) {
      return { _: { id: "No models found." } };
    }
    const out = {};
    for (const m of model_data.data) {
      out[m.id] = {
        id: m.id,
        model_name: m.id,
        description: `LM Studio model: ${m.id}`,
        multimodal: false
      };
    }
    return out;
  }
  get models_endpoint_method() {
    return "get";
  }
  /**
   * Count tokens in input text (no dedicated endpoint)
   * Rough estimate: 1 token ~ 4 chars
   * @param {string|Object} input
   * @returns {Promise<number>}
   */
  async count_tokens(input) {
    const text = typeof input === "string" ? input : JSON.stringify(input);
    return Math.ceil(text.length / 4);
  }
  /**
   * Test API key - LM Studio doesn't require API key. Always true.
   * @returns {Promise<boolean>}
   */
  async test_api_key() {
    return true;
  }
  get api_key() {
    return "no api key required";
  }
  /**
   * Validate configuration
   */
  validate_config() {
    if (!this.adapter_config.model_key) {
      return { valid: false, message: "No model selected." };
    }
    return { valid: true, message: "Configuration is valid." };
  }
};
var SmartChatModelLmStudioRequestAdapter2 = class extends SmartChatModelRequestAdapter2 {
  to_platform(streaming = false) {
    const req = this.to_openai(streaming);
    const body = JSON.parse(req.body);
    if (this.tool_choice?.function?.name) {
      const last_msg = body.messages[body.messages.length - 1];
      if (typeof last_msg.content === "string") {
        last_msg.content = [
          { type: "text", text: last_msg.content }
        ];
      }
      last_msg.content.push({
        type: "text",
        text: `Use the "${this.tool_choice.function.name}" tool.`
      });
      body.tool_choice = "required";
    } else if (body.tool_choice && typeof body.tool_choice === "object") {
      body.tool_choice = "auto";
    }
    req.body = JSON.stringify(body);
    return req;
  }
};
var SmartChatModelLmStudioResponseAdapter2 = class extends SmartChatModelResponseAdapter2 {
};

// node_modules/smart-chat-model/adapters/ollama.js
var SmartChatModelOllamaAdapter2 = class extends SmartChatModelApiAdapter2 {
  static key = "ollama";
  static defaults = {
    description: "Ollama (Local)",
    type: "API",
    models_endpoint: "http://localhost:11434/api/tags",
    endpoint: "http://localhost:11434/api/chat",
    api_key: "na",
    // streaming: false, // TODO: Implement streaming
    streaming: true
  };
  req_adapter = SmartChatModelOllamaRequestAdapter2;
  res_adapter = SmartChatModelOllamaResponseAdapter2;
  /**
   * Get parameters for models request - no auth needed for local instance
   * @returns {Object} Request parameters
   */
  get models_request_params() {
    return {
      url: this.adapter_config.models_endpoint
    };
  }
  /**
   * Get available models from local Ollama instance
   * @param {boolean} [refresh=false] - Whether to refresh cached models
   * @returns {Promise<Object>} Map of model objects
   */
  async get_models(refresh = false) {
    if (!refresh && this.adapter_config?.models && typeof this.adapter_config.models === "object" && Object.keys(this.adapter_config.models).length > 0) return this.adapter_config.models;
    try {
      const list_resp = await this.http_adapter.request(this.models_request_params);
      const list_data = await list_resp.json();
      const models_raw_data = [];
      for (const model of list_data.models) {
        const model_details_resp = await this.http_adapter.request({
          url: `http://localhost:11434/api/show`,
          method: "POST",
          body: JSON.stringify({ model: model.name })
        });
        const model_details_data = await model_details_resp.json();
        models_raw_data.push({ ...model_details_data, name: model.name });
      }
      const model_data = this.parse_model_data(models_raw_data);
      this.adapter_settings.models = model_data;
      this.model.re_render_settings();
      return model_data;
    } catch (error) {
      console.error("Failed to fetch model data:", error);
      return { "_": { id: `Failed to fetch models from ${this.model.adapter_name}` } };
    }
  }
  /**
   * Parse model data from Ollama API response
   * @param {Object[]} model_data - Raw model data from Ollama
   * @returns {Object} Map of model objects with capabilities and limits
   */
  parse_model_data(model_data) {
    if (!Array.isArray(model_data)) {
      this.model_data = {};
      console.error("Invalid model data format from Ollama:", model_data);
      return {};
    }
    if (model_data.length === 0) {
      this.model_data = { "no_models_available": {
        id: "no_models_available",
        name: "No models currently available"
      } };
      return this.model_data;
    }
    return model_data.reduce((acc, model) => {
      const out = {
        model_name: model.name,
        id: model.name,
        multimodal: false,
        max_input_tokens: Object.entries(model.model_info).find((m) => m[0].includes(".context_length"))[1],
        can_use_tools: true
        // TODO: CHECK MODELFILE FOR TOOLS SUPPORT
      };
      acc[model.name] = out;
      return acc;
    }, {});
  }
  /**
   * Override settings config to remove API key setting since not needed for local instance
   * @returns {Object} Settings configuration object
   */
  get settings_config() {
    const config = super.settings_config;
    delete config["[CHAT_ADAPTER].api_key"];
    return config;
  }
  is_end_of_stream(event) {
    return event.data.includes('"done_reason"');
  }
};
var SmartChatModelOllamaRequestAdapter2 = class extends SmartChatModelRequestAdapter2 {
  /**
   * Convert request to Ollama format
   * @returns {Object} Request parameters in Ollama format
   */
  to_platform(streaming = false) {
    const ollama_body = {
      model: this.model,
      messages: this._transform_messages_to_ollama(),
      options: this._transform_parameters_to_ollama(),
      stream: streaming || this.stream
      // format: 'json', // only used for tool calls since returns JSON in content body
    };
    if (this.tools) {
      ollama_body.tools = this._transform_functions_to_tools();
      if (this.tool_choice?.function?.name) {
        ollama_body.messages[ollama_body.messages.length - 1].content += `

Use the "${this.tool_choice.function.name}" tool.`;
        ollama_body.format = "json";
      }
    }
    return {
      url: this.adapter.endpoint,
      method: "POST",
      body: JSON.stringify(ollama_body)
    };
  }
  /**
   * Transform messages to Ollama format
   * @returns {Array} Messages in Ollama format
   * @private
   */
  _transform_messages_to_ollama() {
    return this.messages.map((message) => {
      const ollama_message = {
        role: message.role,
        content: this._transform_content_to_ollama(message.content)
      };
      const images = this._extract_images_from_content(message.content);
      if (images.length > 0) {
        ollama_message.images = images.map((img) => img.replace(/^data:image\/[^;]+;base64,/, ""));
      }
      return ollama_message;
    });
  }
  /**
   * Transform content to Ollama format
   * @param {string|Array} content - Message content
   * @returns {string} Content in Ollama format
   * @private
   */
  _transform_content_to_ollama(content) {
    if (Array.isArray(content)) {
      return content.filter((item) => item.type === "text").map((item) => item.text).join("\n");
    }
    return content;
  }
  /**
   * Extract images from content
   * @param {string|Array} content - Message content
   * @returns {Array} Array of image URLs
   * @private
   */
  _extract_images_from_content(content) {
    if (!Array.isArray(content)) return [];
    return content.filter((item) => item.type === "image_url").map((item) => item.image_url.url);
  }
  /**
   * Transform functions to tools format
   * @returns {Array} Tools array in Ollama format
   * @private
   */
  _transform_functions_to_tools() {
    return this.tools;
  }
  /**
   * Transform parameters to Ollama options format
   * @returns {Object} Options in Ollama format
   * @private
   */
  _transform_parameters_to_ollama() {
    const options = {};
    if (this.max_tokens) options.num_predict = this.max_tokens;
    if (this.temperature) options.temperature = this.temperature;
    if (this.top_p) options.top_p = this.top_p;
    if (this.frequency_penalty) options.frequency_penalty = this.frequency_penalty;
    if (this.presence_penalty) options.presence_penalty = this.presence_penalty;
    return options;
  }
};
var SmartChatModelOllamaResponseAdapter2 = class extends SmartChatModelResponseAdapter2 {
  static get platform_res() {
    return {
      model: "",
      created_at: null,
      message: {
        role: "",
        content: ""
      },
      total_duration: 0,
      load_duration: 0,
      prompt_eval_count: 0,
      prompt_eval_duration: 0,
      eval_count: 0,
      eval_duration: 0
    };
  }
  /**
   * Convert response to OpenAI format
   * @returns {Object} Response in OpenAI format
   */
  to_openai() {
    return {
      id: this._res.created_at,
      object: "chat.completion",
      created: Date.now(),
      model: this._res.model,
      choices: [
        {
          index: 0,
          message: this._transform_message_to_openai(),
          finish_reason: this._res.done_reason
        }
      ],
      usage: this._transform_usage_to_openai()
    };
  }
  /**
   * Transform message to OpenAI format
   * @returns {Object} Message in OpenAI format
   * @private
   */
  _transform_message_to_openai() {
    return {
      role: this._res.message.role,
      content: this._res.message.content,
      tool_calls: this._res.message.tool_calls
    };
  }
  /**
   * Transform usage statistics to OpenAI format
   * @returns {Object} Usage statistics in OpenAI format
   * @private
   */
  _transform_usage_to_openai() {
    return {
      prompt_tokens: this._res.prompt_eval_count || 0,
      completion_tokens: this._res.eval_count || 0,
      total_tokens: (this._res.prompt_eval_count || 0) + (this._res.eval_count || 0)
    };
  }
  /**
   * Parse chunk adds delta to content as expected output format
   */
  handle_chunk(chunk) {
    chunk = JSON.parse(chunk || "{}");
    if (chunk.created_at && !this._res.created_at) {
      this._res.created_at = chunk.created_at;
    }
    if (chunk.message?.content) {
      this._res.message.content += chunk.message.content;
    }
    if (chunk.message?.role) {
      this._res.message.role = chunk.message.role;
    }
    if (chunk.model) {
      this._res.model = chunk.model;
    }
    if (chunk.message?.tool_calls) {
      if (!this._res.message.tool_calls) {
        this._res.message.tool_calls = [{
          id: "",
          type: "function",
          function: {
            name: "",
            arguments: ""
          }
        }];
      }
      if (chunk.message.tool_calls[0].id) {
        this._res.message.tool_calls[0].id += chunk.message.tool_calls[0].id;
      }
      if (chunk.message.tool_calls[0].function.name) {
        this._res.message.tool_calls[0].function.name += chunk.message.tool_calls[0].function.name;
      }
      if (chunk.message.tool_calls[0].function.arguments) {
        if (typeof chunk.message.tool_calls[0].function.arguments === "string") {
          this._res.message.tool_calls[0].function.arguments += chunk.message.tool_calls[0].function.arguments;
        } else {
          this._res.message.tool_calls[0].function.arguments = chunk.message.tool_calls[0].function.arguments;
        }
      }
    }
  }
};

// node_modules/smart-chat-model/adapters/_custom.js
var adapters_map2 = {
  "openai": {
    req: SmartChatModelRequestAdapter2,
    res: SmartChatModelResponseAdapter2
  },
  "anthropic": {
    req: SmartChatModelAnthropicRequestAdapter2,
    res: SmartChatModelAnthropicResponseAdapter2
  },
  "gemini": {
    req: SmartChatModelGeminiRequestAdapter2,
    res: SmartChatModelGeminiResponseAdapter2
  },
  "lm_studio": {
    req: SmartChatModelLmStudioRequestAdapter2,
    res: SmartChatModelLmStudioResponseAdapter2
  },
  "ollama": {
    req: SmartChatModelOllamaRequestAdapter2,
    res: SmartChatModelOllamaResponseAdapter2
  }
};
var SmartChatModelCustomAdapter2 = class extends SmartChatModelApiAdapter2 {
  static key = "custom";
  static defaults = {
    description: "Custom API (Local or Remote, OpenAI format)",
    type: "API",
    /**
     * new default property: 'api_adapter' indicates which
     * request/response adapter set to use internally
     */
    api_adapter: "openai"
  };
  /**
   * Provide dynamic request/response classes
   * based on current adapter_config.api_adapter setting
   * ----------------------------------------------------
   */
  /**
   * @override
   * @returns {typeof SmartChatModelRequestAdapter}
   */
  get req_adapter() {
    const adapter_name = this.adapter_config.api_adapter || "openai";
    const map_entry = adapters_map2[adapter_name];
    return map_entry && map_entry.req ? map_entry.req : SmartChatModelRequestAdapter2;
  }
  /**
   * @override
   * @returns {typeof SmartChatModelResponseAdapter}
   */
  get res_adapter() {
    const adapter_name = this.adapter_config.api_adapter || "openai";
    const map_entry = adapters_map2[adapter_name];
    return map_entry && map_entry.res ? map_entry.res : SmartChatModelResponseAdapter2;
  }
  /**
   * Synthesize a custom endpoint from the config fields.
   * All fields are optional; fallback to a minimal default.
   * @returns {string}
   */
  get endpoint() {
    const protocol = this.adapter_config.protocol || "http";
    const hostname = this.adapter_config.hostname || "localhost";
    const port = this.adapter_config.port ? `:${this.adapter_config.port}` : "";
    let path = this.adapter_config.path || "";
    if (path && !path.startsWith("/")) path = `/${path}`;
    return `${protocol}://${hostname}${port}${path}`;
  }
  get_adapters_as_options() {
    return Object.keys(adapters_map2).map((adapter_name) => ({ value: adapter_name, name: adapter_name }));
  }
  /**
   * Provide custom settings for configuring
   * the user-defined fields plus the new 'api_adapter'.
   * @override
   * @returns {Object} settings configuration
   */
  get settings_config() {
    return {
      /**
       * Select which specialized request/response adapter
       * you'd like to use for your custom endpoint.
       */
      "[CHAT_ADAPTER].api_adapter": {
        name: "API Adapter",
        type: "dropdown",
        description: "Pick a built-in or external adapter to parse request/response data.",
        // Provide a short selection set, or dynamically gather from keys of adapters_map
        options_callback: "adapter.get_adapters_as_options",
        default: "openai"
      },
      "[CHAT_ADAPTER].id": {
        name: "Model Name",
        type: "text",
        description: "Enter the model name for your endpoint if needed."
      },
      "[CHAT_ADAPTER].protocol": {
        name: "Protocol",
        type: "text",
        description: "e.g. http or https"
      },
      "[CHAT_ADAPTER].hostname": {
        name: "Hostname",
        type: "text",
        description: "e.g. localhost or some.remote.host"
      },
      "[CHAT_ADAPTER].port": {
        name: "Port",
        type: "number",
        description: "Port number or leave blank"
      },
      "[CHAT_ADAPTER].path": {
        name: "Path",
        type: "text",
        description: "Path portion of the URL (leading slash optional)"
      },
      "[CHAT_ADAPTER].streaming": {
        name: "Streaming",
        type: "toggle",
        description: "Enable streaming if your API supports it."
      },
      "[CHAT_ADAPTER].max_input_tokens": {
        name: "Max Input Tokens",
        type: "number",
        description: "Max number of tokens your model can handle in the prompt."
      },
      "[CHAT_ADAPTER].api_key": {
        name: "API Key",
        type: "password",
        description: "If your service requires an API key, add it here."
      }
    };
  }
  /**
   * Return 'true' for get_models params since user might
   * not rely on auto-populating. 
   * @override
   * @returns {true}
   */
  validate_get_models_params() {
    return true;
  }
  /**
   * Unlike most API-based adapters, we do NOT force the user to have model_key set.
   * So we override validate_config() to skip the "No model selected" error.
   * Since this is a custom adapter, the onus is on the user to configure it correctly.
   * @override
   * @returns {Object} { valid: boolean, message: string }
   */
  validate_config() {
    return { valid: true, message: "Configuration is valid." };
  }
};

// node_modules/smart-chat-model/adapters/groq.js
var SmartChatModelGroqAdapter2 = class extends SmartChatModelApiAdapter2 {
  static key = "groq";
  static defaults = {
    description: "Groq",
    type: "API",
    endpoint: "https://api.groq.com/openai/v1/chat/completions",
    streaming: true,
    adapter: "Groq",
    models_endpoint: "https://api.groq.com/openai/v1/models",
    default_model: "llama3-8b-8192",
    signup_url: "https://groq.com",
    can_use_tools: true
  };
  /**
   * Request adapter class
   * @returns {typeof SmartChatModelGroqRequestAdapter}
   */
  get req_adapter() {
    return SmartChatModelGroqRequestAdapter2;
  }
  /**
   * Response adapter class
   * @returns {typeof SmartChatModelGroqResponseAdapter}
   */
  get res_adapter() {
    return SmartChatModelGroqResponseAdapter2;
  }
  /**
   * Retrieve the list of models from Groq's API.
   * @returns {Promise<Object>} A dictionary of models keyed by their id
   */
  async get_models(refresh = false) {
    if (!refresh && this.adapter_config?.models && Object.keys(this.adapter_config.models).length > 0) {
      return this.adapter_config.models;
    }
    const request_params = {
      url: this.models_endpoint,
      method: "GET",
      headers: {
        "Authorization": `Bearer ${this.api_key}`
      }
    };
    try {
      const resp = await this.http_adapter.request(request_params);
      const data = await resp.json();
      const model_data = this.parse_model_data(data);
      this.adapter_settings.models = model_data;
      this.model.re_render_settings();
      return model_data;
    } catch (error) {
      console.error("Failed to fetch Groq model data:", error);
      return { "_": { id: "Failed to fetch models from Groq" } };
    }
  }
  /**
   * Parse model data from Groq API format to a dictionary keyed by model ID.
   * The API returns a list of model objects like:
   * {
   *   "object": "list",
   *   "data": [ { "id": "...", "object": "model", ... }, ... ]
   * }
   * 
   * We'll convert each model to:
   * {
   *   model_name: model.id,
   *   id: model.id,
   *   max_input_tokens: model.context_window,
   *   description: `Owned by: ${model.owned_by}, context: ${model.context_window}`,
   *   multimodal: Check if model name or description suggests multimodality
   * }
   */
  parse_model_data(model_data) {
    if (model_data.object !== "list" || !Array.isArray(model_data.data)) {
      return { "_": { id: "No models found." } };
    }
    const parsed = {};
    for (const m of model_data.data) {
      parsed[m.id] = {
        model_name: m.id,
        id: m.id,
        max_input_tokens: m.context_window || 8192,
        description: `Owned by: ${m.owned_by}, context: ${m.context_window}`,
        // A basic heuristic for multimodal: if 'vision' or 'tool' is in model id
        // Adjust as needed based on known capabilities
        multimodal: m.id.includes("vision")
      };
    }
    return parsed;
  }
  /**
   * Validate configuration for Groq
   * @returns {Object} { valid: boolean, message: string }
   */
  validate_config() {
    if (!this.adapter_config.model_key) return { valid: false, message: "No model selected." };
    if (!this.api_key) {
      return { valid: false, message: "API key is missing." };
    }
    return { valid: true, message: "Configuration is valid." };
  }
};
var SmartChatModelGroqRequestAdapter2 = class extends SmartChatModelRequestAdapter2 {
  _get_openai_content(message) {
    if (["assistant", "tool"].includes(message.role)) {
      if (Array.isArray(message.content)) {
        return message.content.map((part) => {
          if (typeof part === "string") return part;
          if (part?.text) return part.text;
          return "";
        }).join("\n");
      }
    }
    return message.content;
  }
};
var SmartChatModelGroqResponseAdapter2 = class extends SmartChatModelResponseAdapter2 {
};

// src/smart_env.config.js
var import_obsidian26 = require("obsidian");

// node_modules/smart-collections/utils/collection_instance_name_from.js
function collection_instance_name_from2(class_name) {
  if (class_name.endsWith("Item")) {
    return class_name.replace(/Item$/, "").toLowerCase();
  }
  return class_name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase().replace(/y$/, "ie") + "s";
}

// node_modules/smart-collections/utils/helpers.js
function create_uid2(data) {
  const str = JSON.stringify(data);
  let hash = 0;
  if (str.length === 0) return hash;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
    if (hash < 0) hash = hash * -1;
  }
  return hash.toString() + str.length;
}
function deep_merge3(target, source2) {
  for (const key in source2) {
    if (source2.hasOwnProperty(key)) {
      if (is_obj(source2[key]) && is_obj(target[key])) deep_merge3(target[key], source2[key]);
      else target[key] = source2[key];
    }
  }
  return target;
  function is_obj(item) {
    return item && typeof item === "object" && !Array.isArray(item);
  }
}

// node_modules/smart-collections/utils/deep_equal.js
function deep_equal2(obj1, obj2, visited = /* @__PURE__ */ new WeakMap()) {
  if (obj1 === obj2) return true;
  if (obj1 === null || obj2 === null || obj1 === void 0 || obj2 === void 0) return false;
  if (typeof obj1 !== typeof obj2 || Array.isArray(obj1) !== Array.isArray(obj2)) return false;
  if (Array.isArray(obj1)) {
    if (obj1.length !== obj2.length) return false;
    return obj1.every((item, index) => deep_equal2(item, obj2[index], visited));
  }
  if (typeof obj1 === "object") {
    if (visited.has(obj1)) return visited.get(obj1) === obj2;
    visited.set(obj1, obj2);
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length) return false;
    return keys1.every((key) => deep_equal2(obj1[key], obj2[key], visited));
  }
  return obj1 === obj2;
}

// node_modules/smart-collections/item.js
var CollectionItem2 = class _CollectionItem {
  /**
   * Default properties for an instance of CollectionItem.
   * Override in subclasses to define different defaults.
   * @returns {Object}
   */
  static get defaults() {
    return {
      data: {}
    };
  }
  /**
   * @param {Object} env - The environment/context.
   * @param {Object|null} [data=null] - Initial data for the item.
   */
  constructor(env, data = null) {
    env.create_env_getter(this);
    this.config = this.env?.config;
    this.merge_defaults();
    if (data) deep_merge3(this.data, data);
    if (!this.data.class_name) this.data.class_name = this.collection.item_class_name;
  }
  /**
   * Loads an item from data and initializes it.
   * @param {Object} env
   * @param {Object} data
   * @returns {CollectionItem}
   */
  static load(env, data) {
    const item = new this(env, data);
    item.init();
    return item;
  }
  /**
   * Merge default properties from the entire inheritance chain.
   * @private
   */
  merge_defaults() {
    let current_class = this.constructor;
    while (current_class) {
      for (let key in current_class.defaults) {
        const default_val = current_class.defaults[key];
        if (typeof default_val === "object") {
          this[key] = { ...default_val, ...this[key] };
        } else {
          this[key] = this[key] === void 0 ? default_val : this[key];
        }
      }
      current_class = Object.getPrototypeOf(current_class);
    }
  }
  /**
   * Generates or retrieves a unique key for the item.
   * Key syntax supports:
   * - `[i]` for sequences
   * - `/` for super-sources (groups, directories, clusters)
   * - `#` for sub-sources (blocks)
   * @returns {string} The unique key
   */
  get_key() {
    return create_uid2(this.data);
  }
  /**
   * Updates the item data and returns true if changed.
   * @param {Object} data
   * @returns {boolean} True if data changed.
   */
  update_data(data) {
    const sanitized_data = this.sanitize_data(data);
    const current_data = { ...this.data };
    deep_merge3(current_data, sanitized_data);
    const changed = !deep_equal2(this.data, current_data);
    if (!changed) return false;
    this.data = current_data;
    return true;
  }
  /**
   * Sanitizes data for saving. Ensures no circular references.
   * @param {*} data
   * @returns {*} Sanitized data.
   */
  sanitize_data(data) {
    if (data instanceof _CollectionItem) return data.ref;
    if (Array.isArray(data)) return data.map((val) => this.sanitize_data(val));
    if (typeof data === "object" && data !== null) {
      return Object.keys(data).reduce((acc, key) => {
        acc[key] = this.sanitize_data(data[key]);
        return acc;
      }, {});
    }
    return data;
  }
  /**
   * Initializes the item. Override as needed.
   * @param {Object} [input_data] - Additional data that might be provided on creation.
   */
  init(input_data) {
  }
  /**
   * Queues this item for saving.
   */
  queue_save() {
    this._queue_save = true;
  }
  /**
   * Saves this item using its data adapter.
   * @returns {Promise<void>}
   */
  async save() {
    try {
      await this.data_adapter.save_item(this);
      this.init();
    } catch (err) {
      this._queue_save = true;
      console.error(err, err.stack);
    }
  }
  /**
   * Queues this item for loading.
   */
  queue_load() {
    this._queue_load = true;
  }
  /**
   * Loads this item using its data adapter.
   * @returns {Promise<void>}
   */
  async load() {
    try {
      await this.data_adapter.load_item(this);
      this.init();
    } catch (err) {
      this._load_error = err;
      this.on_load_error(err);
    }
  }
  /**
   * Handles load errors by re-queuing for load.
   * Override if needed.
   * @param {Error} err
   */
  on_load_error(err) {
    this.queue_load();
  }
  /**
   * Validates the item before saving. Checks for presence and validity of key.
   * @returns {boolean}
   */
  validate_save() {
    if (!this.key) return false;
    if (this.key.trim() === "") return false;
    if (this.key === "undefined") return false;
    return true;
  }
  /**
   * Marks this item as deleted. This does not immediately remove it from memory,
   * but queues a save that will result in the item being removed from persistent storage.
   */
  delete() {
    this.deleted = true;
    this.queue_save();
  }
  /**
   * Filters items in the collection based on provided options.
   * functional filter (returns true or false) for filtering items in collection; called by collection class
   * @param {Object} filter_opts - Filtering options.
   * @param {string} [filter_opts.exclude_key] - A single key to exclude.
   * @param {string[]} [filter_opts.exclude_keys] - An array of keys to exclude. If exclude_key is provided, it's added to this array.
   * @param {string} [filter_opts.exclude_key_starts_with] - Exclude keys starting with this string.
   * @param {string[]} [filter_opts.exclude_key_starts_with_any] - Exclude keys starting with any of these strings.
   * @param {string} [filter_opts.exclude_key_includes] - Exclude keys that include this string.
   * @param {string[]} [filter_opts.exclude_key_includes_any] - Exclude keys that include any of these strings.
   * @param {string} [filter_opts.exclude_key_ends_with] - Exclude keys ending with this string.
   * @param {string[]} [filter_opts.exclude_key_ends_with_any] - Exclude keys ending with any of these strings.
   * @param {string} [filter_opts.key_ends_with] - Include only keys ending with this string.
   * @param {string} [filter_opts.key_starts_with] - Include only keys starting with this string.
   * @param {string[]} [filter_opts.key_starts_with_any] - Include only keys starting with any of these strings.
   * @param {string} [filter_opts.key_includes] - Include only keys that include this string.
   * @returns {boolean} True if the item passes the filter, false otherwise.
   */
  filter(filter_opts = {}) {
    const {
      exclude_key,
      exclude_keys = exclude_key ? [exclude_key] : [],
      exclude_key_starts_with,
      exclude_key_starts_with_any,
      exclude_key_includes,
      exclude_key_includes_any,
      exclude_key_ends_with,
      exclude_key_ends_with_any,
      key_ends_with,
      key_starts_with,
      key_starts_with_any,
      key_includes,
      key_includes_any
    } = filter_opts;
    if (exclude_keys?.includes(this.key)) return false;
    if (exclude_key_starts_with && this.key.startsWith(exclude_key_starts_with)) return false;
    if (exclude_key_starts_with_any && exclude_key_starts_with_any.some((prefix) => this.key.startsWith(prefix))) return false;
    if (exclude_key_includes && this.key.includes(exclude_key_includes)) return false;
    if (exclude_key_includes_any && exclude_key_includes_any.some((include) => this.key.includes(include))) return false;
    if (exclude_key_ends_with && this.key.endsWith(exclude_key_ends_with)) return false;
    if (exclude_key_ends_with_any && exclude_key_ends_with_any.some((suffix) => this.key.endsWith(suffix))) return false;
    if (key_ends_with && !this.key.endsWith(key_ends_with)) return false;
    if (key_starts_with && !this.key.startsWith(key_starts_with)) return false;
    if (key_starts_with_any && !key_starts_with_any.some((prefix) => this.key.startsWith(prefix))) return false;
    if (key_includes && !this.key.includes(key_includes)) return false;
    if (key_includes_any && !key_includes_any.some((include) => this.key.includes(include))) return false;
    return true;
  }
  /**
   * Parses item data for additional processing. Override as needed.
   */
  parse() {
  }
  get actions() {
    if (!this._actions) {
      this._actions = Object.entries(this.env.opts.items[this.item_type_key].actions || {}).reduce((acc, [k, v]) => {
        acc[k] = v.bind(this);
        return acc;
      }, {});
    }
    return this._actions;
  }
  /**
   * Derives the collection key from the class name.
   * @returns {string}
   */
  static get collection_key() {
    let name = this.name;
    if (name.match(/\d$/)) name = name.slice(0, -1);
    return collection_instance_name_from2(name);
  }
  /**
   * @returns {string} The collection key for this item.
   */
  get collection_key() {
    let name = this.constructor.name;
    if (name.match(/\d$/)) name = name.slice(0, -1);
    return collection_instance_name_from2(name);
  }
  /**
   * Retrieves the parent collection from the environment.
   * @returns {Collection}
   */
  get collection() {
    return this.env[this.collection_key];
  }
  /**
   * @returns {string} The item's key.
   */
  get key() {
    return this.data?.key || this.get_key();
  }
  get item_type_key() {
    let name = this.constructor.name;
    if (name.match(/\d$/)) name = name.slice(0, -1);
    return camel_case_to_snake_case3(name);
  }
  /**
   * A simple reference object for this item.
   * @returns {{collection_key: string, key: string}}
   */
  get ref() {
    return { collection_key: this.collection_key, key: this.key };
  }
  /**
   * @returns {Object} The data adapter for this item's collection.
   */
  get data_adapter() {
    return this.collection.data_adapter;
  }
  /**
   * @returns {Object} The filesystem adapter.
   */
  get data_fs() {
    return this.collection.data_fs;
  }
  /**
   * Access to collection-level settings.
   * @returns {Object}
   */
  get settings() {
    if (!this.env.settings[this.collection_key]) this.env.settings[this.collection_key] = {};
    return this.env.settings[this.collection_key];
  }
  set settings(settings) {
    this.env.settings[this.collection_key] = settings;
    this.env.smart_settings.save();
  }
  // /**
  //  * Render this item into a container using the item's component.
  //  * @deprecated 2024-12-02 Use explicit component pattern from environment
  //  * @param {HTMLElement} container
  //  * @param {Object} opts
  //  * @returns {Promise<HTMLElement>}
  //  */
  // async render_item(container, opts = {}) {
  //   const frag = await this.component.call(this.smart_view, this, opts);
  //   this.env.smart_view.empty(container);
  //   container.appendChild(frag);
  //   return container;
  // }
  /**
   * @deprecated use env.smart_view
   * @returns {Object}
   */
  get smart_view() {
    if (!this._smart_view) this._smart_view = this.env.init_module("smart_view");
    return this._smart_view;
  }
  // /**
  //  * Override in child classes to set the component for this item
  //  * @deprecated 2024-12-02
  //  * @returns {Function} The render function for this component
  //  */
  // get component() { return item_component; }
};
function camel_case_to_snake_case3(str) {
  const result = str.replace(/([A-Z])/g, (match) => `_${match.toLowerCase()}`).replace(/^_/, "").replace(/2$/, "");
  return result;
}

// node_modules/smart-collections/collection.js
var AsyncFunction2 = Object.getPrototypeOf(async function() {
}).constructor;
var Collection2 = class {
  /**
   * Constructs a new Collection instance.
   *
   * @param {Object} env - The environment context containing configurations and adapters.
   * @param {Object} [opts={}] - Optional configuration.
   * @param {string} [opts.collection_key] - Custom key to override default collection name.
   * @param {string} [opts.data_dir] - Custom data directory path.
   * @param {boolean} [opts.prevent_load_on_init] - Whether to prevent loading items on initialization.
   */
  constructor(env, opts = {}) {
    env.create_env_getter(this);
    this.opts = opts;
    if (opts.collection_key) this.collection_key = opts.collection_key;
    this.env[this.collection_key] = this;
    this.config = this.env.config;
    this.items = {};
    this.loaded = null;
    this._loading = false;
    this.load_time_ms = null;
    this.settings_container = null;
  }
  /**
   * Initializes a new collection in the environment. Override in subclass if needed.
   *
   * @param {Object} env
   * @param {Object} [opts={}]
   * @returns {Promise<void>}
   */
  static async init(env, opts = {}) {
    env[this.collection_key] = new this(env, opts);
    await env[this.collection_key].init();
    env.collections[this.collection_key] = "init";
  }
  /**
   * The unique collection key derived from the class name.
   * @returns {string}
   */
  static get collection_key() {
    let name = this.name;
    if (name.match(/\d$/)) name = name.slice(0, -1);
    return name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
  }
  /**
   * Instance-level init. Override in subclasses if necessary.
   * @returns {Promise<void>}
   */
  async init() {
  }
  /**
   * Creates or updates an item in the collection.
   * - If `data` includes a key that matches an existing item, that item is updated.
   * - Otherwise, a new item is created.
   * After updating or creating, the item is validated. If validation fails, the item is logged and returned without being saved.
   * If validation succeeds for a new item, it is added to the collection and marked for saving.
   *
   * If the item’s `init()` method is async, a promise is returned that resolves once init completes.
   *
   * @param {Object} [data={}] - Data for creating/updating an item.
   * @returns {Promise<Item>|Item} The created or updated item. May return a promise if `init()` is async.
   */
  create_or_update(data = {}) {
    const existing_item = this.find_by(data);
    const item = existing_item ? existing_item : new this.item_type(this.env);
    item._queue_save = !existing_item;
    const data_changed = item.update_data(data);
    if (!existing_item && !item.validate_save()) {
      return item;
    }
    if (!existing_item) {
      this.set(item);
    }
    if (existing_item && !data_changed) return existing_item;
    if (item.init instanceof AsyncFunction2) {
      return new Promise((resolve) => {
        item.init(data).then(() => resolve(item));
      });
    }
    item.init(data);
    return item;
  }
  /**
   * Finds an item by partial data match (first checks key). If `data.key` provided,
   * returns the item with that key; otherwise attempts a match by merging data.
   *
   * @param {Object} data - Data to match against.
   * @returns {Item|null}
   */
  find_by(data) {
    if (data.key) return this.get(data.key);
    const temp = new this.item_type(this.env);
    const temp_data = JSON.parse(JSON.stringify(data, temp.sanitize_data(data)));
    deep_merge3(temp.data, temp_data);
    return temp.key ? this.get(temp.key) : null;
  }
  /**
   * Filters items based on provided filter options or a custom function.
   *
   * @param {Object|Function} [filter_opts={}] - Filter options or a predicate function.
   * @returns {Item[]} Array of filtered items.
   */
  filter(filter_opts = {}) {
    if (typeof filter_opts === "function") {
      return Object.values(this.items).filter(filter_opts);
    }
    filter_opts = this.prepare_filter(filter_opts);
    const results = [];
    const { first_n } = filter_opts;
    for (const item of Object.values(this.items)) {
      if (first_n && results.length >= first_n) break;
      if (item.filter(filter_opts)) results.push(item);
    }
    return results;
  }
  /**
   * Alias for `filter()`
   * @param {Object|Function} filter_opts
   * @returns {Item[]}
   */
  list(filter_opts) {
    return this.filter(filter_opts);
  }
  /**
   * Prepares filter options. Can be overridden by subclasses to normalize filter options.
   *
   * @param {Object} filter_opts
   * @returns {Object} Prepared filter options.
   */
  prepare_filter(filter_opts) {
    return filter_opts;
  }
  /**
   * Retrieves an item by key.
   * @param {string} key
   * @returns {Item|undefined}
   */
  get(key) {
    return this.items[key];
  }
  /**
   * Retrieves multiple items by an array of keys.
   * @param {string[]} keys
   * @returns {Item[]}
   */
  get_many(keys = []) {
    if (!Array.isArray(keys)) {
      console.error("get_many called with non-array keys:", keys);
      return [];
    }
    return keys.map((key) => this.get(key)).filter(Boolean);
  }
  /**
   * Retrieves a random item from the collection, optionally filtered by options.
   * @param {Object} [opts]
   * @returns {Item|undefined}
   */
  get_rand(opts = null) {
    if (opts) {
      const filtered = this.filter(opts);
      return filtered[Math.floor(Math.random() * filtered.length)];
    }
    const keys = this.keys;
    return this.items[keys[Math.floor(Math.random() * keys.length)]];
  }
  /**
   * Adds or updates an item in the collection.
   * @param {Item} item
   */
  set(item) {
    if (!item.key) throw new Error("Item must have a key property");
    this.items[item.key] = item;
  }
  /**
   * Updates multiple items by their keys.
   * @param {string[]} keys
   * @param {Object} data
   */
  update_many(keys = [], data = {}) {
    this.get_many(keys).forEach((item) => item.update_data(data));
  }
  /**
   * Clears all items from the collection.
   */
  clear() {
    this.items = {};
  }
  /**
   * @returns {string} The collection key, can be overridden by opts.collection_key
   */
  get collection_key() {
    return this._collection_key ? this._collection_key : this.constructor.collection_key;
  }
  set collection_key(key) {
    this._collection_key = key;
  }
  /**
   * Lazily initializes and returns the data adapter instance for this collection.
   * @returns {Object} The data adapter instance.
   */
  get data_adapter() {
    if (!this._data_adapter) {
      const AdapterClass = this.get_adapter_class("data");
      this._data_adapter = new AdapterClass(this);
    }
    return this._data_adapter;
  }
  get_adapter_class(type) {
    const config = this.env.opts.collections?.[this.collection_key];
    const adapter_key = type + "_adapter";
    const adapter_module = config?.[adapter_key] ?? this.env.opts.collections?.smart_collections?.[adapter_key];
    if (typeof adapter_module === "function") return adapter_module;
    if (typeof adapter_module?.collection === "function") return adapter_module.collection;
    throw new Error(`No '${type}' adapter class found for ${this.collection_key} or smart_collections`);
  }
  /**
   * Data directory strategy for this collection. Defaults to 'multi'.
   * @returns {string}
   */
  get data_dir() {
    return this.collection_key;
  }
  /**
   * File system adapter from the environment.
   * @returns {Object}
   */
  get data_fs() {
    return this.env.data_fs;
  }
  /**
   * Derives the corresponding item class name based on this collection's class name.
   * @returns {string}
   */
  get item_class_name() {
    let name = this.constructor.name;
    if (name.match(/\d$/)) name = name.slice(0, -1);
    if (name.endsWith("ies")) return name.slice(0, -3) + "y";
    else if (name.endsWith("s")) return name.slice(0, -1);
    return name + "Item";
  }
  /**
   * Derives a readable item name from the item class name.
   * @returns {string}
   */
  get item_name() {
    return this.item_class_name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
  }
  /**
   * Retrieves the item type (constructor) from the environment.
   * @returns {Function} Item constructor.
   */
  get item_type() {
    if (this.opts.item_type) return this.opts.item_type;
    return this.env.item_types[this.item_class_name];
  }
  /**
   * Returns an array of all keys in the collection.
   * @returns {string[]}
   */
  get keys() {
    return Object.keys(this.items);
  }
  /**
   * @deprecated use data_adapter instead (2024-09-14)
   */
  get adapter() {
    return this.data_adapter;
  }
  /**
   * @method process_save_queue
   * @description 
   * Saves items flagged for saving (_queue_save) back to AJSON or SQLite. This ensures persistent storage 
   * of any updates made since last load/import. This method also writes changes to disk (AJSON files or DB).
   */
  async process_save_queue(opts = {}) {
    if (opts.force) {
      Object.values(this.items).forEach((item) => item._queue_save = true);
    }
    await this.data_adapter.process_save_queue(opts);
  }
  /**
   * @alias process_save_queue
   * @returns {Promise<void>}
   */
  async save(opts = {}) {
    await this.process_save_queue(opts);
  }
  /**
   * @method process_load_queue
   * @description 
   * Loads items that have been flagged for loading (_queue_load). This may involve 
   * reading from AJSON/SQLite or re-importing from markdown if needed. 
   * Called once initial environment is ready and collections are known.
   */
  async process_load_queue() {
    await this.data_adapter.process_load_queue();
  }
  /**
   * Retrieves processed settings configuration.
   * @returns {Object}
   */
  get settings_config() {
    return this.process_settings_config({});
  }
  /**
   * Processes given settings config, adding prefixes and handling conditionals.
   *
   * @private
   * @param {Object} _settings_config
   * @param {string} [prefix='']
   * @returns {Object}
   */
  process_settings_config(_settings_config, prefix = "") {
    const add_prefix = (key) => prefix && !key.includes(`${prefix}.`) ? `${prefix}.${key}` : key;
    return Object.entries(_settings_config).reduce((acc, [key, val]) => {
      let new_val = { ...val };
      if (new_val.conditional) {
        if (!new_val.conditional(this)) return acc;
        delete new_val.conditional;
      }
      if (new_val.callback) new_val.callback = add_prefix(new_val.callback);
      if (new_val.btn_callback) new_val.btn_callback = add_prefix(new_val.btn_callback);
      if (new_val.options_callback) new_val.options_callback = add_prefix(new_val.options_callback);
      const new_key = add_prefix(this.process_setting_key(key));
      acc[new_key] = new_val;
      return acc;
    }, {});
  }
  /**
   * Processes an individual setting key. Override if needed.
   * @param {string} key
   * @returns {string}
   */
  process_setting_key(key) {
    return key;
  }
  /**
   * Default settings for this collection. Override in subclasses as needed.
   * @returns {Object}
   */
  get default_settings() {
    return {};
  }
  /**
   * Current settings for the collection.
   * Initializes with default settings if none exist.
   * @returns {Object}
   */
  get settings() {
    if (!this.env.settings[this.collection_key]) {
      this.env.settings[this.collection_key] = this.default_settings;
    }
    return this.env.settings[this.collection_key];
  }
  /**
   * @deprecated use env.smart_view instead
   * @returns {Object} smart_view instance
   */
  get smart_view() {
    if (!this._smart_view) this._smart_view = this.env.init_module("smart_view");
    return this._smart_view;
  }
  /**
   * Renders the settings for the collection into a given container.
   * @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
   * @param {HTMLElement} [container=this.settings_container]
   * @param {Object} opts
   * @returns {Promise<HTMLElement>}
   */
  async render_settings(container = this.settings_container, opts = {}) {
    return await this.render_collection_settings(container, opts);
  }
  /**
   * Helper function to render collection settings.
   * @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
   * @param {HTMLElement} [container=this.settings_container]
   * @param {Object} opts
   * @returns {Promise<HTMLElement>}
   */
  async render_collection_settings(container = this.settings_container, opts = {}) {
    if (container && (!this.settings_container || this.settings_container !== container)) {
      this.settings_container = container;
    } else if (!container) {
      container = this.env.smart_view.create_doc_fragment("<div></div>");
    }
    this.env.smart_view.safe_inner_html(container, `<div class="sc-loading">Loading ${this.collection_key} settings...</div>`);
    const frag = await this.env.render_component("settings", this, opts);
    this.env.smart_view.empty(container);
    container.appendChild(frag);
    return container;
  }
  /**
   * Unloads collection data from memory.
   */
  unload() {
    this.clear();
    this.unloaded = true;
    this.env.collections[this.collection_key] = null;
  }
  // only show process notice if taking longer than 1 second
  show_process_notice(process2, opts = {}) {
    if (!this.debounce_process_notice) this.debounce_process_notice = {};
    this.debounce_process_notice[process2] = setTimeout(() => {
      this.debounce_process_notice[process2] = null;
      this.env.notices?.show(process2, { collection_key: this.collection_key, ...opts });
    }, 1e3);
  }
  clear_process_notice(process2) {
    if (this.debounce_process_notice?.[process2]) {
      clearTimeout(this.debounce_process_notice[process2]);
      this.debounce_process_notice[process2] = null;
    } else {
      this.env.notices?.remove(process2);
    }
  }
};

// node_modules/smart-entities/adapters/_adapter.js
var EntitiesVectorAdapter2 = class {
  /**
   * @constructor
   * @param {Object} collection - The collection (SmartEntities or derived class) instance.
   */
  constructor(collection) {
    this.collection = collection;
  }
  /**
   * Find the nearest entities to the given vector.
   * @async
   * @param {number[]} vec - The reference vector.
   * @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
   * @returns {Promise<Array<{item:Object, score:number}>>} Array of results sorted by score descending.
   * @throws {Error} Not implemented by default.
   */
  async nearest(vec, filter = {}) {
    throw new Error("EntitiesVectorAdapter.nearest() not implemented");
  }
  /**
   * Find the furthest entities from the given vector.
   * @async
   * @param {number[]} vec - The reference vector.
   * @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
   * @returns {Promise<Array<{item:Object, score:number}>>} Array of results sorted by score ascending (furthest).
   * @throws {Error} Not implemented by default.
   */
  async furthest(vec, filter = {}) {
    throw new Error("EntitiesVectorAdapter.furthest() not implemented");
  }
  /**
   * Embed a batch of entities.
   * @async
   * @param {Object[]} entities - Array of entity instances to embed.
   * @returns {Promise<void>}
   * @throws {Error} Not implemented by default.
   */
  async embed_batch(entities) {
    throw new Error("EntitiesVectorAdapter.embed_batch() not implemented");
  }
  /**
   * Process a queue of entities waiting to be embedded.
   * Typically, this will call embed_batch in batches and update entities.
   * @async
   * @param {Object[]} embed_queue - Array of entities to embed.
   * @returns {Promise<void>}
   * @throws {Error} Not implemented by default.
   */
  async process_embed_queue(embed_queue) {
    throw new Error("EntitiesVectorAdapter.process_embed_queue() not implemented");
  }
};
var EntityVectorAdapter2 = class {
  /**
   * @constructor
   * @param {Object} item - The SmartEntity instance that this adapter is associated with.
   */
  constructor(item) {
    this.item = item;
  }
  /**
   * Retrieve the current vector embedding for this entity.
   * @async
   * @returns {Promise<number[]|undefined>} The entity's vector or undefined if not set.
   * @throws {Error} Not implemented by default.
   */
  async get_vec() {
    throw new Error("EntityVectorAdapter.get_vec() not implemented");
  }
  /**
   * Store/update the vector embedding for this entity.
   * @async
   * @param {number[]} vec - The vector to set.
   * @returns {Promise<void>}
   * @throws {Error} Not implemented by default.
   */
  async set_vec(vec) {
    throw new Error("EntityVectorAdapter.set_vec() not implemented");
  }
  /**
   * Delete/remove the vector embedding for this entity.
   * @async
   * @returns {Promise<void>}
   * @throws {Error} Not implemented by default.
   */
  async delete_vec() {
    throw new Error("EntityVectorAdapter.delete_vec() not implemented");
  }
};

// node_modules/smart-entities/utils/cos_sim.js
function cos_sim2(vector1, vector2) {
  if (vector1.length !== vector2.length) {
    throw new Error("Vectors must have the same length");
  }
  let dot_product = 0;
  let magnitude1 = 0;
  let magnitude2 = 0;
  const epsilon = 1e-8;
  for (let i = 0; i < vector1.length; i++) {
    dot_product += vector1[i] * vector2[i];
    magnitude1 += vector1[i] * vector1[i];
    magnitude2 += vector2[i] * vector2[i];
  }
  magnitude1 = Math.sqrt(magnitude1);
  magnitude2 = Math.sqrt(magnitude2);
  if (magnitude1 < epsilon || magnitude2 < epsilon) {
    return 0;
  }
  return dot_product / (magnitude1 * magnitude2);
}

// node_modules/smart-entities/utils/results_acc.js
function results_acc2(_acc, result, ct = 10) {
  if (_acc.results.size < ct) {
    _acc.results.add(result);
    if (_acc.results.size === ct && _acc.min === Number.POSITIVE_INFINITY) {
      let { minScore, minObj } = find_min2(_acc.results);
      _acc.min = minScore;
      _acc.minResult = minObj;
    }
  } else if (result.score > _acc.min) {
    _acc.results.add(result);
    _acc.results.delete(_acc.minResult);
    let { minScore, minObj } = find_min2(_acc.results);
    _acc.min = minScore;
    _acc.minResult = minObj;
  }
}
function furthest_acc2(_acc, result, ct = 10) {
  if (_acc.results.size < ct) {
    _acc.results.add(result);
    if (_acc.results.size === ct && _acc.max === Number.NEGATIVE_INFINITY) {
      let { maxScore, maxObj } = find_max2(_acc.results);
      _acc.max = maxScore;
      _acc.maxResult = maxObj;
    }
  } else if (result.score < _acc.max) {
    _acc.results.add(result);
    _acc.results.delete(_acc.maxResult);
    let { maxScore, maxObj } = find_max2(_acc.results);
    _acc.max = maxScore;
    _acc.maxResult = maxObj;
  }
}
function find_min2(results) {
  let minScore = Number.POSITIVE_INFINITY;
  let minObj = null;
  for (const obj of results) {
    if (obj.score < minScore) {
      minScore = obj.score;
      minObj = obj;
    }
  }
  return { minScore, minObj };
}
function find_max2(results) {
  let maxScore = Number.NEGATIVE_INFINITY;
  let maxObj = null;
  for (const obj of results) {
    if (obj.score > maxScore) {
      maxScore = obj.score;
      maxObj = obj;
    }
  }
  return { maxScore, maxObj };
}

// node_modules/smart-entities/utils/sort_by_score.js
function sort_by_score2(a, b) {
  const epsilon = 1e-9;
  const score_diff = a.score - b.score;
  if (Math.abs(score_diff) < epsilon) return 0;
  return score_diff > 0 ? -1 : 1;
}
function sort_by_score_descending2(a, b) {
  return sort_by_score2(a, b);
}
function sort_by_score_ascending2(a, b) {
  return sort_by_score2(a, b) * -1;
}

// node_modules/smart-entities/adapters/default.js
var DefaultEntitiesVectorAdapter2 = class extends EntitiesVectorAdapter2 {
  constructor(collection) {
    super(collection);
    this._is_processing_embed_queue = false;
    this._reset_embed_queue_stats();
  }
  /**
   * Find the nearest entities to the given vector.
   * @async
   * @param {number[]} vec - The reference vector.
   * @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
   * @returns {Promise<Array<{item:Object, score:number}>>} Array of results sorted by score descending.
   */
  async nearest(vec, filter = {}) {
    if (!vec || !Array.isArray(vec)) {
      throw new Error("Invalid vector input to nearest()");
    }
    const {
      limit = 50
      // TODO: default configured in settings
    } = filter;
    const nearest = this.collection.filter(filter).reduce((acc, item) => {
      if (!item.vec) return acc;
      const result = { item, score: cos_sim2(vec, item.vec) };
      results_acc2(acc, result, limit);
      return acc;
    }, { min: 0, results: /* @__PURE__ */ new Set() });
    return Array.from(nearest.results).sort(sort_by_score_descending2);
  }
  /**
   * Find the furthest entities from the given vector.
   * @async
   * @param {number[]} vec - The reference vector.
   * @param {Object} [filter={}] - Optional filters (limit, exclude, etc.)
   * @returns {Promise<Array<{item:Object, score:number}>>} Array of results sorted by score ascending (furthest).
   */
  async furthest(vec, filter = {}) {
    if (!vec || !Array.isArray(vec)) {
      throw new Error("Invalid vector input to furthest()");
    }
    const {
      limit = 50
      // TODO: default configured in settings
    } = filter;
    const furthest = this.collection.filter(filter).reduce((acc, item) => {
      if (!item.vec) return acc;
      const result = { item, score: cos_sim2(vec, item.vec) };
      furthest_acc2(acc, result, limit);
      return acc;
    }, { max: 0, results: /* @__PURE__ */ new Set() });
    return Array.from(furthest.results).sort(sort_by_score_ascending2);
  }
  /**
   * Embed a batch of entities.
   * @async
   * @param {Object[]} entities - Array of entity instances to embed.
   * @returns {Promise<void>}
   */
  async embed_batch(entities) {
    if (!this.collection.embed_model) {
      throw new Error("No embed_model found in collection for embedding");
    }
    await Promise.all(entities.map((e) => e.get_embed_input()));
    const embeddings = await this.collection.embed_model.embed_batch(entities);
    embeddings.forEach((emb, i) => {
      const entity = entities[i];
      entity.vec = emb.vec;
      entity.data.last_embed = entity.data.last_read;
      if (emb.tokens !== void 0) entity.tokens = emb.tokens;
    });
  }
  /**
   * Process a queue of entities waiting to be embedded.
   * Prevents multiple concurrent runs by using `_is_processing_embed_queue`.
   * @async
   * @returns {Promise<void>}
   */
  async process_embed_queue() {
    if (this._is_processing_embed_queue) {
      console.log("process_embed_queue is already running, skipping concurrent call.");
      return;
    }
    this._is_processing_embed_queue = true;
    try {
      if (!this.collection.embed_model.is_loaded) {
        await this.collection.embed_model.load();
      }
    } catch (e) {
      this.notices?.show("Failed to load embed_model");
      return;
    }
    try {
      const embed_queue = this.collection.embed_queue;
      this._reset_embed_queue_stats();
      if (this.collection.embed_model_key === "None") {
        console.log(`Smart Connections: No active embedding model for ${this.collection.collection_key}, skipping embedding`);
        return;
      }
      if (!this.collection.embed_model) {
        console.log(`Smart Connections: No active embedding model for ${this.collection.collection_key}, skipping embedding`);
        return;
      }
      const datetime_start = /* @__PURE__ */ new Date();
      if (!embed_queue.length) {
        console.log(`Smart Connections: No items in ${this.collection.collection_key} embed queue`);
        return;
      }
      console.log(`Time spent getting embed queue: ${(/* @__PURE__ */ new Date()).getTime() - datetime_start.getTime()}ms`);
      console.log(`Processing ${this.collection.collection_key} embed queue: ${embed_queue.length} items`);
      for (let i = 0; i < embed_queue.length; i += this.collection.embed_model.batch_size) {
        if (this.is_queue_halted) {
          this.is_queue_halted = false;
          break;
        }
        this._show_embed_progress_notice(embed_queue.length);
        const batch = embed_queue.slice(i, i + this.collection.embed_model.batch_size);
        await Promise.all(batch.map((item) => item.get_embed_input()));
        try {
          const start_time = Date.now();
          await this.embed_batch(batch);
          this.total_time += Date.now() - start_time;
        } catch (e) {
          if (e && e.message && e.message.includes("API key not set")) {
            this.halt_embed_queue_processing(`API key not set for ${this.collection.embed_model_key}
Please set the API key in the settings.`);
          }
          console.error(e);
          console.error(`Error processing ${this.collection.collection_key} embed queue: ` + JSON.stringify(e || {}, null, 2));
        }
        batch.forEach((item) => {
          item.embed_hash = item.read_hash;
          item._queue_save = true;
        });
        this.embedded_total += batch.length;
        this.total_tokens += batch.reduce((acc, item) => acc + (item.tokens || 0), 0);
        if (this.embedded_total - this.last_save_total > 1e3) {
          this.last_save_total = this.embedded_total;
          await this.collection.process_save_queue();
          if (this.collection.block_collection) {
            console.log(`Saving ${this.collection.block_collection.collection_key} block collection`);
            await this.collection.block_collection.process_save_queue();
          }
        }
      }
      this._show_embed_completion_notice(embed_queue.length);
      await this.collection.process_save_queue();
      if (this.collection.block_collection) {
        await this.collection.block_collection.process_save_queue();
      }
    } finally {
      this._is_processing_embed_queue = false;
    }
  }
  get should_show_embed_progress_notice() {
    if (Date.now() - (this.last_notice_time ?? 0) > 3e4) {
      return true;
    }
    return this.embedded_total - this.last_notice_embedded_total >= 100;
  }
  /**
   * Displays the embedding progress notice.
   * @private
   * @returns {void}
   */
  _show_embed_progress_notice(embed_queue_length) {
    if (!this.should_show_embed_progress_notice) return;
    this.last_notice_time = Date.now();
    this.last_notice_embedded_total = this.embedded_total;
    this.notices?.show("embedding_progress", {
      progress: this.embedded_total,
      total: embed_queue_length,
      tokens_per_second: this._calculate_embed_tokens_per_second(),
      model_name: this.collection.embed_model_key
    });
  }
  /**
   * Displays the embedding completion notice.
   * @private
   * @returns {void}
   */
  _show_embed_completion_notice() {
    this.notices?.remove("embedding_progress");
    this.notices?.show("embedding_complete", {
      total_embeddings: this.embedded_total,
      tokens_per_second: this._calculate_embed_tokens_per_second(),
      model_name: this.collection.embed_model_key
    });
  }
  /**
   * Halts the embed queue processing.
   * @param {string|null} msg - Optional message.
   */
  halt_embed_queue_processing(msg = null) {
    this.is_queue_halted = true;
    console.log("Embed queue processing halted");
    this.notices?.remove("embedding_progress");
    this.notices?.show("embedding_paused", {
      progress: this.embedded_total,
      total: this.collection._embed_queue.length,
      tokens_per_second: this._calculate_embed_tokens_per_second(),
      model_name: this.collection.embed_model_key
    });
  }
  /**
   * Resumes the embed queue processing after a delay.
   * @param {number} [delay=0] - The delay in milliseconds before resuming.
   * @returns {void}
   */
  resume_embed_queue_processing(delay = 0) {
    console.log("resume_embed_queue_processing");
    this.notices?.remove("embedding_paused");
    setTimeout(() => {
      this.embedded_total = 0;
      this.process_embed_queue();
    }, delay);
  }
  /**
   * Calculates the number of tokens processed per second.
   * @private
   * @returns {number} Tokens per second.
   */
  _calculate_embed_tokens_per_second() {
    const elapsed_time = this.total_time / 1e3;
    return Math.round(this.total_tokens / (elapsed_time || 1));
  }
  /**
   * Resets the statistics related to embed queue processing.
   * @private
   * @returns {void}
   */
  _reset_embed_queue_stats() {
    this.collection._embed_queue = [];
    this.embedded_total = 0;
    this.is_queue_halted = false;
    this.last_save_total = 0;
    this.last_notice_embedded_total = 0;
    this.total_tokens = 0;
    this.total_time = 0;
  }
  get notices() {
    return this.collection.notices;
  }
};
var DefaultEntityVectorAdapter2 = class extends EntityVectorAdapter2 {
  get data() {
    return this.item.data;
  }
  /**
   * Retrieve the current vector embedding for this entity.
   * @async
   * @returns {Promise<number[]|undefined>} The entity's vector or undefined if not set.
   */
  async get_vec() {
    return this.vec;
  }
  /**
   * Store/update the vector embedding for this entity.
   * @async
   * @param {number[]} vec - The vector to set.
   * @returns {Promise<void>}
   */
  async set_vec(vec) {
    this.vec = vec;
  }
  /**
   * Delete/remove the vector embedding for this entity.
   * @async
   * @returns {Promise<void>}
   */
  async delete_vec() {
    if (this.item.data?.embeddings?.[this.item.embed_model_key]) {
      delete this.item.data.embeddings[this.item.embed_model_key].vec;
    }
  }
  // adds synchronous get/set for vec
  get vec() {
    return this.item.data?.embeddings?.[this.item.embed_model_key]?.vec;
  }
  set vec(vec) {
    if (!this.item.data.embeddings) {
      this.item.data.embeddings = {};
    }
    if (!this.item.data.embeddings[this.item.embed_model_key]) {
      this.item.data.embeddings[this.item.embed_model_key] = {};
    }
    this.item.data.embeddings[this.item.embed_model_key].vec = vec;
  }
};

// node_modules/smart-entities/actions/find_connections.js
async function find_connections3(params = {}) {
  const filter_opts = this.prepare_find_connections_filter_opts(params);
  const limit = params.filter?.limit || params.limit || this.env.settings.smart_view_filter?.results_limit || 10;
  const cache_key = this.key + JSON.stringify(params);
  if (!this.env.connections_cache) this.env.connections_cache = {};
  if (!this.env.connections_cache[cache_key]) {
    const connections = (await this.nearest(filter_opts)).sort(sort_by_score2).slice(0, limit);
    this.connections_to_cache(cache_key, connections);
  }
  return this.connections_from_cache(cache_key);
}

// node_modules/smart-entities/smart_entity.js
var SmartEntity2 = class extends CollectionItem2 {
  /**
   * Creates an instance of SmartEntity.
   * @constructor
   * @param {Object} env - The environment instance.
   * @param {Object} [opts={}] - Configuration options.
   */
  constructor(env, opts = {}) {
    super(env, opts);
    this.entity_adapter = new DefaultEntityVectorAdapter2(this);
  }
  /**
   * Provides default values for a SmartEntity instance.
   * @static
   * @readonly
   * @returns {Object} The default values.
   */
  static get defaults() {
    return {
      data: {
        path: null,
        last_embed: {
          hash: null
        },
        embeddings: {}
      }
    };
  }
  get vector_adapter() {
    if (!this._vector_adapter) {
      this._vector_adapter = new this.collection.opts.vector_adapter.item(this);
    }
    return this._vector_adapter;
  }
  /**
   * Initializes the SmartEntity instance.
   * Checks if the entity has a vector and if it matches the model dimensions.
   * If not, it queues an embed.
   * Removes embeddings for inactive models.
   * @returns {void}
   */
  init() {
    super.init();
    if (!this.vec || !this.vec.length) {
      this.vec = null;
      this.queue_embed();
    }
    Object.entries(this.data.embeddings || {}).forEach(([model, embedding]) => {
      if (model !== this.embed_model_key) {
        this.data.embeddings[model] = null;
        delete this.data.embeddings[model];
      }
    });
  }
  /**
   * Queues the entity for embedding.
   * @returns {void}
   */
  queue_embed() {
    this._queue_embed = true;
  }
  /**
   * Finds the nearest entities to this entity.
   * @param {Object} [filter={}] - Optional filters to apply.
   * @returns {Array<{item:Object, score:number}>} An array of result objects with score and item.
   */
  async nearest(filter = {}) {
    return await this.collection.nearest_to(this, filter);
  }
  /**
   * Prepares the input for embedding.
   * @async
   * @param {string} [content=null] - Optional content to use instead of calling subsequent read()
   * @returns {Promise<void>} Should be overridden in child classes.
   */
  async get_embed_input(content = null) {
  }
  // override in child class
  /**
   * Retrieves the embed input, either from cache or by generating it.
   * @readonly
   * @returns {string|Promise<string>} The embed input string or a promise resolving to it.
   */
  get embed_input() {
    return this._embed_input ? this._embed_input : this.get_embed_input();
  }
  /**
   * Prepares filter options for finding connections based on parameters.
   * @param {Object} [params={}] - Parameters for finding connections.
   * @returns {Object} The prepared filter options.
   */
  prepare_find_connections_filter_opts(params = {}) {
    const opts = {
      ...this.env.settings.smart_view_filter || {},
      ...params,
      entity: this
    };
    if (opts.filter?.limit) delete opts.filter.limit;
    if (opts.limit) delete opts.limit;
    return opts;
  }
  /**
   * Finds connections relevant to this entity based on provided parameters.
   * @async
   * @param {Object} [params={}] - Parameters for finding connections.
   * @returns {Array<{item:Object, score:number}>} An array of result objects with score and item.
   */
  async find_connections(params = {}) {
    return await this.actions.find_connections(params);
  }
  /**
   * Retrieves connections from the cache based on the cache key.
   * @param {string} cache_key - The cache key.
   * @returns {Array<{item:Object, score:number}>} The cached connections.
   */
  connections_from_cache(cache_key) {
    return this.env.connections_cache[cache_key];
  }
  /**
   * Stores connections in the cache with the provided cache key.
   * @param {string} cache_key - The cache key.
   * @param {Array<{item:Object, score:number}>} connections - The connections to cache.
   * @returns {void}
   */
  connections_to_cache(cache_key, connections) {
    this.env.connections_cache[cache_key] = connections;
  }
  get read_hash() {
    return this.data.last_read?.hash;
  }
  set read_hash(hash) {
    if (!this.data.last_read) this.data.last_read = {};
    this.data.last_read.hash = hash;
  }
  get embedding_data() {
    if (!this.data.embeddings[this.embed_model_key]) {
      this.data.embeddings[this.embed_model_key] = {};
    }
    return this.data.embeddings[this.embed_model_key];
  }
  get last_embed() {
    if (!this.embedding_data.last_embed) {
      this.embedding_data.last_embed = {};
      if (this.data.last_embed) {
        this.embedding_data.last_embed = this.data.last_embed;
        delete this.data.last_embed;
        this.queue_save();
      }
    }
    return this.embedding_data.last_embed;
  }
  get embed_hash() {
    return this.last_embed?.hash;
  }
  set embed_hash(hash) {
    if (!this.embedding_data.last_embed) this.embedding_data.last_embed = {};
    this.embedding_data.last_embed.hash = hash;
  }
  /**
   * Gets the embed link for the entity.
   * @readonly
   * @returns {string} The embed link.
   */
  get embed_link() {
    return `![[${this.path}]]`;
  }
  /**
   * Gets the key of the embedding model.
   * @readonly
   * @returns {string} The embedding model key.
   */
  get embed_model_key() {
    return this.collection.embed_model_key;
  }
  /**
   * Gets the name of the entity, formatted based on settings.
   * @readonly
   * @returns {string} The entity name.
   */
  get name() {
    return (!this.should_show_full_path ? this.path.split("/").pop() : this.path.split("/").join(" > ")).split("#").join(" > ").replace(".md", "");
  }
  /**
   * Determines whether to show the full path of the entity.
   * @readonly
   * @returns {boolean} True if the full path should be shown, false otherwise.
   */
  get should_show_full_path() {
    return this.env.settings.smart_view_filter?.show_full_path;
  }
  /**
   * @deprecated Use embed_model instead.
   * @readonly
   * @returns {Object} The smart embedding model.
   */
  get smart_embed() {
    return this.embed_model;
  }
  /**
   * Gets the embedding model instance from the collection.
   * @readonly
   * @returns {Object} The embedding model instance.
   */
  get embed_model() {
    return this.collection.embed_model;
  }
  /**
   * Determines if the entity should be embedded if unembedded. NOT the same as is_unembedded.
   * @readonly
   * @returns {boolean} True if no vector is set, false otherwise.
   */
  get should_embed() {
    return this.size > (this.settings?.min_chars || 300);
  }
  /**
   * Sets the error for the embedding model.
   * @param {string} error - The error message.
   */
  set error(error) {
    this.data.embeddings[this.embed_model_key].error = error;
  }
  /**
   * Gets the number of tokens associated with the entity's embedding.
   * @readonly
   * @returns {number|undefined} The number of tokens, or undefined if not set.
   */
  get tokens() {
    return this.last_embed?.tokens;
  }
  /**
   * Sets the number of tokens for the embedding.
   * @param {number} tokens - The number of tokens.
   */
  set tokens(tokens) {
    this.last_embed.tokens = tokens;
  }
  /**
   * Gets the vector representation from the entity adapter.
   * @readonly
   * @returns {Array<number>|undefined} The vector or undefined if not set.
   */
  get vec() {
    return this.entity_adapter.vec;
  }
  /**
   * Sets the vector representation in the entity adapter.
   * @param {Array<number>} vec - The vector to set.
   */
  set vec(vec) {
    this.entity_adapter.vec = vec;
    this._queue_embed = false;
    this._embed_input = null;
    this.queue_save();
  }
  /**
   * Removes all embeddings from the entity.
   * @returns {void}
   */
  remove_embeddings() {
    this.data.embeddings = null;
    this.queue_save();
  }
  /**
   * Retrieves the key of the entity.
   * @returns {string} The entity key.
   */
  get_key() {
    return this.data.key || this.data.path;
  }
  /**
   * Retrieves the path of the entity.
   * @readonly
   * @returns {string|null} The entity path.
   */
  get path() {
    return this.data.path;
  }
  get is_unembedded() {
    if (!this.vec) return true;
    if (!this.embed_hash || this.embed_hash !== this.read_hash) return true;
    return false;
  }
};

// node_modules/smart-entities/smart_entities.js
var SmartEntities2 = class extends Collection2 {
  /**
   * Creates an instance of SmartEntities.
   * @constructor
   * @param {Object} env - The environment instance.
   * @param {Object} opts - Configuration options.
   */
  constructor(env, opts) {
    super(env, opts);
    this.entities_vector_adapter = new DefaultEntitiesVectorAdapter2(this);
    this.model_instance_id = null;
    this._embed_queue = [];
  }
  /**
   * Initializes the SmartEntities instance by loading embeddings.
   * @async
   * @returns {Promise<void>}
   */
  async init() {
    await super.init();
    await this.load_smart_embed();
    if (!this.embed_model) {
      console.log(`SmartEmbed not loaded for **${this.collection_key}**. Continuing without embedding capabilities.`);
    }
  }
  /**
   * Loads the smart embedding model.
   * @async
   * @returns {Promise<void>}
   */
  async load_smart_embed() {
    if (this.embed_model_key === "None") return;
    if (!this.embed_model) return;
    if (this.embed_model.is_loading) return console.log(`SmartEmbedModel already loading for ${this.embed_model_key}`);
    if (this.embed_model.is_loaded) return console.log(`SmartEmbedModel already loaded for ${this.embed_model_key}`);
    try {
      console.log(`Loading SmartEmbedModel in ${this.collection_key}, current state: ${this.embed_model.state}`);
      await this.embed_model.load();
    } catch (e) {
      console.error(`Error loading SmartEmbedModel for ${this.embed_model.model_key}`);
      console.error(e);
    }
  }
  /**
   * Unloads the smart embedding model.
   * @async
   * @returns {Promise<void>}
   */
  async unload() {
    if (typeof this.embed_model?.unload === "function") {
      this.embed_model.unload();
    }
    super.unload();
  }
  /**
   * Gets the key of the embedding model.
   * @readonly
   * @returns {string} The embedding model key.
   */
  get embed_model_key() {
    return this.embed_model?.model_key;
  }
  /**
   * Gets or creates the container for smart embeddings in the DOM.
   * @readonly
   * @returns {HTMLElement|undefined} The container element or undefined if not available.
   */
  get smart_embed_container() {
    if (!this.model_instance_id) return console.log("model_key not set");
    const id = this.model_instance_id.replace(/[^a-zA-Z0-9]/g, "_");
    if (!window.document) return console.log("window.document not available");
    if (window.document.querySelector(`#${id}`)) return window.document.querySelector(`#${id}`);
    const container = window.document.createElement("div");
    container.id = id;
    window.document.body.appendChild(container);
    return container;
  }
  /**
   * @deprecated Use embed_model instead.
   * @readonly
   * @returns {Object} The smart embedding model.
   */
  get smart_embed() {
    return this.embed_model;
  }
  /**
   * Gets the embedding model instance.
   * @readonly
   * @returns {Object|null} The embedding model instance or null if none.
   */
  get embed_model() {
    if (!this.env._embed_model && this.env.opts.modules.smart_embed_model?.class) this.env._embed_model = new this.env.opts.modules.smart_embed_model.class({
      settings: this.settings.embed_model,
      adapters: this.env.opts.modules.smart_embed_model?.adapters,
      re_render_settings: () => this.env.render_component("collection_settings", this, { settings_container: this.settings_container }),
      reload_model: this.reload_embed_model.bind(this)
    });
    return this.env._embed_model;
  }
  set embed_model(embed_model) {
    this.env._embed_model = embed_model;
  }
  reload_embed_model() {
    console.log("reload_embed_model");
    this.embed_model.unload();
    this.env._embed_model = null;
  }
  /**
   * Finds the nearest entities to a given entity.
   * @async
   * @param {Object} entity - The reference entity.
   * @param {Object} [filter={}] - Optional filters to apply.
   * @returns {Promise<Array<{item:Object, score:number}>>} An array of result objects with score and item.
   */
  async nearest_to(entity, filter = {}) {
    return await this.nearest(entity.vec, filter);
  }
  /**
   * Finds the nearest entities to a vector using the default adapter.
   * @async
   * @param {Array<number>} vec - The vector to compare against.
   * @param {Object} [filter={}] - Optional filters to apply.
   * @returns {Promise<Array<{item:Object, score:number}>>} An array of result objects with score and item.
   */
  async nearest(vec, filter = {}) {
    if (!vec) {
      console.warn("nearest: no vec");
      return [];
    }
    return await this.entities_vector_adapter.nearest(vec, filter);
  }
  /**
   * Finds the furthest entities from a vector using the default adapter.
   * @async
   * @param {Array<number>} vec - The vector to compare against.
   * @param {Object} [filter={}] - Optional filters to apply.
   * @returns {Promise<Array<{item:Object, score:number}>>} An array of result objects with score and item.
   */
  async furthest(vec, filter = {}) {
    if (!vec) return console.warn("furthest: no vec");
    return await this.entities_vector_adapter.furthest(vec, filter);
  }
  /**
   * Gets the file name based on collection key and embedding model key.
   * @readonly
   * @returns {string} The constructed file name.
   */
  get file_name() {
    return this.collection_key + "-" + this.embed_model_key.split("/").pop();
  }
  /**
   * Calculates the relevance of an item based on the search filter.
   * @param {Object} item - The item to calculate relevance for.
   * @param {Object} search_filter - The search filter containing keywords.
   * @returns {number} The relevance score:
   *                   1 if any keyword is found in the item's path,
   *                   0 otherwise (default relevance for keyword in content).
   */
  calculate_relevance(item, search_filter) {
    if (search_filter.keywords.some((keyword) => item.path?.includes(keyword))) return 1;
    return 0;
  }
  /**
   * Prepares the filter options by incorporating entity-based filters.
   * @param {Object} [opts={}] - The filter options.
   * @param {Object} [opts.entity] - The entity to base the filters on.
   * @param {string|string[]} [opts.exclude_filter] - Keys or prefixes to exclude.
   * @param {string|string[]} [opts.include_filter] - Keys or prefixes to include.
   * @param {boolean} [opts.exclude_inlinks] - Whether to exclude inlinks of the entity.
   * @param {boolean} [opts.exclude_outlinks] - Whether to exclude outlinks of the entity.
   * @returns {Object} The modified filter options.
   */
  prepare_filter(opts = {}) {
    const {
      entity,
      exclude_filter,
      include_filter,
      exclude_inlinks,
      exclude_outlinks
    } = opts;
    if (entity) {
      if (typeof opts.exclude_key_starts_with_any === "undefined") opts.exclude_key_starts_with_any = [];
      if (opts.exclude_key_starts_with) {
        opts.exclude_key_starts_with_any = [
          opts.exclude_key_starts_with
        ];
        delete opts.exclude_key_starts_with;
      }
      opts.exclude_key_starts_with_any.push(entity.source_key || entity.key);
      if (exclude_filter) {
        if (!Array.isArray(opts.exclude_key_includes_any)) opts.exclude_key_includes_any = [];
        if (typeof exclude_filter === "string") {
          if (exclude_filter.includes(",")) {
            opts.exclude_key_includes_any.push(...exclude_filter.split(","));
          } else {
            opts.exclude_key_includes_any.push(exclude_filter);
          }
        }
      }
      if (include_filter) {
        if (!Array.isArray(opts.key_includes_any)) opts.key_includes_any = [];
        if (typeof include_filter === "string") {
          if (include_filter.includes(",")) {
            opts.key_includes_any.push(...include_filter.split(","));
          } else {
            opts.key_includes_any.push(include_filter);
          }
        }
      }
      if (exclude_inlinks && entity?.inlinks?.length) {
        if (!Array.isArray(opts.exclude_key_starts_with_any)) opts.exclude_key_starts_with_any = [];
        opts.exclude_key_starts_with_any.push(...entity.inlinks);
      }
      if (exclude_outlinks && entity?.outlinks?.length) {
        if (!Array.isArray(opts.exclude_key_starts_with_any)) opts.exclude_key_starts_with_any = [];
        opts.exclude_key_starts_with_any.push(...entity.outlinks);
      }
    }
    return opts;
  }
  /**
   * Looks up entities based on hypothetical content.
   * @async
   * @param {Object} [params={}] - The parameters for the lookup.
   * @param {Array<string>} [params.hypotheticals=[]] - The hypothetical content to lookup.
   * @param {Object} [params.filter] - The filter to use for the lookup.
   * @param {number} [params.k] - Deprecated: Use `filter.limit` instead.
   * @returns {Promise<Array<Result>|Object>} The lookup results or an error object.
   */
  async lookup(params = {}) {
    const { hypotheticals = [] } = params;
    if (!hypotheticals?.length) return { error: "hypotheticals is required" };
    if (!this.embed_model) return { error: "Embedding search is not enabled." };
    const hyp_vecs = await this.embed_model.embed_batch(hypotheticals.map((h) => ({ embed_input: h })));
    const limit = params.filter?.limit || params.k || this.env.settings.lookup_k || 10;
    if (params.filter?.limit) delete params.filter.limit;
    const filter = {
      ...this.env.chats?.current?.scope || {},
      // DEPRECATED: since Smart Chat v1 (remove after removing legacy Smart Chat v0 from obsidian-smart-connections)
      ...params.filter || {}
    };
    const results = await hyp_vecs.reduce(async (acc_promise, embedding, i) => {
      const acc = await acc_promise;
      const results2 = await this.nearest(embedding.vec, filter);
      results2.forEach((result) => {
        if (!acc[result.item.path] || result.score > acc[result.item.path].score) {
          acc[result.item.path] = {
            key: result.item.key,
            score: result.score,
            item: result.item,
            hypothetical_i: i
          };
        } else {
          result.score = acc[result.item.path].score;
        }
      });
      return acc;
    }, Promise.resolve({}));
    const top_k = Object.values(results).sort(sort_by_score2).slice(0, limit);
    console.log(`Found and returned ${top_k.length} ${this.collection_key}.`);
    return top_k;
  }
  /**
   * Gets the configuration for settings.
   * @readonly
   * @returns {Object} The settings configuration.
   */
  get settings_config() {
    return settings_config3;
  }
  /**
   * @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
   */
  async render_settings(container = this.settings_container, opts = {}) {
    container = await this.render_collection_settings(container, opts);
    const embed_model_settings_frag = await this.env.render_component("settings", this.embed_model, opts);
    container.appendChild(embed_model_settings_frag);
    return container;
  }
  /**
   * Gets the notices from the environment.
   * @readonly
   * @returns {Object} The notices object.
   */
  get notices() {
    return this.env.smart_connections_plugin?.notices || this.env.main?.notices;
  }
  /**
   * Gets the embed queue containing items to be embedded.
   * @readonly
   * @returns {Array<Object>} The embed queue.
   */
  get embed_queue() {
    if (!this._embed_queue?.length) {
      console.time(`Building embed queue`);
      this._embed_queue = Object.values(this.items).filter((item) => item._queue_embed || item.is_unembedded && item.should_embed);
      console.timeEnd(`Building embed queue`);
    }
    return this._embed_queue;
  }
  /**
   * Processes the embed queue by delegating to the default vector adapter.
   * @async
   * @returns {Promise<void>}
   */
  async process_embed_queue() {
    await this.entities_vector_adapter.process_embed_queue();
  }
  /**
   * Handles changes to the embedding model by reinitializing and processing the load queue.
   * @async
   * @returns {Promise<void>}
   */
  async embed_model_changed() {
    await this.unload();
    await this.init();
    this.render_settings();
    await this.process_load_queue();
  }
  get connections_filter_config() {
    return connections_filter_config2;
  }
};
var settings_config3 = {
  "min_chars": {
    name: "Minimum length",
    type: "number",
    description: "Minimum length of entity to embed (in characters).",
    placeholder: "Enter number ex. 300",
    default: 300
  }
};
var connections_filter_config2 = {
  "smart_view_filter.show_full_path": {
    "name": "Show full path",
    "type": "toggle",
    "description": "Turning on will include the folder path in the connections results."
  },
  "smart_view_filter.render_markdown": {
    "name": "Render markdown",
    "type": "toggle",
    "description": "Turn off to prevent rendering markdown and display connection results as plain text."
  },
  "smart_view_filter.results_limit": {
    "name": "Results limit",
    "type": "number",
    "description": "Adjust the number of connections displayed in the connections view (default 20).",
    "default": 20
  },
  "smart_view_filter.exclude_inlinks": {
    "name": "Exclude inlinks (backlinks)",
    "type": "toggle",
    "description": "Exclude notes that already link to the current note from the connections results."
  },
  "smart_view_filter.exclude_outlinks": {
    "name": "Exclude outlinks",
    "type": "toggle",
    "description": "Exclude notes that are already linked from within the current note from appearing in the connections results."
  },
  "smart_view_filter.include_filter": {
    "name": "Include filter",
    "type": "text",
    "description": "Notes must match this value in their file/folder path. Matching notes will be included in the connections results. Separate multiple values with commas."
  },
  "smart_view_filter.exclude_filter": {
    "name": "Exclude filter",
    "type": "text",
    "description": "Notes must *not* match this value in their file/folder path. Matching notes will be *excluded* from the connections results. Separate multiple values with commas."
  },
  // should be better scoped at source-level (leaving here for now since connections_filter_config needs larger refactor)
  "smart_view_filter.exclude_blocks_from_source_connections": {
    "name": "Hide blocks in results",
    "type": "toggle",
    "description": "Show only sources in the connections results (no blocks)."
  }
};

// node_modules/smart-sources/components/source.js
async function render19(entity, opts = {}) {
  let markdown;
  if (should_render_embed2(entity)) markdown = `${entity.embed_link}

${await entity.read()}`;
  else markdown = process_for_rendering2(await entity.read());
  let frag;
  if (source.env.settings.smart_view_filter.render_markdown) frag = await this.render_markdown(markdown, source);
  else frag = this.create_doc_fragment(`<span>${markdown}</span>`);
  return await post_process17.call(this, source, frag, opts);
}
function process_for_rendering2(content) {
  if (content.includes("```dataview")) content = content.replace(/```dataview/g, "```\\dataview");
  if (content.includes("![[")) content = content.replace(/\!\[\[/g, "! [[");
  return content;
}
async function post_process17(scope, frag, opts = {}) {
  return frag;
}
function should_render_embed2(entity) {
  if (!entity) return false;
  if (entity.is_media) return true;
  return false;
}

// node_modules/smart-sources/actions/find_connections.js
async function find_connections4(params = {}) {
  let connections;
  if (this.block_collection.settings.embed_blocks && !params.exclude_blocks_from_source_connections) connections = [];
  else connections = await find_connections3.call(this, params);
  const filter_opts = this.prepare_find_connections_filter_opts(params);
  const limit = params.filter?.limit || params.limit || this.env.settings.smart_view_filter?.results_limit || 20;
  if (params.filter?.limit) delete params.filter.limit;
  if (params.limit) delete params.limit;
  if (!params.exclude_blocks_from_source_connections) {
    const cache_key = this.key + JSON.stringify(params) + "_blocks";
    if (!this.env.connections_cache) this.env.connections_cache = {};
    if (!this.env.connections_cache[cache_key]) {
      const nearest = (await this.env.smart_blocks.nearest(this.vec, filter_opts)).sort(sort_by_score2).slice(0, limit);
      this.connections_to_cache(cache_key, nearest);
    }
    connections = [
      ...connections,
      ...this.connections_from_cache(cache_key)
    ].sort(sort_by_score2).slice(0, limit);
  }
  return connections;
}

// node_modules/smart-sources/smart_source.js
var SmartSource2 = class extends SmartEntity2 {
  /**
   * Provides default values for a SmartSource instance.
   * @static
   * @readonly
   * @returns {Object} The default values.
   */
  static get defaults() {
    return {
      data: {
        last_read: {
          hash: null,
          mtime: 0
        },
        embeddings: {}
      },
      _embed_input: null,
      // Stored temporarily
      _queue_load: true
    };
  }
  /**
   * Initializes the SmartSource instance by queuing an import if blocks are missing.
   * @returns {void}
   */
  init() {
    super.init();
    if (!this.data.blocks) this.queue_import();
  }
  /**
   * Queues the SmartSource for import.
   * @returns {void}
   */
  queue_import() {
    this._queue_import = true;
  }
  /**
   * Imports the SmartSource by checking for updates and parsing content.
   * @async
   * @returns {Promise<void>}
   */
  async import() {
    this._queue_import = false;
    try {
      await this.source_adapter?.import();
    } catch (err) {
      if (err.code === "ENOENT") {
        console.log(`Smart Connections: Deleting ${this.path} data because it no longer exists on disk`);
        this.delete();
      } else {
        console.warn("Smart Connections: Error during import: re-queueing import", err);
        this.queue_import();
      }
    }
  }
  /**
   * @deprecated likely extraneous
   */
  async parse_content(content = null) {
    const parse_fns = this.env?.opts?.collections?.smart_sources?.content_parsers || [];
    for (const fn of parse_fns) {
      await fn(this, content);
    }
    if (this.data.last_import?.hash === this.data.last_read?.hash) {
      if (this.data.blocks) return;
    }
  }
  /**
   * Finds connections relevant to this SmartSource based on provided parameters.
   * @async
   * @param {Object} [params={}] - Parameters for finding connections.
   * @param {boolean} [params.exclude_blocks_from_source_connections=false] - Whether to exclude block connections from source connections.
   * @returns {Array<SmartSource>} An array of relevant SmartSource entities.
   */
  async find_connections(params = {}) {
    return await this.actions.find_connections(params);
  }
  /**
   * Prepares the embed input for the SmartSource by reading content and applying exclusions.
   * @async
   * @returns {Promise<string|false>} The embed input string or `false` if already embedded.
   */
  async get_embed_input(content = null) {
    if (typeof this._embed_input === "string" && this._embed_input.length) return this._embed_input;
    if (!content) content = await this.read();
    if (!content) {
      console.warn("SmartSource.get_embed_input: No content available for embedding: " + this.path);
      return "";
    }
    if (this.excluded_lines.length) {
      const content_lines = content.split("\n");
      this.excluded_lines.forEach((lines) => {
        const { start, end } = lines;
        for (let i = start; i <= end; i++) {
          content_lines[i] = "";
        }
      });
      content = content_lines.filter((line) => line.length).join("\n");
    }
    const breadcrumbs = this.path.split("/").join(" > ").replace(".md", "");
    const max_tokens = this.collection.embed_model.model_config.max_tokens || 500;
    const max_chars = Math.floor(max_tokens * 3.7);
    this._embed_input = `${breadcrumbs}:
${content}`.substring(0, max_chars);
    return this._embed_input;
  }
  /**
   * Opens the SmartSource note in the SmartConnections plugin.
   * @returns {void}
   */
  open() {
    this.env.smart_connections_plugin.open_note(this.path);
  }
  /**
   * Retrieves the block associated with a specific line number.
   * @param {number} line - The line number to search for.
   * @returns {SmartBlock|null} The corresponding SmartBlock or `null` if not found.
   */
  get_block_by_line(line) {
    return Object.entries(this.data.blocks || {}).reduce((acc, [sub_key, range]) => {
      if (acc) return acc;
      if (range[0] <= line && range[1] >= line) {
        const block = this.block_collection.get(this.key + sub_key);
        if (block?.vec) return block;
      }
      return acc;
    }, null);
  }
  /**
   * Checks if the source file exists in the file system.
   * @async
   * @returns {Promise<boolean>} A promise that resolves to `true` if the file exists, `false` otherwise.
   */
  async has_source_file() {
    return await this.fs.exists(this.path);
  }
  // CRUD
  /**
   * FILTER/SEARCH METHODS
   */
  /**
   * Searches for keywords within the entity's data and content.
   * @async
   * @param {Object} search_filter - The search filter object.
   * @param {string[]} search_filter.keywords - An array of keywords to search for.
   * @param {string} [search_filter.type='any'] - The type of search to perform. 'any' counts all matching keywords, 'all' counts only if all keywords match.
   * @returns {Promise<number>} A promise that resolves to the number of matching keywords.
   */
  async search(search_filter = {}) {
    const { keywords, type = "any", limit } = search_filter;
    if (!keywords || !Array.isArray(keywords)) {
      console.warn("Entity.search: keywords not set or is not an array");
      return 0;
    }
    if (limit && this.collection.search_results_ct >= limit) return 0;
    const lowercased_keywords = keywords.map((keyword) => keyword.toLowerCase());
    const content = await this.read();
    const lowercased_content = content.toLowerCase();
    const lowercased_path = this.path.toLowerCase();
    const matching_keywords = lowercased_keywords.filter(
      (keyword) => lowercased_path.includes(keyword) || lowercased_content.includes(keyword)
    );
    if (type === "all") {
      return matching_keywords.length === lowercased_keywords.length ? matching_keywords.length : 0;
    } else {
      return matching_keywords.length;
    }
  }
  /**
   * ADAPTER METHODS
   */
  /**
   * Appends content to the end of the source file.
   * @async
   * @param {string} content - The content to append to the file.
   * @returns {Promise<void>} A promise that resolves when the operation is complete.
   */
  async append(content) {
    await this.source_adapter.append(content);
    await this.import();
  }
  /**
   * Updates the entire content of the source file.
   * @async
   * @param {string} full_content - The new content to write to the file.
   * @param {Object} [opts={}] - Additional options for the update.
   * @returns {Promise<void>} A promise that resolves when the operation is complete.
   */
  async update(full_content, opts = {}) {
    try {
      await this.source_adapter.update(full_content, opts);
      await this.import();
    } catch (error) {
      console.error("Error during update:", error);
      throw error;
    }
  }
  /**
   * Reads the entire content of the source file.
   * @async
   * @param {Object} [opts={}] - Additional options for reading.
   * @returns {Promise<string>} A promise that resolves with the content of the file.
   */
  async read(opts = {}) {
    try {
      const content = await this.source_adapter.read(opts);
      return content;
    } catch (error) {
      console.error("Error during read:", error);
      throw error;
    }
  }
  /**
   * Removes the source file from the file system and deletes the entity.
   * This is different from `delete()` because it also removes the source file.
   * @async
   * @returns {Promise<void>} A promise that resolves when the operation is complete.
   */
  async remove() {
    try {
      await this.source_adapter.remove();
    } catch (error) {
      console.error("Error during remove:", error);
      throw error;
    }
  }
  /**
   * Moves the current source to a new location.
   * Handles the destination as a string (new path) or entity (block or source).
   *
   * @async
   * @param {string|Object|SmartEntity} entity_ref - The destination path or entity to move to.
   * @throws {Error} If the entity reference is invalid.
   * @returns {Promise<void>} A promise that resolves when the move operation is complete.
   */
  async move_to(entity_ref) {
    try {
      await this.source_adapter.move_to(entity_ref);
    } catch (error) {
      console.error("error_during_move:", error);
      throw error;
    }
  }
  /**
   * Merges the given content into the current source.
   * Parses the content into blocks and either appends to existing blocks, replaces blocks, or replaces all content.
   *
   * @async
   * @param {string} content - The content to merge into the current source.
   * @param {Object} [opts={}] - Options object.
   * @param {string} [opts.mode='append'] - The merge mode: 'append', 'replace_blocks', or 'replace_all'.
   * @returns {Promise<void>}
   */
  async merge(content, opts = {}) {
    try {
      await this.source_adapter.merge(content, opts);
      await this.import();
    } catch (error) {
      console.error("Error during merge:", error);
      throw error;
    }
  }
  /**
   * Handles errors during the load process.
   * @param {Error} err - The error encountered during load.
   * @returns {void}
   */
  on_load_error(err) {
    super.on_load_error(err);
    if (err.code === "ENOENT") {
      this._queue_load = false;
      this.queue_import();
    }
  }
  // GETTERS
  /**
   * Retrieves the block collection associated with SmartSources.
   * @readonly
   * @returns {SmartBlocks} The block collection instance.
   */
  get block_collection() {
    return this.env.smart_blocks;
  }
  /**
   * Retrieves the vector representations of all blocks within the SmartSource.
   * @readonly
   * @returns {Array<Array<number>>} An array of vectors.
   */
  get block_vecs() {
    return this.blocks.map((block) => block.vec).filter((vec) => vec);
  }
  /**
   * Retrieves all blocks associated with the SmartSource.
   * @readonly
   * @returns {Array<SmartBlock>} An array of SmartBlock instances.
   * @description
   * Uses block refs (Fastest) to get blocks without iterating over all blocks
   */
  get blocks() {
    if (this.data.blocks) return this.block_collection.get_many(Object.keys(this.data.blocks).map((key) => this.key + key));
    return [];
  }
  /**
   * Determines if the SmartSource is excluded from processing.
   * @readonly
   * @returns {boolean} `true` if excluded, `false` otherwise.
   */
  get excluded() {
    return this.fs.is_excluded(this.path);
  }
  /**
   * Retrieves the lines excluded from embedding.
   * @readonly
   * @returns {Array<Object>} An array of objects with `start` and `end` line numbers.
   */
  get excluded_lines() {
    return this.blocks.filter((block) => block.excluded).map((block) => block.lines);
  }
  /**
   * Retrieves the file system instance from the SmartSource's collection.
   * @readonly
   * @returns {SmartFS} The file system instance.
   */
  get fs() {
    return this.collection.fs;
  }
  /**
   * Retrieves the file object associated with the SmartSource.
   * @readonly
   * @returns {Object} The file object.
   */
  get file() {
    return this.fs.files[this.path];
  }
  /**
   * Retrieves the file name of the SmartSource.
   * @readonly
   * @returns {string} The file name.
   */
  get file_name() {
    return this.path.split("/").pop();
  }
  /**
   * Retrieves the file path of the SmartSource.
   * @readonly
   * @returns {string} The file path.
   */
  get file_path() {
    return this.path;
  }
  /**
   * Retrieves the file type based on the file extension.
   * @readonly
   * @returns {string} The file type in lowercase.
   */
  get file_type() {
    if (!this._ext) {
      this._ext = this.collection.get_extension_for_path(this.path) || "md";
    }
    return this._ext;
  }
  /**
   * Retrieves the modification time of the SmartSource.
   * @readonly
   * @returns {number} The modification time.
   */
  get mtime() {
    return this.file?.stat?.mtime || 0;
  }
  /**
   * Retrieves the size of the SmartSource.
   * @readonly
   * @returns {number} The size.
   */
  get size() {
    return this.source_adapter?.size || 0;
  }
  /**
   * Retrieves the last import stat of the SmartSource.
   * @readonly
   * @returns {Object} The last import stat.
   */
  get last_import() {
    return this.data?.last_import;
  }
  /**
   * Retrieves the last import modification time of the SmartSource.
   * @readonly
   * @returns {number} The last import modification time.
   */
  get last_import_mtime() {
    return this.last_import?.mtime || 0;
  }
  /**
   * Retrieves the last import size of the SmartSource.
   * @readonly
   * @returns {number} The last import size.
   */
  get last_import_size() {
    return this.last_import?.size || 0;
  }
  /**
   * Retrieves the paths of inlinks to this SmartSource.
   * @readonly
   * @returns {Array<string>} An array of inlink paths.
   */
  get inlinks() {
    return Object.keys(this.collection.links?.[this.path] || {});
  }
  get is_media() {
    return this.source_adapter.is_media || false;
  }
  /**
   * Determines if the SmartSource is gone (i.e., the file no longer exists).
   * @readonly
   * @returns {boolean} `true` if gone, `false` otherwise.
   */
  get is_gone() {
    return !this.file;
  }
  /**
   * Retrieves the last read hash of the SmartSource.
   * @readonly
   * @returns {string|undefined} The last read hash or `undefined` if not set.
   */
  get last_read() {
    return this.data.last_read;
  }
  get metadata() {
    return this.data.metadata;
  }
  /**
   * Retrieves the display name of the SmartSource.
   * @readonly
   * @returns {string} The display name.
   */
  get name() {
    if (this.should_show_full_path) return this.path.split("/").join(" > ").replace(".md", "");
    return this.path.split("/").pop().replace(".md", "");
  }
  get outdated() {
    return this.source_adapter.outdated;
  }
  /**
   * Retrieves the outlink paths from the SmartSource.
   * @readonly
   * @returns {Array<string>} An array of outlink paths.
   */
  get outlinks() {
    return (this.data.outlinks || []).map((link) => {
      const link_ref = link?.target || link;
      if (typeof link_ref !== "string") return null;
      if (link_ref.startsWith("http")) return null;
      const link_path = this.fs.get_link_target_path(link_ref, this.file_path);
      return link_path;
    }).filter((link_path) => link_path);
  }
  get path() {
    return this.data.path || this.data.key;
  }
  get source_adapters() {
    return this.collection.source_adapters;
  }
  get source_adapter() {
    if (this._source_adapter) return this._source_adapter;
    if (this.source_adapters[this.file_type]) this._source_adapter = new this.source_adapters[this.file_type](this);
    else {
    }
    return this._source_adapter;
  }
  // COMPONENTS
  /**
   * Retrieves the component responsible for rendering the SmartSource.
   * @deprecated
   * @readonly
   * @returns {Function} The render function for the source component.
   */
  get component() {
    return render19;
  }
  // Currently unused, but useful for later
  /**
   * Calculates the mean vector of all blocks within the SmartSource.
   * @readonly
   * @returns {Array<number>|null} The mean vector or `null` if no vectors are present.
   */
  get mean_block_vec() {
    if (this._mean_block_vec) {
      this._mean_block_vec = compute_centroid(this.block_vecs);
    }
    return this._mean_block_vec;
  }
  /**
   * Calculates the median vector of all blocks within the SmartSource.
   * @readonly
   * @returns {Array<number>|null} The median vector or `null` if no vectors are present.
   */
  get median_block_vec() {
    if (this._median_block_vec) {
      this._median_block_vec = compute_medoid(this.block_vecs);
    }
    return this._median_block_vec;
  }
  // DEPRECATED methods
  /**
   * @async
   * @deprecated Use `read` instead.
   * @returns {Promise<string>} A promise that resolves with the content of the file.
   */
  async _read() {
    return await this.source_adapter._read();
  }
  /**
   * @async
   * @deprecated Use `remove` instead.
   * @returns {Promise<void>} A promise that resolves when the entity is destroyed.
   */
  async destroy() {
    await this.remove();
  }
  /**
   * @async
   * @deprecated Use `update` instead.
   * @param {string} content - The content to update.
   * @returns {Promise<void>}
   */
  async _update(content) {
    await this.source_adapter.update(content);
  }
  /**
   * @deprecated Use `source` instead.
   * @readonly
   * @returns {SmartSource} The associated SmartSource instance.
   */
  get t_file() {
    return this.fs.files[this.path];
  }
};
var smart_source_default2 = {
  class: SmartSource2,
  actions: {
    find_connections: find_connections4
  }
};

// node_modules/smart-sources/smart_sources.js
var SmartSources2 = class extends SmartEntities2 {
  /**
   * Creates an instance of SmartSources.
   * @constructor
   * @param {Object} env - The environment instance.
   * @param {Object} [opts={}] - Configuration options.
   */
  constructor(env, opts = {}) {
    super(env, opts);
    this.search_results_ct = 0;
    this._excluded_headings = null;
  }
  /**
   * Initializes the SmartSources instance by performing an initial scan of sources.
   * @async
   * @returns {Promise<void>}
   */
  async init() {
    await super.init();
    await this.init_items();
  }
  /**
   * Initializes items by letting each adapter do any necessary file-based scanning.
   * Adapters that do not rely on file scanning can skip or do nothing.
   * @async
   * @returns {Promise<void>}
   */
  async init_items() {
    this.show_process_notice("initial_scan");
    for (const AdapterClass of Object.values(this.source_adapters)) {
      if (typeof AdapterClass.init_items === "function") {
        await AdapterClass.init_items(this);
      }
    }
    this.clear_process_notice("initial_scan");
    this.notices?.show("done_initial_scan", { collection_key: this.collection_key });
  }
  /**
   * Creates (or returns existing) a SmartSource for a given file path, if the extension is recognized.
   * @param {string} file_path - The path to the file or pseudo-file
   * @returns {SmartSource|undefined} The newly created or existing SmartSource, or undefined if no recognized extension
   */
  init_file_path(file_path) {
    const ext = this.get_extension_for_path(file_path);
    if (!ext) {
      return;
    }
    if (this.fs.is_excluded(file_path)) {
      console.warn(`File ${file_path} is excluded from processing.`);
      return;
    }
    if (!this.fs.files[file_path]) {
      this.fs.include_file(file_path);
    }
    if (this.items[file_path]) return this.items[file_path];
    const item = new this.item_type(this.env, { path: file_path });
    this.items[file_path] = item;
    item.queue_import();
    item.queue_load();
    return item;
  }
  /**
   * Looks for an extension in descending order:
   * e.g. split "my.file.name.github" -> ["my","file","name","github"]
   * Try 'file.name.github', 'name.github', 'github'
   * Return the first that is in 'source_adapters'
   * @param {string} file_path
   * @returns {string|undefined} recognized extension, or undefined if none
   */
  get_extension_for_path(file_path) {
    if (!file_path) return void 0;
    const pcs = file_path.split(".");
    if (pcs.length < 2) return void 0;
    let last_ext;
    pcs.shift();
    while (pcs.length) {
      const supported_ext = pcs.join(".").toLowerCase();
      if (this.source_adapters[supported_ext]) {
        return supported_ext;
      }
      last_ext = pcs.shift();
    }
    return last_ext;
    return void 0;
  }
  /**
   * Builds a map of links between sources.
   * @returns {Object} An object mapping link paths to source keys.
   */
  build_links_map() {
    const start_time = Date.now();
    this.links = {};
    for (const source2 of Object.values(this.items)) {
      for (const link of source2.outlinks) {
        if (!this.links[link]) this.links[link] = {};
        this.links[link][source2.key] = true;
      }
    }
    const end_time = Date.now();
    console.log(`Time spent building links: ${end_time - start_time}ms`);
    return this.links;
  }
  /**
   * Creates a new source with the given key and content.
   * @async
   * @param {string} key - The key (path) of the new source.
   * @param {string} content - The content to write to the new source.
   * @returns {Promise<SmartSource>} The created SmartSource instance.
   */
  async create(key, content) {
    await this.fs.write(key, content);
    await this.fs.refresh();
    const source2 = await this.create_or_update({ path: key });
    await source2.import();
    return source2;
  }
  /**
   * Performs a lexical search for matching SmartSource content.
   * @async
   * @param {Object} search_filter - The filter criteria for the search.
   * @param {string[]} search_filter.keywords - An array of keywords to search for.
   * @param {number} [search_filter.limit] - The maximum number of results to return.
   * @returns {Promise<Array<SmartSource>>} A promise that resolves to an array of matching SmartSource entities.
   */
  async search(search_filter = {}) {
    const {
      keywords,
      limit,
      ...filter_opts
    } = search_filter;
    if (!keywords) {
      console.warn("search_filter.keywords not set");
      return [];
    }
    this.search_results_ct = 0;
    const initial_results = this.filter(filter_opts);
    const search_results = [];
    for (let i = 0; i < initial_results.length; i += 10) {
      const batch = initial_results.slice(i, i + 10);
      const batch_results = await Promise.all(
        batch.map(async (item) => {
          try {
            const matches = await item.search(search_filter);
            if (matches) {
              this.search_results_ct++;
              return { item, score: matches };
            } else return null;
          } catch (error) {
            console.error(`Error searching item ${item.id || "unknown"}:`, error);
            return null;
          }
        })
      );
      search_results.push(...batch_results.filter(Boolean));
    }
    return search_results.sort((a, b) => b.score - a.score).map((result) => result.item);
  }
  /**
   * Looks up entities based on the provided parameters.
   * @async
   * @param {Object} [params={}] - Parameters for the lookup.
   * @param {Object} [params.filter] - Filter options.
   * @param {number} [params.k] - Deprecated. Use `params.filter.limit` instead.
   * @returns {Promise<Array<SmartSource>>} A promise that resolves to an array of matching SmartSource entities.
   */
  async lookup(params = {}) {
    const limit = params.filter?.limit || params.k || this.env.settings.lookup_k || 10;
    if (params.filter?.limit) delete params.filter.limit;
    if (params.collection) {
      const collection = this.env[params.collection];
      if (collection && collection.lookup) {
        delete params.collection;
        params.skip_blocks = true;
        const results2 = await collection.lookup(params);
        if (results2.error) {
          console.warn(results2.error);
          return [];
        }
        return results2.slice(0, limit);
      }
    }
    let results = await super.lookup(params);
    if (results.error) {
      console.warn(results.error);
      return [];
    }
    if (this.block_collection?.settings?.embed_block && !params.skip_blocks) {
      results = [
        ...results,
        ...await this.block_collection.lookup(params)
      ].sort(sort_by_score2);
    }
    return results.slice(0, limit);
  }
  /**
   * Processes the load queue by loading items and optionally importing them.
   * Called after a "re-load" from settings, or after environment init.
   * @async
   * @returns {Promise<void>}
   */
  async process_load_queue() {
    await super.process_load_queue();
    if (this.collection_key === "smart_sources" && this.env.smart_blocks) {
      Object.values(this.env.smart_blocks.items).forEach((item) => item.init());
    }
    if (this.block_collection) {
      this.block_collection.loaded = Object.keys(this.block_collection.items).length;
    }
    if (!this.opts.prevent_import_on_load) {
      await this.process_source_import_queue(this.opts);
    }
    this.build_links_map();
  }
  /**
   * @method process_source_import_queue
   * @description 
   * Imports items (SmartSources or SmartBlocks) that have been flagged for import.
   */
  async process_source_import_queue(opts = {}) {
    const { process_embed_queue = true, force = false } = opts;
    if (force) Object.values(this.items).forEach((item) => item._queue_import = true);
    const import_queue = Object.values(this.items).filter((item) => item._queue_import);
    console.log("import_queue " + import_queue.length);
    if (import_queue.length) {
      const time_start = Date.now();
      for (let i = 0; i < import_queue.length; i += 100) {
        this.notices?.show("import_progress", {
          progress: i,
          total: import_queue.length
        });
        await Promise.all(import_queue.slice(i, i + 100).map((item) => item.import()));
      }
      setTimeout(() => {
        this.notices?.remove("import_progress");
      }, 1e3);
      this.notices?.show("done_import", {
        count: import_queue.length,
        time_in_seconds: (Date.now() - time_start) / 1e3
      });
    } else {
      this.notices?.show("no_import_queue");
    }
    this.build_links_map();
    if (process_embed_queue) await this.process_embed_queue();
    else console.log("skipping process_embed_queue");
    await this.process_save_queue();
    await this.block_collection?.process_save_queue();
  }
  /**
   * Retrieves the source adapters based on the collection configuration.
   * @readonly
   * @returns {Object} An object mapping file extensions to adapter constructors.
   */
  get source_adapters() {
    if (!this._source_adapters) {
      const source_adapters = Object.values(this.env.opts.collections?.[this.collection_key]?.source_adapters || {});
      const _source_adapters = source_adapters.reduce((acc, adapter) => {
        adapter.extensions?.forEach((ext) => acc[ext] = adapter);
        return acc;
      }, {});
      if (Object.keys(_source_adapters).length) {
        this._source_adapters = _source_adapters;
      }
    }
    return this._source_adapters;
  }
  /**
   * Retrieves the notices system from the environment.
   * @readonly
   * @returns {Object} The notices object.
   */
  get notices() {
    return this.env.smart_connections_plugin?.notices || this.env.main?.notices;
  }
  /**
   * Retrieves the currently active note.
   * @readonly
   * @returns {SmartSource|null} The current SmartSource instance or null if none.
   */
  get current_note() {
    return this.get(this.env.smart_connections_plugin.app.workspace.getActiveFile().path);
  }
  /**
   * Retrieves the file system instance, initializing it if necessary.
   * @readonly
   * @returns {SmartFS} The file system instance.
   */
  get fs() {
    if (!this._fs) {
      this._fs = new this.env.opts.modules.smart_fs.class(this.env, {
        adapter: this.env.opts.modules.smart_fs.adapter,
        fs_path: this.env.opts.env_path || "",
        exclude_patterns: this.excluded_patterns || []
      });
    }
    return this._fs;
  }
  /**
   * Retrieves the settings configuration by combining superclass settings and adapter-specific settings.
   * @readonly
   * @returns {Object} The settings configuration object.
   */
  get settings_config() {
    const _settings_config = {
      ...super.settings_config,
      ...this.process_settings_config(settings_config4),
      ...this.process_settings_config(this.embed_model.settings_config, "embed_model"),
      ...Object.entries(this.source_adapters).reduce((acc, [file_extension, adapter_constructor]) => {
        if (acc[adapter_constructor]) return acc;
        const item = this.items[Object.keys(this.items).find((i) => i.endsWith(file_extension))];
        const adapter_instance = new adapter_constructor(item || new this.item_type(this.env, {}));
        if (adapter_instance.settings_config) {
          acc[adapter_constructor.name] = {
            type: "html",
            value: `<h4>${adapter_constructor.name} adapter</h4>`
          };
          acc = { ...acc, ...adapter_instance.settings_config };
        }
        return acc;
      }, {})
    };
    return _settings_config;
  }
  /**
   * Retrieves the block collection associated with SmartSources.
   * @readonly
   * @returns {SmartBlocks} The block collection instance.
   */
  get block_collection() {
    return this.env.smart_blocks;
  }
  /**
   * Retrieves the embed queue containing items and their blocks to be embedded.
   * @readonly
   * @returns {Array<Object>} The embed queue.
   */
  get embed_queue() {
    if (!this._embed_queue.length) {
      try {
        const embed_blocks = this.block_collection.settings.embed_blocks;
        this._embed_queue = Object.values(this.items).reduce((acc, item) => {
          if (item._queue_embed || item.should_embed && item.is_unembedded) acc.push(item);
          if (embed_blocks) item.blocks.forEach((block) => {
            if (block._queue_embed || block.should_embed && block.is_unembedded) acc.push(block);
          });
          return acc;
        }, []);
      } catch (e) {
        console.error(`Error getting embed queue:`, e);
      }
    }
    return this._embed_queue;
  }
  /**
   * Clears all data by removing sources and blocks, reinitializing the file system, and reimporting items.
   * @async
   * @returns {Promise<void>}
   */
  async run_clear_all() {
    this.notices?.show("clearing_all");
    await this.data_fs.remove_dir(this.data_dir, true);
    this.clear();
    this.block_collection.clear();
    this._fs = null;
    await this.init_fs();
    await this.init_items();
    this._excluded_headings = null;
    Object.values(this.items).forEach((item) => {
      item.queue_import();
      item.queue_embed();
      item.loaded_at = Date.now() + 9999999999;
    });
    this.notices?.remove("clearing_all");
    this.notices?.show("done_clearing_all");
    await this.process_source_import_queue();
  }
  async init_fs(opts = {}) {
    const { force_refresh = false } = opts;
    if (force_refresh) await this.env.fs.refresh();
    await this.fs.load_exclusions();
    this.fs.file_paths = this.fs.post_process(this.env.fs.file_paths);
    this.fs.files = this.fs.file_paths.reduce((acc, file_path) => {
      acc[file_path] = this.env.fs.files[file_path];
      return acc;
    }, {});
    this.fs.folder_paths = this.fs.post_process(this.env.fs.folder_paths);
    this.fs.folders = this.fs.folder_paths.reduce((acc, folder_path) => {
      acc[folder_path] = this.env.fs.folders[folder_path];
      return acc;
    }, {});
  }
  /**
   * Deletes all *.ajson files in the "multi/" data_dir, then re-saves all sources (opts.force=true).
   */
  async run_clean_up_data() {
    this.notices?.show("pruning_collection", { collection_key: this.block_collection.collection_key });
    const remove_smart_blocks = this.block_collection.filter((item) => {
      if (!item.vec) return false;
      if (item.is_gone) {
        item.reason = "is_gone";
        return true;
      }
      if (!item.should_embed) {
        item.reason = "should not embed";
        return true;
      }
      return false;
    });
    for (let i = 0; i < remove_smart_blocks.length; i++) {
      const item = remove_smart_blocks[i];
      if (item.is_gone) item.delete();
      else item.remove_embeddings();
    }
    this.notices?.remove("pruning_collection");
    this.notices?.show("done_pruning_collection", { collection_key: this.block_collection.collection_key, count: remove_smart_blocks.length });
    console.log(`Pruned ${remove_smart_blocks.length} blocks:
${remove_smart_blocks.map((item) => `${item.reason} - ${item.key}`).join("\n")}`);
    await this.data_fs.remove_dir(this.data_dir, true);
    await this.process_save_queue({ force: true });
  }
  /**
   * Retrieves patterns for excluding files/folders from processing.
   * @readonly
   * @returns {Array<string>}
   */
  get excluded_patterns() {
    return [
      ...this.file_exclusions?.map((file) => `${file}**`) || [],
      ...(this.folder_exclusions || []).map((folder) => `${folder}**`),
      this.env.env_data_dir + "/**"
    ];
  }
  /**
   * Retrieves the file exclusion patterns from settings.
   * @readonly
   * @returns {Array<string>} An array of file exclusion patterns.
   */
  get file_exclusions() {
    return this.env.settings?.file_exclusions?.length ? this.env.settings.file_exclusions.split(",").map((file) => file.trim()) : [];
  }
  /**
   * Retrieves the folder exclusion patterns from settings.
   * @readonly
   * @returns {Array<string>} An array of folder exclusion patterns.
   */
  get folder_exclusions() {
    return this.env.settings?.folder_exclusions?.length ? this.env.settings.folder_exclusions.split(",").map((folder) => {
      folder = folder.trim();
      if (folder === "") return false;
      if (folder === "/") return false;
      if (!folder.endsWith("/")) return folder + "/";
      return folder;
    }).filter(Boolean) : [];
  }
  /**
   * Retrieves the excluded headings from settings.
   * @readonly
   * @returns {Array<string>} An array of excluded headings.
   */
  get excluded_headings() {
    if (!this._excluded_headings) {
      this._excluded_headings = this.env.settings?.excluded_headings?.length ? this.env.settings.excluded_headings.split(",").map((heading) => heading.trim()) : [];
    }
    return this._excluded_headings;
  }
  /**
   * Retrieves the count of included files that are not excluded.
   * @readonly
   * @returns {number} The number of included files.
   */
  get included_files() {
    const extensions = Object.keys(this.source_adapters);
    return this.fs.file_paths.filter((file_path) => extensions.some((ext) => file_path.endsWith(ext)) && !this.fs.is_excluded(file_path)).length;
  }
  get excluded_file_paths() {
    return this.env.fs.file_paths.filter((file_path) => this.fs.is_excluded(file_path));
  }
  /**
   * Retrieves the total number of files, regardless of exclusion.
   * @readonly
   * @returns {number} The total number of files.
   */
  get total_files() {
    return this.fs.file_paths.filter((file) => file.endsWith(".md") || file.endsWith(".canvas")).length;
  }
  get data_dir() {
    return "multi";
  }
};
var settings_config4 = {
  // "smart_change.active": {
  //   "name": "Smart Change (change safety)",
  //   "description": "Enable Smart Changes (prevents accidental deletions/overwrites).",
  //   "type": "toggle",
  //   "default": true,
  // },
};

// node_modules/smart-chat-obsidian/src/utils/ScTranslations.json
var ScTranslations_default = {
  en: {
    name: "English",
    pronouns: ["my", "I", "me", "mine", "our", "ours", "us", "we"],
    context_prefix_prompt: "Context from lookup:",
    context_suffix_prompt: 'Use the provided context to respond like "Based on your notes..."',
    initial_message: "Hi there, welcome to the Smart Chat. Ask me a question about your notes and I'll try to answer it."
  },
  es: {
    name: "Espa\xF1ol",
    pronouns: ["mi", "yo", "m\xED", "t\xFA", "mis"],
    context_prefix_prompt: "Contexto de b\xFAsqueda:",
    context_suffix_prompt: 'Usa el contexto proporcionado para responder como "Bas\xE1ndote en tus notas..."',
    initial_message: "Hola, bienvenido al Smart Chat. Hazme una pregunta sobre tus apuntes y tratar\xE9 de responderla."
  },
  fr: {
    name: "Fran\xE7ais",
    pronouns: ["me", "mon", "ma", "mes", "moi", "nous", "notre", "nos", "je", "j'", "m'"],
    context_prefix_prompt: "Contexte de recherche :",
    context_suffix_prompt: `Utilisez le contexte fourni pour r\xE9pondre comme "D'apr\xE8s vos notes..."`,
    initial_message: "Bonjour, bienvenue dans le Smart Chat. Posez-moi une question sur vos notes et j'essaierai d'y r\xE9pondre."
  },
  de: {
    name: "Deutsch",
    pronouns: ["mein", "meine", "meinen", "meiner", "meines", "mir", "uns", "unser", "unseren", "unserer", "unseres"],
    context_prefix_prompt: "Kontext aus Suche:",
    context_suffix_prompt: 'Verwenden Sie den bereitgestellten Kontext, um zu antworten wie "Basierend auf Ihren Notizen..."',
    initial_message: "Hallo, willkommen beim Smart Chat. Stellen Sie mir eine Frage zu Ihren Notizen, und ich werde versuchen, sie zu beantworten."
  },
  it: {
    name: "Italiano",
    pronouns: ["mio", "mia", "miei", "mie", "noi", "nostro", "nostri", "nostra", "nostre"],
    context_prefix_prompt: "Contesto dalla ricerca:",
    context_suffix_prompt: 'Usa il contesto fornito per rispondere come "Basandoti sui tuoi appunti..."',
    initial_message: "Ciao, benvenuto al Smart Chat. Fai una domanda sui tuoi appunti e cercher\xF2 di risponderti."
  },
  pt: {
    name: "Portugu\xEAs",
    pronouns: ["meu", "eu", "mim", "minha", "nosso", "nossa", "n\xF3s"],
    context_prefix_prompt: "Contexto da pesquisa:",
    context_suffix_prompt: 'Use o contexto fornecido para responder como "Com base em suas anota\xE7\xF5es..."',
    initial_message: "Ol\xE1, bem-vindo ao Smart Chat. Fa\xE7a-me uma pergunta sobre suas anota\xE7\xF5es e tentarei respond\xEA-la."
  },
  "pt-br": {
    name: "Portugu\xEAs (Brasil)",
    pronouns: ["eu", "me", "mim", "meu", "meus", "minha", "minhas", "nosso", "nossos", "nossa", "nossas", "n\xF3s", "nos", "a gente"],
    context_prefix_prompt: "Contexto da pesquisa:",
    context_suffix_prompt: 'Use o contexto fornecido para responder como "Com base nas suas notas..."',
    initial_message: "Ol\xE1, bem-vindo ao Smart Chat. Fa\xE7a-me uma pergunta sobre suas notas e tentarei respond\xEA-la."
  },
  ja: {
    name: "\u65E5\u672C\u8A9E",
    pronouns: ["\u79C1", "\u81EA\u5206", "\u50D5", "\u4FFA", "\u79C1\u9054", "\u3053\u306E"],
    context_prefix_prompt: "\u691C\u7D22\u304B\u3089\u306E\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\uFF1A",
    context_suffix_prompt: "\u63D0\u4F9B\u3055\u308C\u305F\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u3092\u4F7F\u7528\u3057\u3066\u300C\u3053\u306E\u30CE\u30FC\u30C8\u306B\u57FA\u3065\u3044\u3066...\u300D\u306E\u3088\u3046\u306B\u5FDC\u7B54\u3057\u3066\u304F\u3060\u3055\u3044",
    initial_message: "\u3053\u3093\u306B\u3061\u306F\u3001Smart Chat\u3078\u3088\u3046\u3053\u305D\u3002\u3042\u306A\u305F\u306E\u30CE\u30FC\u30C8\u306B\u95A2\u3059\u308B\u8CEA\u554F\u3092\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u304A\u7B54\u3048\u3057\u307E\u3059\u3002"
  },
  ko: {
    name: "\uD55C\uAD6D\uC5B4",
    pronouns: ["\uB098", "\uB0B4", "\uB098\uC758", "\uC800", "\uC81C", "\uC6B0\uB9AC", "\uC800\uD76C"],
    context_prefix_prompt: "\uAC80\uC0C9\uC5D0\uC11C\uC758 \uCEE8\uD14D\uC2A4\uD2B8:",
    context_suffix_prompt: '\uC81C\uACF5\uB41C \uCEE8\uD14D\uC2A4\uD2B8\uB97C \uC0AC\uC6A9\uD558\uC5EC "\uB2F9\uC2E0\uC758 \uB178\uD2B8\uC5D0 \uAE30\uBC18\uD558\uC5EC..."\uC640 \uAC19\uC774 \uB2F5\uBCC0\uD558\uC138\uC694',
    initial_message: "\uC548\uB155\uD558\uC138\uC694, Smart Chat\uC5D0 \uC624\uC2E0 \uAC83\uC744 \uD658\uC601\uD569\uB2C8\uB2E4. \uB178\uD2B8\uC5D0 \uAD00\uD55C \uC9C8\uBB38\uC774 \uC788\uC73C\uC2DC\uBA74 \uB9D0\uC500\uD574 \uC8FC\uC138\uC694. \uC81C\uAC00 \uB2F5\uBCC0\uD574 \uB4DC\uB9AC\uACA0\uC2B5\uB2C8\uB2E4."
  },
  zh: {
    name: "\u4E2D\u6587\uFF08\u7B80\u4F53\uFF09",
    pronouns: ["\u6211", "\u6211\u7684", "\u6211\u4EEC", "\u6211\u4EEC\u7684"],
    context_prefix_prompt: "\u67E5\u627E\u7684\u4E0A\u4E0B\u6587\uFF1A",
    context_suffix_prompt: "\u4F7F\u7528\u63D0\u4F9B\u7684\u4E0A\u4E0B\u6587\uFF0C\u4EE5\u201C\u6839\u636E\u4F60\u7684\u7B14\u8BB0...\u201D\u7684\u65B9\u5F0F\u56DE\u7B54",
    initial_message: "\u4F60\u597D\uFF0C\u6B22\u8FCE\u4F7F\u7528 Smart Chat\u3002\u8BF7\u95EE\u6211\u5173\u4E8E\u4F60\u7684\u7B14\u8BB0\u7684\u95EE\u9898\uFF0C\u6211\u4F1A\u5C3D\u529B\u56DE\u7B54\u3002"
  },
  "zh-TW": {
    name: "\u4E2D\u6587\uFF08\u7E41\u4F53\uFF09",
    pronouns: ["\u6211", "\u6211\u7684", "\u6211\u5011", "\u6211\u5011\u7684"],
    context_prefix_prompt: "\u67E5\u627E\u7684\u4E0A\u4E0B\u6587\uFF1A",
    context_suffix_prompt: "\u4F7F\u7528\u63D0\u4F9B\u7684\u4E0A\u4E0B\u6587\uFF0C\u4EE5\u300C\u6839\u64DA\u60A8\u7684\u7B46\u8A18...\u300D\u7684\u65B9\u5F0F\u56DE\u7B54",
    initial_message: "\u55E8\uFF0C\u6B61\u8FCE\u4F86\u5230 Smart Chat\u3002\u8ACB\u554F\u6211\u95DC\u65BC\u60A8\u7684\u7B46\u8A18\u7684\u554F\u984C\uFF0C\u6211\u6703\u76E1\u529B\u56DE\u7B54\u3002"
  },
  hi: {
    name: "\u0939\u093F\u0928\u094D\u0926\u0940",
    pronouns: ["\u092E\u0948\u0902", "\u092E\u0941\u091D\u0947", "\u092E\u0947\u0930\u093E", "\u092E\u0947\u0930\u0947", "\u092E\u0947\u0930\u0940", "\u0939\u092E", "\u0939\u092E\u0947\u0902", "\u0939\u092E\u093E\u0930\u093E", "\u0939\u092E\u093E\u0930\u0947", "\u0939\u092E\u093E\u0930\u0940"],
    context_prefix_prompt: "\u0916\u094B\u091C \u0938\u0947 \u0938\u0902\u0926\u0930\u094D\u092D:",
    context_suffix_prompt: '\u092A\u094D\u0930\u0926\u093E\u0928 \u0915\u093F\u090F \u0917\u090F \u0938\u0902\u0926\u0930\u094D\u092D \u0915\u093E \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0915\u0947 "\u0906\u092A\u0915\u0947 \u0928\u094B\u091F\u094D\u0938 \u0915\u0947 \u0906\u0927\u093E\u0930 \u092A\u0930..." \u0915\u0940 \u0924\u0930\u0939 \u0909\u0924\u094D\u0924\u0930 \u0926\u0947\u0902',
    initial_message: "\u0928\u092E\u0938\u094D\u0924\u0947, Smart Chat \u092E\u0947\u0902 \u0906\u092A\u0915\u093E \u0938\u094D\u0935\u093E\u0917\u0924 \u0939\u0948\u0964 \u0905\u092A\u0928\u0947 \u0928\u094B\u091F\u094D\u0938 \u0915\u0947 \u092C\u093E\u0930\u0947 \u092E\u0947\u0902 \u092E\u0941\u091D\u0938\u0947 \u0915\u094B\u0908 \u092A\u094D\u0930\u0936\u094D\u0928 \u092A\u0942\u091B\u0947\u0902 \u0914\u0930 \u092E\u0948\u0902 \u0909\u0924\u094D\u0924\u0930 \u0926\u0947\u0928\u0947 \u0915\u093E \u092A\u094D\u0930\u092F\u093E\u0938 \u0915\u0930\u0942\u0902\u0917\u093E\u0964"
  },
  ar: {
    name: "\u0627\u0644\u0639\u0631\u0628\u064A\u0629",
    pronouns: ["\u0623\u0646\u0627", "\u0644\u064A", "\u0646\u062D\u0646", "\u0644\u0646\u0627", "\u064A", "\u0646\u0627"],
    context_prefix_prompt: "\u0633\u064A\u0627\u0642 \u0645\u0646 \u0627\u0644\u0628\u062D\u062B:",
    context_suffix_prompt: '\u0627\u0633\u062A\u062E\u062F\u0645 \u0627\u0644\u0633\u064A\u0627\u0642 \u0627\u0644\u0645\u0642\u062F\u0645 \u0644\u0644\u0631\u062F \u0645\u062B\u0644 "\u0628\u0646\u0627\u0621\u064B \u0639\u0644\u0649 \u0645\u0644\u0627\u062D\u0638\u0627\u062A\u0643..."',
    initial_message: "\u0645\u0631\u062D\u0628\u0627\u064B \u0628\u0643 \u0641\u064A Smart Chat. \u0627\u0633\u0623\u0644\u0646\u064A \u0633\u0624\u0627\u0644\u0627\u064B \u062D\u0648\u0644 \u0645\u0644\u0627\u062D\u0638\u0627\u062A\u0643 \u0648\u0633\u0623\u062D\u0627\u0648\u0644 \u0627\u0644\u0625\u062C\u0627\u0628\u0629 \u0639\u0644\u064A\u0647."
  },
  bn: {
    name: "\u09AC\u09BE\u0982\u09B2\u09BE",
    pronouns: ["\u0986\u09AE\u09BF", "\u0986\u09AE\u09BE\u09B0", "\u0986\u09AE\u09BE\u0995\u09C7", "\u0986\u09AE\u09B0\u09BE", "\u0986\u09AE\u09BE\u09A6\u09C7\u09B0", "\u0986\u09AE\u09BE\u09A6\u09C7\u09B0\u0995\u09C7"],
    context_prefix_prompt: "\u0985\u09A8\u09C1\u09B8\u09A8\u09CD\u09A7\u09BE\u09A8 \u09A5\u09C7\u0995\u09C7 \u09AA\u09CD\u09B0\u09C7\u0995\u09CD\u09B7\u09BE\u09AA\u099F:",
    context_suffix_prompt: '\u09AA\u09CD\u09B0\u09A6\u09A4\u09CD\u09A4 \u09AA\u09CD\u09B0\u09B8\u0999\u09CD\u0997 \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0 \u0995\u09B0\u09C7 "\u0986\u09AA\u09A8\u09BE\u09B0 \u09A8\u09CB\u099F\u09C7\u09B0 \u09AD\u09BF\u09A4\u09CD\u09A4\u09BF\u09A4\u09C7..." \u098F\u09B0 \u09AE\u09A4\u09CB \u0995\u09B0\u09C7 \u0989\u09A4\u09CD\u09A4\u09B0 \u09A6\u09BF\u09A8',
    initial_message: "\u09B9\u09CD\u09AF\u09BE\u09B2\u09CB, Smart Chat-\u098F \u0986\u09AA\u09A8\u09BE\u0995\u09C7 \u09B8\u09CD\u09AC\u09BE\u0997\u09A4\u09AE\u0964 \u0986\u09AA\u09A8\u09BE\u09B0 \u09A8\u09CB\u099F \u09B8\u09AE\u09CD\u09AA\u09B0\u09CD\u0995\u09C7 \u0986\u09AE\u09BE\u0995\u09C7 \u09AA\u09CD\u09B0\u09B6\u09CD\u09A8 \u0995\u09B0\u09C1\u09A8, \u0986\u09AE\u09BF \u0989\u09A4\u09CD\u09A4\u09B0 \u09A6\u09C7\u0993\u09AF\u09BC\u09BE\u09B0 \u099A\u09C7\u09B7\u09CD\u099F\u09BE \u0995\u09B0\u09AC\u0964"
  },
  ur: {
    name: "\u0627\u0631\u062F\u0648",
    pronouns: ["\u0645\u06CC\u06BA", "\u0645\u062C\u06BE\u06D2", "\u0645\u06CC\u0631\u0627", "\u06C1\u0645", "\u06C1\u0645\u06CC\u06BA", "\u06C1\u0645\u0627\u0631\u0627"],
    context_prefix_prompt: "\u062A\u0644\u0627\u0634 \u0938\u0947 \u0633\u06CC\u0627\u0642 \u0648 \u0633\u0628\u0627\u0642:",
    context_suffix_prompt: '\u0641\u0631\u0627\u06C1\u0645 \u06A9\u0631\u062F\u06C1 \u0633\u06CC\u0627\u0642 \u0648 \u0633\u0628\u0627\u0642 \u06A9\u0627 \u0627\u0633\u062A\u0639\u0645\u0627\u0644 \u06A9\u0631\u062A\u06D2 \u06C1\u0648\u0626\u06D2 \u0627\u06CC\u0633\u06D2 \u062C\u0648\u0627\u0628 \u062F\u06CC\u06BA \u062C\u06CC\u0633\u06D2 "\u0622\u067E \u06A9\u06D2 \u0646\u0648\u0679\u0633 \u0915\u0940 \u0628\u0646\u06CC\u0627\u062F \u067E\u0631..."',
    initial_message: "\u062E\u0648\u0634 \u0622\u0645\u062F\u06CC\u062F\u060C Smart Chat \u0645\u06CC\u06BA\u06D4 \u0627\u067E\u0646\u06D2 \u0646\u0648\u0679\u0633 \u06A9\u06D2 \u0628\u0627\u0631\u06D2 \u0645\u06CC\u06BA \u0645\u062C\u06BE \u0633\u06D2 \u06A9\u0648\u0626\u06CC \u0633\u0648\u0627\u0644 \u067E\u0648\u0686\u06BE\u06CC\u06BA \u0627\u0648\u0631 \u0645\u06CC\u06BA \u062C\u0648\u0627\u0628 \u062F\u06CC\u0646\u06D2 \u06A9\u06CC \u06A9\u0648\u0634\u0634 \u06A9\u0631\u0648\u06BA \u06AF\u0627\u06D4"
  },
  sw: {
    name: "Kiswahili",
    pronouns: ["mimi", "yangu", "sisi", "yetu"],
    context_prefix_prompt: "Muktadha kutoka utafutaji:",
    context_suffix_prompt: 'Tumia muktadha uliotolewa kujibu kama "Kulingana na maelezo yako..."',
    initial_message: "Hujambo, karibu kwenye Smart Chat. Niulize swali kuhusu maelezo yako na nitajaribu kujibu."
  },
  pl: {
    name: "Polski",
    pronouns: ["ja", "mnie", "m\xF3j", "moja", "moje", "my", "nas", "nasz", "nasza", "nasze"],
    context_prefix_prompt: "Kontekst z wyszukiwania:",
    context_suffix_prompt: 'U\u017Cyj podanego kontekstu, aby odpowiedzie\u0107 jak "Na podstawie twoich notatek..."',
    initial_message: "Cze\u015B\u0107, witaj w Smart Chat. Zadaj mi pytanie dotycz\u0105ce twoich notatek, a postaram si\u0119 odpowiedzie\u0107."
  },
  uk: {
    name: "\u0423\u043A\u0440\u0430\u0457\u043D\u0441\u044C\u043A\u0430",
    pronouns: ["\u044F", "\u043C\u0435\u043D\u0456", "\u043C\u0456\u0439", "\u043C\u043E\u044F", "\u043C\u043E\u0454", "\u043C\u0438", "\u043D\u0430\u0441", "\u043D\u0430\u0448", "\u043D\u0430\u0448\u0430", "\u043D\u0430\u0448\u0435"],
    context_prefix_prompt: "\u041A\u043E\u043D\u0442\u0435\u043A\u0441\u0442 \u0437 \u043F\u043E\u0448\u0443\u043A\u0443:",
    context_suffix_prompt: '\u0412\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u0439\u0442\u0435 \u043D\u0430\u0434\u0430\u043D\u0438\u0439 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442, \u0449\u043E\u0431 \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0441\u0442\u0438 \u044F\u043A "\u041D\u0430 \u043E\u0441\u043D\u043E\u0432\u0456 \u0432\u0430\u0448\u0438\u0445 \u043D\u043E\u0442\u0430\u0442\u043E\u043A..."',
    initial_message: "\u041F\u0440\u0438\u0432\u0456\u0442, \u043B\u0430\u0441\u043A\u0430\u0432\u043E \u043F\u0440\u043E\u0441\u0438\u043C\u043E \u0434\u043E Smart Chat. \u0417\u0430\u0434\u0430\u0439\u0442\u0435 \u043C\u0435\u043D\u0456 \u043F\u0438\u0442\u0430\u043D\u043D\u044F \u043F\u0440\u043E \u0432\u0430\u0448\u0456 \u043D\u043E\u0442\u0430\u0442\u043A\u0438, \u0456 \u044F \u0441\u043F\u0440\u043E\u0431\u0443\u044E \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0441\u0442\u0438."
  },
  nl: {
    name: "Nederlands",
    pronouns: ["ik", "mij", "me", "mijn", "wij", "we", "ons", "onze"],
    context_prefix_prompt: "Context van zoekopdracht:",
    context_suffix_prompt: 'Gebruik de verstrekte context om te reageren als "Gebaseerd op uw notities..."',
    initial_message: "Hallo, welkom bij Smart Chat. Stel me een vraag over uw notities en ik zal proberen deze te beantwoorden."
  },
  sv: {
    name: "Svenska",
    pronouns: ["jag", "mig", "min", "mitt", "mina", "vi", "oss", "v\xE5r", "v\xE5rt", "v\xE5ra"],
    context_prefix_prompt: "Kontext fr\xE5n s\xF6kning:",
    context_suffix_prompt: 'Anv\xE4nd den tillhandah\xE5llna kontexten f\xF6r att svara som "Baserat p\xE5 dina anteckningar..."',
    initial_message: "Hej, v\xE4lkommen till Smart Chat. St\xE4ll en fr\xE5ga om dina anteckningar s\xE5 ska jag f\xF6rs\xF6ka svara."
  },
  tr: {
    name: "T\xFCrk\xE7e",
    pronouns: ["ben", "bana", "benim", "biz", "bize", "bizim"],
    context_prefix_prompt: "Arama ba\u011Flam\u0131:",
    context_suffix_prompt: 'Verilen ba\u011Flam\u0131 kullanarak "Notlar\u0131n\u0131za dayanarak..." \u015Feklinde cevap verin',
    initial_message: "Merhaba, Smart Chat'e ho\u015F geldiniz. Notlar\u0131n\u0131z hakk\u0131nda bana bir soru sorun, yan\u0131tlamaya \xE7al\u0131\u015Faca\u011F\u0131m."
  },
  ru: {
    name: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
    pronouns: ["\u044F", "\u043C\u043E\u0451", "\u043C\u043E\u0435", "\u043C\u043E\u0439", "\u043C\u043D\u0435", "\u043C\u043E\u0438\u0445", "\u043C\u043E\u0438", "\u043C\u043E\u0451\u043C", "\u043C\u043E\u0435\u043C", "\u043D\u0430\u0448", "\u043D\u0430\u0448\u0435", "\u043D\u0430\u0448\u0435\u043C", "\u043D\u0430\u0448\u0435\u043C\u0443", "\u043D\u0430\u0448\u0438\u043C", "\u043D\u0430\u0448\u0438", "\u043C\u044B"],
    context_prefix_prompt: "\u041A\u043E\u043D\u0442\u0435\u043A\u0441\u0442 \u0438\u0437 \u043F\u043E\u0438\u0441\u043A\u0430:",
    context_suffix_prompt: '\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 \u043F\u0440\u0435\u0434\u043E\u0441\u0442\u0430\u0432\u043B\u0435\u043D\u043D\u044B\u0439 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442, \u0447\u0442\u043E\u0431\u044B \u043E\u0442\u0432\u0435\u0442\u0438\u0442\u044C \u043A\u0430\u043A "\u041D\u0430 \u043E\u0441\u043D\u043E\u0432\u0435 \u0432\u0430\u0448\u0438\u0445 \u0437\u0430\u043F\u0438\u0441\u0435\u0439..."',
    initial_message: "\u041F\u0440\u0438\u0432\u0435\u0442, \u0434\u043E\u0431\u0440\u043E \u043F\u043E\u0436\u0430\u043B\u043E\u0432\u0430\u0442\u044C \u0432 Smart Chat. \u0417\u0430\u0434\u0430\u0439\u0442\u0435 \u043C\u043D\u0435 \u0432\u043E\u043F\u0440\u043E\u0441 \u043E \u0432\u0430\u0448\u0438\u0445 \u0437\u0430\u043F\u0438\u0441\u044F\u0445, \u0438 \u044F \u043F\u043E\u0441\u0442\u0430\u0440\u0430\u044E\u0441\u044C \u043E\u0442\u0432\u0435\u0442\u0438\u0442\u044C."
  }
};

// smart-chat-v0/utils/self_referential_keywords.js
function contains_self_referential_keywords(user_input, language) {
  const language_settings = ScTranslations_default[language];
  if (!language_settings) return false;
  let check_str = `${user_input}`;
  check_str = check_str.replace(/\[\[[^\]]+\]\]/g, "").replace(/\/[^/]*?\//g, "").replace(/@"[^"]+"/g, "");
  return new RegExp(`\\b(${language_settings.pronouns.join("|")})\\b`, "i").test(check_str);
}
function get_language_options() {
  return Object.entries(ScTranslations_default).map(([language, language_settings]) => ({ value: language, name: language_settings.name }));
}
function get_initial_message(language) {
  const language_settings = ScTranslations_default[language];
  return language_settings.initial_message;
}
function get_translated_context_suffix_prompt(language) {
  const language_settings = ScTranslations_default[language];
  return language_settings.context_suffix_prompt;
}
function get_translated_context_prefix_prompt(language) {
  const language_settings = ScTranslations_default[language];
  return language_settings.context_prefix_prompt;
}

// smart-chat-v0/smart_threads.js
var SmartThreads = class extends SmartSources2 {
  // /**
  //  * Initializes the file system and preloads chat models
  //  * @async
  //  */
  // async init() {
  //   await this.fs.init();
  // }
  /**
   * Initializes items by setting up the file system and loading sources.
   * @async
   * @returns {Promise<void>}
   */
  async init_items() {
    if (!await this.fs.exists(this.source_dir)) await this.fs.mkdir(this.source_dir);
    (await this.fs.list(this.source_dir)).filter((file) => this.source_adapters?.[file.extension]).forEach((file) => {
      const key = file.path.replace(this.source_dir + "/", "").replace("." + file.extension, "");
      this.items[key] = new this.item_type(this.env, { path: file.path, key });
      this.items[key].source_adapter.import();
    });
  }
  /**
   * Renders the chat interface
   * @async
   * @param {HTMLElement} [container] - Container element to render into
   * @param {Object} [opts={}] - Rendering options
   * @returns {DocumentFragment} Rendered chat interface
   */
  async render(container = this.container, opts = {}) {
    if (Object.keys(opts).length > 0) this.render_opts = opts;
    if (container && (!this.container || this.container !== container)) this.container = container;
    const frag = await this.env.render_component("smart_chat", this, this.render_opts);
    this.env.smart_view.empty(container);
    container.appendChild(frag);
    return frag;
  }
  get chat_model_settings() {
    if (!this.settings.chat_model) this.settings.chat_model = {};
    return this.settings.chat_model;
  }
  /**
   * @property {Object} chat_model - The AI chat model instance
   * @readonly
   */
  get chat_model() {
    if (!this._chat_model) {
      this._chat_model = this.env.init_module("smart_chat_model", {
        model_config: {},
        settings: this.chat_model_settings,
        env: this.env,
        reload_model: this.reload_chat_model.bind(this),
        re_render_settings: this.re_render_settings.bind(this)
      });
    }
    return this._chat_model;
  }
  reload_chat_model() {
    console.log("reload_chat_model");
    this.chat_model.unload();
    this._chat_model = null;
  }
  get container() {
    return this._container;
  }
  set container(container) {
    this._container = container;
  }
  /**
   * @property {Object} default_settings - Default configuration for models
   * @readonly
   * @returns {Object} settings - Default settings object containing:
   * @returns {Object} settings.chat_model - Chat model configuration
   * @returns {string} settings.chat_model.adapter - Default adapter
   * @returns {Object} settings.chat_model.openai - OpenAI-specific settings
   * @returns {Object} settings.embed_model - Embedding model configuration
   */
  get default_settings() {
    return {
      chat_model: {
        adapter: "openai",
        openai: {
          model_key: "gpt-4o"
        }
      },
      embed_model: {
        model_key: "None"
      }
    };
  }
  re_render_settings() {
    this.env.smart_view.empty(this.settings_container);
    this.render_settings();
  }
  async render_settings(container = this.settings_container, opts = {}) {
    container = await this.render_collection_settings(container, opts);
    const chat_model_frag = await this.env.render_component("settings", this.chat_model, opts);
    container.appendChild(chat_model_frag);
    return container;
  }
  /**
   * @property {Object} settings_config - Processed settings configuration
   * @readonly
   */
  get settings_config() {
    return {
      "language": {
        name: "Language",
        type: "dropdown",
        options_callback: "get_language_options",
        description: "The language to use for the chat.",
        default: "en"
      },
      "review_context": {
        name: "Review Context",
        type: "toggle",
        default: false,
        description: "Whether to review the retrieved context before the AI completes the message."
      },
      "lookup_limit": {
        name: "Lookup Limit",
        type: "number",
        default: 10,
        description: "The maximum number of context items to retrieve via lookup."
      },
      "send_tool_output_in_user_message": {
        name: "Send Tool Output in User Message",
        type: "toggle",
        default: false,
        description: "Whether to send tool output in the user message."
      }
    };
  }
  get_language_options() {
    return get_language_options();
  }
  get initial_message() {
    return get_initial_message(this.language);
  }
  get language() {
    return this.settings.language || "en";
  }
  /**
   * Gets the currently active thread based on the chat box data-thread-key
   * @returns {SmartThread} The active thread
   */
  get_active_thread() {
    const chat_box = this.container?.querySelector(".sc-thread");
    if (!chat_box) return null;
    const thread_key = chat_box.getAttribute("data-thread-key");
    if (!thread_key) return null;
    return this.get(thread_key);
  }
  queue_save() {
    if (this._queue_process_save) {
      clearTimeout(this._queue_process_save);
      this._queue_process_save = null;
    }
    this._queue_process_save = setTimeout(async () => {
      await this.process_save_queue();
      this._queue_process_save = null;
    }, 3e3);
  }
  /**
   * @property {string} data_folder - Path to chat history storage
   * @readonly
   */
  get data_folder() {
    return this.env.opts.env_path + (this.env.opts.env_path ? "/" : "") + ".smart-env";
  }
  get source_dir() {
    return this.data_folder + "/" + this.collection_key;
  }
  get fs() {
    if (!this._fs) {
      this._fs = super.fs;
      this._fs.excluded_patterns = [];
    }
    return this._fs;
  }
  // disable embed_model for SmartThreads
  get embed_model() {
    return null;
  }
  async process_embed_queue() {
    console.log("skipping embed queue processing for SmartThreads");
  }
  async process_load_queue() {
    console.log("skipping load queue processing for SmartThreads");
  }
};

// smart-chat-v0/components/thread.js
function build_html15(thread, opts = {}) {
  return `
    <div class="sc-thread" data-thread-key="${thread.key}">
      <div class="sc-message-container">
        ${opts.show_welcome && !thread.messages.length ? `
          <div class="sc-message assistant">
            <div class="sc-message-content">
              <span>${thread.collection.initial_message}</span>
            </div>
          </div>
        ` : ""}
      </div>
      <div class="sc-typing-indicator">
        <div class="sc-typing-dots">
          <div class="sc-typing-dot"></div>
          <div class="sc-typing-dot"></div>
          <div class="sc-typing-dot"></div>
        </div>
      </div>
      <div class="sc-config-error-notice" style="display: none;"></div>
      <div class="sc-chat-form">
        <textarea class="sc-chat-input" placeholder="Use @ to add context. Try &quot;Based on my notes&quot; or &quot;Summarize [[this note]]&quot; or &quot;Important tasks in /folder/&quot;"></textarea>
        <div class="sc-btn-container">
          <span id="sc-abort-button" style="display: none;">${this.get_icon_html("square")}</span>
          <button class="send-button" id="sc-send-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="none" viewBox="0 0 32 32">
              <circle cx="16" cy="16" r="16" fill="currentColor" />
              <path fill="currentColor" fill-rule="evenodd" d="M15.192 8.906a1.143 1.143 0 0 1 1.616 0l5.143 5.143a1.143 1.143 0 0 1-1.616 1.616l-3.192-3.192v9.813a1.143 1.143 0 0 1-2.286 0v-9.813l-3.192 3.192a1.143 1.143 0 1 1-1.616-1.616z" clip-rule="evenodd" fill="#727272"></path>
            </svg>
          </button>
        </div>
      </div>
    </div>
  `;
}
async function render21(thread, opts = {}) {
  const html = build_html15.call(this, thread, {
    show_welcome: opts.show_welcome !== false
  });
  const frag = this.create_doc_fragment(html);
  return await post_process18.call(this, thread, frag, opts);
}
async function post_process18(thread, frag, opts) {
  const container = frag.querySelector(".sc-message-container");
  if (thread.messages.length) {
    thread.messages.forEach((msg) => {
      const msg_elm = document.createElement("div");
      msg_elm.id = msg.data.id;
      container.appendChild(msg_elm);
    });
    await Promise.all(
      thread.messages.map((msg) => msg.render(container))
    );
  }
  const chat_input = frag.querySelector(".sc-chat-form textarea");
  if (chat_input) {
    chat_input.addEventListener("keydown", async (e) => {
      const is_mod = this.adapter.is_mod_event(e);
      if (e.key === "Enter" && (is_mod || e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        await send_message(chat_input, thread);
        return;
      }
    });
    chat_input.addEventListener("keyup", (e) => handle_chat_input_keyup.call(this, e, chat_input));
  }
  if (container.scrollHeight > container.clientHeight) {
    container.scrollTop = container.scrollHeight;
  }
  const send_button = frag.querySelector("#sc-send-button");
  send_button.addEventListener("click", async () => {
    await send_message(chat_input, thread);
  });
  const abort_button = frag.querySelector("#sc-abort-button");
  abort_button.addEventListener("click", () => {
    thread.chat_model.abort_current_response();
    thread.clear_streaming_ux();
  });
  const validation_result = thread.chat_model.validate_config();
  if (!validation_result.valid) {
    const notice = frag.querySelector(".sc-config-error-notice");
    const message = document.createElement("span");
    message.textContent = validation_result.message;
    notice.appendChild(message);
    notice.style.display = "";
    const hide_button = document.createElement("button");
    hide_button.textContent = "Hide";
    notice.appendChild(hide_button);
    hide_button.addEventListener("click", () => {
      notice.style.display = "none";
    });
  }
  const typing_indicator = frag.querySelector(".sc-typing-indicator");
  if (typing_indicator) {
    const is_dark = document.body.classList.contains("theme-dark");
    typing_indicator.style.setProperty("--text-muted", is_dark ? "rgba(255, 255, 255, 0.4)" : "rgba(0, 0, 0, 0.4)");
  }
  return frag;
}
async function send_message(chat_input, thread) {
  const message = chat_input.value;
  chat_input.value = "";
  await thread.handle_message_from_user(message);
  await thread.save();
}
function handle_chat_input_keyup(e, chat_input) {
  clearTimeout(this.resize_debounce);
  this.resize_debounce = setTimeout(() => {
    chat_input.style.height = "auto";
    chat_input.style.height = `${chat_input.scrollHeight}px`;
  }, 200);
}

// smart-chat-v0/utils/folder_references.js
function contains_folder_reference(user_input) {
  const first_slash = user_input.indexOf("/");
  if (first_slash === -1) return false;
  const last_slash = user_input.lastIndexOf("/");
  if (last_slash - first_slash <= 1) return false;
  const first_open_parentheses = user_input.indexOf("(");
  const first_close_parentheses = user_input.indexOf(")");
  if (first_open_parentheses > first_slash && first_close_parentheses < last_slash) return true;
  const first_wiki_open = user_input.indexOf("[[");
  const first_wiki_close = user_input.indexOf("]]");
  if (first_wiki_open !== -1 && first_wiki_close !== -1) {
    if (first_slash > first_wiki_open && last_slash < first_wiki_close) return false;
  }
  if (first_open_parentheses !== -1 && first_close_parentheses !== -1) {
    if (first_slash > first_open_parentheses && last_slash < first_close_parentheses) return false;
    const without_content_in_parentheses = user_input.slice(0, first_open_parentheses) + user_input.slice(first_close_parentheses + 1);
    if (without_content_in_parentheses.indexOf("/") !== -1) return false;
    if (without_content_in_parentheses.indexOf("/") === without_content_in_parentheses.lastIndexOf("/")) return false;
  }
  return true;
}
function extract_folder_references(folders, user_input) {
  folders = folders.slice();
  const matches = folders.sort((a, b) => b.length - a.length).map((folder) => {
    if (user_input.indexOf(folder) !== -1) {
      user_input = user_input.replace(folder, "");
      return folder;
    }
    return false;
  }).filter((folder) => folder && folder !== "/");
  if (matches) return matches;
  return false;
}

// smart-chat-v0/utils/internal_links.js
function contains_internal_link(user_input) {
  if (user_input.indexOf("[[") === -1) return false;
  if (user_input.indexOf("]]") === -1) return false;
  return true;
}
function extract_internal_links(user_input) {
  const matches = [];
  const regex = /\[\[(.*?)\]\]/g;
  let match;
  while ((match = regex.exec(user_input)) !== null) {
    matches.push(match[1]);
  }
  return matches;
}
function contains_internal_embedded_link(user_input) {
  if (user_input.indexOf("![") === -1) return false;
  if (user_input.indexOf("]") === -1) return false;
  return true;
}
function extract_internal_embedded_links(user_input) {
  const matches = [];
  const regex = /[!]\[\[(.*?)\]\]/g;
  let match;
  while ((match = regex.exec(user_input)) !== null) {
    matches.push(match);
  }
  return matches;
}

// smart-chat-v0/components/error.js
function build_html16(error, opts = {}) {
  const error_message = error?.error?.message || error?.message || "An unknown error occurred";
  const error_code = error?.error?.code || error?.code;
  const error_type = error?.error?.type || error?.type || "Error";
  return `
    <div class="sc-error-container" role="alert">
      <div class="sc-error-header">
        <span class="sc-error-icon">${this.get_icon_html("alert-triangle")}</span>
        <span class="sc-error-type">${error_type}</span>
        ${error_code ? `<span class="sc-error-code">(${error_code})</span>` : ""}
        <button class="sc-error-close" title="Dismiss">${this.get_icon_html("x")}</button>
      </div>
      <div class="sc-error-content">
        <p class="sc-error-message">${error_message}</p>
        ${error?.error?.details ? `
          <button class="sc-error-details-toggle" aria-expanded="false">
            Show Details ${this.get_icon_html("chevron-down")}
          </button>
          <div class="sc-error-details" hidden>
            <pre>${JSON.stringify(error.error.details, null, 2)}</pre>
          </div>
        ` : ""}
      </div>
      ${opts.retry ? `
        <div class="sc-error-actions">
          <button class="sc-error-retry">
            ${this.get_icon_html("refresh-cw")} Retry
          </button>
        </div>
      ` : ""}
    </div>
  `;
}
async function render22(error, opts = {}) {
  const html = build_html16.call(this, error, opts);
  const frag = this.create_doc_fragment(html);
  return await post_process19.call(this, error, frag, opts);
}
async function post_process19(error, frag, opts) {
  const close_button = frag.querySelector(".sc-error-close");
  if (close_button) {
    close_button.addEventListener("click", () => {
      const container = close_button.closest(".sc-error-container");
      container.remove();
    });
  }
  const details_toggle = frag.querySelector(".sc-error-details-toggle");
  const details_content = frag.querySelector(".sc-error-details");
  if (details_toggle && details_content) {
    details_toggle.addEventListener("click", () => {
      const is_expanded = details_toggle.getAttribute("aria-expanded") === "true";
      details_toggle.setAttribute("aria-expanded", !is_expanded);
      details_content.hidden = is_expanded;
      this.safe_inner_html(details_toggle, `
        ${is_expanded ? "Show" : "Hide"} Details ${this.get_icon_html(is_expanded ? "chevron-down" : "chevron-up")}
      `);
    });
  }
  const retry_button = frag.querySelector(".sc-error-retry");
  if (retry_button && opts.retry && typeof opts.retry === "function") {
    retry_button.addEventListener("click", async () => {
      const container = retry_button.closest(".sc-error-container");
      container.classList.add("retrying");
      retry_button.disabled = true;
      this.safe_inner_html(retry_button, `${this.get_icon_html("loader")} Retrying...`);
      try {
        await opts.retry();
        container.remove();
      } catch (retry_error) {
        const new_error_frag = await render22.call(this, retry_error, opts);
        container.replaceWith(new_error_frag);
      }
    });
  }
  if (opts.auto_dismiss) {
    const dismiss_delay = typeof opts.auto_dismiss === "number" ? opts.auto_dismiss : 5e3;
    setTimeout(() => {
      const container = frag.querySelector(".sc-error-container");
      if (container) {
        container.classList.add("sc-error-fade-out");
        setTimeout(() => container.remove(), 300);
      }
    }, dismiss_delay);
  }
  return frag;
}

// smart-chat-v0/smart_thread.js
var SmartThread = class extends SmartSource2 {
  /**
   * @static
   * @property {Object} defaults - Default configuration for a new thread
   */
  static get defaults() {
    return {
      data: {
        created_at: null,
        responses: {},
        messages: {},
        branches: {},
        path: null
      }
    };
  }
  // Define available tools
  tools = {
    lookup: {
      type: "function",
      function: {
        name: "lookup",
        description: "Performs a semantic search of the user's data to surface relevant content.",
        parameters: {
          type: "object",
          properties: {
            hypotheticals: {
              type: "object",
              description: "Predicted relevant notes in markdown format. Provide at least three.",
              properties: {
                "1": { type: "string" },
                "2": { type: "string" },
                "3": { type: "string" }
              },
              required: ["1", "2", "3"]
            }
          },
          required: ["hypotheticals"]
        }
      }
    }
  };
  /**
   * Imports the SmartSource by checking for updates and parsing content.
   * @async
   */
  async import() {
    this._queue_import = false;
    try {
      await this.source_adapter.import();
    } catch (err) {
      this.queue_import();
      console.error(err, err.stack);
    }
  }
  /**
   * Renders the thread UI.
   * @async
   * @param {HTMLElement} [container=this.container] - The container element to render into.
   * @param {Object} [opts={}] - Additional rendering options.
   * @returns {Promise<DocumentFragment>} The rendered thread interface.
   */
  async render(container = this.container, opts = {}) {
    const frag = await this.env.render_component("thread", this, opts);
    if (container) {
      container.empty();
      if (container.classList.contains("sc-thread")) {
        container.replaceWith(frag);
      } else {
        container.appendChild(frag);
      }
    }
    return frag;
  }
  /**
   * Handles a new user message by creating a corresponding SmartMessage.
   * This involves parsing the message content for inline references, folder references,
   * and self-referential keywords.
   *
   * @async
   * @param {string} content - The raw text content of the user's message.
   */
  async handle_message_from_user(content) {
    try {
      const new_msg_data = this.#prepare_new_user_message_data(content);
      this.#process_inline_embedded_links(new_msg_data);
      this.#extract_context_from_message_content(new_msg_data);
      await this.env.smart_messages.create_or_update(new_msg_data);
    } catch (error) {
      console.error("Error in handle_message_from_user:", error);
    }
  }
  /**
   * Creates a new system message or updates the last existing system message.
   * Useful for adding guidance or instructions from the system to the user.
   *
   * @async
   * @param {string|Object} system_message - The system message as text or a content object.
   */
  async add_system_message(system_message) {
    if (typeof system_message === "string") {
      system_message = { type: "text", text: system_message };
    }
    if (!system_message.type) system_message.type = "text";
    const last_msg = this.messages[this.messages.length - 1];
    if (last_msg?.role === "system") {
      last_msg.content.push(system_message);
      last_msg.render();
    } else {
      await this.env.smart_messages.create_or_update({
        role: "system",
        content: [system_message],
        thread_key: this.key
      });
    }
  }
  /**
   * Processes and adds the AI model's response to the thread.
   * If the model's response includes tool calls, they are handled accordingly.
   *
   * @async
   * @param {Object} response - The raw response object from the AI model.
   * @param {Object} [opts={}] - Additional options.
   * @returns {Promise<Array>} Array of created or updated message objects.
   */
  async handle_message_from_chat_model(response, opts = {}) {
    const response_id = response.id;
    if (!response_id) return [];
    const new_messages = [];
    for (const choice of response.choices || []) {
      const msg_data = { ...choice?.message || choice, thread_key: this.key, response_id };
      const existing_msg = this.messages.find((m) => m.data.response_id === response_id);
      if (existing_msg) msg_data.key = existing_msg.key;
      const new_msg = await this.env.smart_messages.create_or_update(msg_data);
      new_messages.push(new_msg);
      if (msg_data.tool_calls?.length > 0) {
        await this.handle_tool_calls(msg_data.tool_calls, msg_data);
        await new_msg.init();
      }
    }
    return new_messages;
  }
  /**
   * Handles the execution of detected tool calls from a message.
   * This is a base implementation that should be overridden by subclasses
   * to provide specific tool handling logic.
   * 
   * @async
   * @param {Array<Object>} tool_calls - Array of tool call objects found in the message
   * @param {Object} msg_data - Data of the message that triggered these tool calls
   */
  async handle_tool_calls(tool_calls, msg_data) {
    console.warn("handle_tool_calls() not implemented in base class");
  }
  /**
   * Converts the entire thread state into a request payload for the AI model.
   * This involves collecting all messages and optionally adding tool definitions and choices.
   *
   * @async
   * @returns {Promise<Object>} The request object ready to be sent to the AI model.
   */
  async to_request() {
    const request = { messages: [] };
    for (let i = 0; i < this.messages.length; i++) {
      const msg = this.messages[i];
      if (this.settings.send_tool_output_in_user_message) {
        if (this.#should_include_tool_output(msg)) {
          const combined_msg = await this.#combine_user_and_tool_output(msg);
          request.messages.push(combined_msg);
          continue;
        }
        if (msg.role === "assistant" && msg.tool_calls?.length) {
          continue;
        }
        if (msg.role === "tool") {
          continue;
        }
      }
      request.messages.push(await msg.to_request());
      if (msg.context?.has_self_ref || msg.context?.folder_refs) {
        request.tools = [this.tools["lookup"]];
        if (msg.is_last_message && msg.role === "user") {
          request.tool_choice = { type: "function", function: { name: "lookup" } };
        }
      }
    }
    if (this.last_message_is_tool && this.settings.send_tool_output_in_user_message) {
      request.tools = null;
    }
    if (this.last_message_is_tool) {
      delete request.tool_choice;
    }
    request.temperature = 0.3;
    request.top_p = 1;
    request.presence_penalty = 0;
    request.frequency_penalty = 0;
    this.#reorder_last_user_message_if_needed(request);
    return request;
  }
  get last_message_is_tool() {
    const last_msg = this.messages[this.messages.length - 1];
    return last_msg?.role === "tool";
  }
  /**
   * Sends the current thread state to the AI model for completion.
   * Handles streaming and non-streaming responses, as well as errors.
   *
   * @async
   */
  async complete() {
    this.show_typing_indicator();
    const request = await this.to_request();
    const should_stream = this.chat_model.can_stream && (!request.tool_choice || request.tool_choice === "none");
    if (should_stream) {
      await this.chat_model.stream(request, {
        chunk: this.chunk_handler.bind(this),
        done: this.done_handler.bind(this),
        error: this.error_handler.bind(this)
      });
    } else {
      const response = await this.chat_model.complete(request);
      if (response.error) {
        return this.error_handler(response);
      }
      this.data.responses[response.id] = response;
      await this.handle_message_from_chat_model(response);
    }
    this.hide_typing_indicator();
  }
  /**
   * Handles partial chunks of a streaming response from the model.
   * @async
   * @param {Object} response - The partial response chunk from the model.
   */
  async chunk_handler(response) {
    const msg_items = await this.handle_message_from_chat_model(response);
    if (msg_items?.length > 0) await msg_items[0].render();
  }
  /**
   * Handles the final event of a streaming response from the model.
   * @async
   * @param {Object} response - The final response object from the model.
   */
  async done_handler(response) {
    const msg_items = await this.handle_message_from_chat_model(response);
    this.data.responses[response.id] = response;
    if (msg_items.length > 0) await msg_items[0].init();
  }
  /**
   * Handles error responses from the model, rendering an error message in the thread.
   * @param {Object} response - The error response object.
   */
  error_handler(response) {
    this.hide_typing_indicator();
    this.render_error(response);
    console.error("error_handler", response);
  }
  /**
   * Renders an error message in the UI.
   * @async
   * @param {Object} response - The error response object.
   * @param {HTMLElement} [container=this.messages_container] - Container element for the error.
   * @returns {Promise<DocumentFragment>}
   */
  async render_error(response, container = this.messages_container) {
    const frag = await render22.call(this.smart_view, response);
    if (container) container.appendChild(frag);
    return frag;
  }
  /**
   * @deprecated temp handling until SmartThreads/SmartChats v2
   */
  get file_type() {
    return "json";
  }
  /*** Private Helpers ***/
  /**
   * Prepares initial data for a new user message.
   * @private
   * @param {string} content - The raw user-provided content.
   * @returns {Object} The data object for the new message.
   */
  #prepare_new_user_message_data(content) {
    return {
      thread_key: this.key,
      role: "user",
      content: [{ type: "text", text: content.trim() }],
      context: {}
    };
  }
  /**
   * Processes inline embedded links (e.g., ![[link]]) within the user message.
   * Replaces them with separate message parts (text or images).
   * @private
   * @param {Object} new_msg_data - The message data object to modify.
   */
  #process_inline_embedded_links(new_msg_data) {
    for (let i = 0; i < new_msg_data.content.length; i++) {
      const part = new_msg_data.content[i];
      if (part.type !== "text" || !part.text) continue;
      if (contains_internal_embedded_link(part.text)) {
        const internal_links = extract_internal_embedded_links(part.text);
        for (const [full_match, link_path] of internal_links) {
          const [before, after] = part.text.split(full_match);
          const embedded_part = this.#create_embedded_part(link_path);
          part.text = after;
          if (before?.trim()?.length) {
            new_msg_data.content.splice(
              i,
              0,
              { type: "text", text: before },
              embedded_part
            );
          } else {
            new_msg_data.content.splice(i, 0, embedded_part);
          }
        }
      }
    }
  }
  /**
   * Creates an embedded part object (image or text) from an embedded link path.
   * @private
   * @param {string} link_path - The path to the embedded content.
   * @returns {Object} The embedded part object.
   */
  #create_embedded_part(link_path) {
    const is_image = ["png", "jpg", "jpeg"].some((ext) => link_path.endsWith(ext));
    if (is_image) {
      return { type: "image_url", input: { image_path: link_path } };
    } else {
      const resolved_path = this.env.smart_sources.fs.get_link_target_path(link_path, "/");
      return { type: "text", input: { key: resolved_path } };
    }
  }
  /**
   * Extracts and attaches relevant context from the message content.
   * @private
   * @param {Object} new_msg_data - The message data object to modify.
   */
  #extract_context_from_message_content(new_msg_data) {
    for (let i = 0; i < new_msg_data.content.length; i++) {
      const part = new_msg_data.content[i];
      if (part.type !== "text" || !part.text) continue;
      if (contains_internal_link(part.text)) {
        const internal_links = extract_internal_links(part.text);
        new_msg_data.context.internal_links = internal_links.map(
          (link) => this.env.smart_sources?.fs?.get_link_target_path(link, "/") || link
        );
      }
      if (contains_folder_reference(part.text)) {
        const folders = Object.keys(this.env.smart_sources.fs.folders);
        const folder_refs = extract_folder_references(folders, part.text);
        new_msg_data.context.folder_refs = folder_refs;
      }
      if (contains_self_referential_keywords(part.text, this.language)) {
        new_msg_data.context.has_self_ref = true;
      }
    }
  }
  /**
   * Determines if we should include tool output in the user message based on configuration.
   * @private
   * @param {SmartMessage} msg - The current message being processed.
   * @returns {boolean} True if tool output should be included, false otherwise.
   */
  #should_include_tool_output(msg) {
    return msg.role === "user" && msg.next_message?.tool_calls?.length && !msg.next_message.is_last_message && msg.next_message.next_message?.role === "tool";
  }
  /**
   * Combines the user message with the subsequent tool output, embedding the tool output
   * in the user message request.
   * @private
   * @param {SmartMessage} msg - The user message before the tool output.
   * @returns {Promise<Object>} A message object that includes the tool output followed by the user content.
   */
  async #combine_user_and_tool_output(msg) {
    const message = { role: "user", content: [] };
    const tool_output = await msg.next_message.next_message.tool_call_output_to_request();
    message.content.push({ type: "text", text: tool_output });
    const user_content = await msg.to_request();
    if (user_content.content) {
      message.content.push(...user_content.content);
    }
    return message;
  }
  /**
   * Ensures the last user message is placed at the end of the request if the last message is a tool output.
   * @private
   * @param {Object} request - The request object being built.
   */
  #reorder_last_user_message_if_needed(request) {
    if (request.messages[request.messages.length - 1]?.tool_call_id) {
      const last_user_msg_index = request.messages.findLastIndex((msg) => msg.role === "user");
      if (last_user_msg_index !== -1 && last_user_msg_index !== request.messages.length - 1) {
        const last_user_msg = request.messages.splice(last_user_msg_index, 1)[0];
        request.messages.push(last_user_msg);
        console.log("Moved last user message to the end of the request for better context handling.");
      }
    }
  }
  /**
   * Shows the typing indicator in the thread UI.
   */
  show_typing_indicator() {
    const indicator = this.container?.querySelector(".sc-typing-indicator");
    if (indicator) indicator.classList.add("visible");
  }
  /**
   * Hides the typing indicator in the thread UI.
   */
  hide_typing_indicator() {
    const indicator = this.container?.querySelector(".sc-typing-indicator");
    if (indicator) indicator.classList.remove("visible");
  }
  /*** Getters and Utility Properties ***/
  get chat_model() {
    return this.collection.chat_model;
  }
  get created_at() {
    if (!this.data.created_at) this.data.created_at = Date.now();
    return this.data.created_at;
  }
  /**
   * @property {HTMLElement} container - Container element for the thread UI
   */
  get container() {
    return this.collection.container?.querySelector(".sc-thread");
  }
  get messages_container() {
    return this.container?.querySelector(".sc-message-container");
  }
  /**
   * @property {Array<SmartMessage>} messages - All messages in the thread
   * @readonly
   */
  get messages() {
    return Object.entries(this.data.messages || {}).sort((a, b) => a[1] - b[1]).map(([key]) => this.env.smart_messages.get(this.key + "#" + key));
  }
  /**
   * @alias {Array<SmartMessage>} messages
   * @readonly
   */
  get blocks() {
    return this.messages;
  }
  get_key() {
    if (!this.data.key) this.data.key = "Untitled " + this.created_at;
    return this.data.key;
  }
  /**
   * @property {string} path - Path identifier for the thread
   * @readonly
   */
  get path() {
    if (!this.data.path) {
      this.data.path = this.collection.source_dir + "/" + this.key + "." + this.source_adapter.extension;
    }
    return this.data.path;
  }
  get language() {
    return this.settings.language || "en";
  }
  /**
   * Processes base64 encoding for image files
   * @async
   * @param {string} file_path - Path to the image file
   * @returns {string} Base64 encoded image data URL
   */
  async process_image_to_base64(file_path) {
    const file = this.env.smart_connections_plugin?.app.vault.getFileByPath(file_path);
    if (!file) return null;
    const base642 = await this.env.smart_sources.fs.read(file.path, "base64");
    return `data:image/${file.extension};base64,${base642}`;
  }
  /**
   * Queues the thread for saving via the collection.
   * @returns {void}
   */
  queue_save() {
    if (this.messages.length === 0) return;
    this._queue_save = true;
    this.collection?.queue_save();
  }
  async save() {
    await this.source_adapter.save();
  }
  async rename(new_name) {
    await this.source_adapter.rename(new_name);
  }
  /**
   * Get all branches for a specific message index
   * @param {number} msg_i - Message index to get branches for
   * @returns {Array<Object>} Array of branch message objects
   */
  get_branches(msg_i) {
    return this.data.branches?.[msg_i] || [];
  }
  /**
   * Get the latest branch for a specific message index
   * @param {number} msg_i - Message index to get latest branch for
   * @returns {Object|null} Latest branch message object or null if no branches exist
   */
  get_latest_branch(msg_i) {
    const branches = this.get_branches(msg_i);
    return branches.length > 0 ? branches[branches.length - 1] : null;
  }
  /**
   * Create a new branch from a specific message index
   * @param {number} msg_i - Message index to branch from
   * @param {Object} branch_messages - Messages to store in the branch
   */
  create_branch(msg_i, branch_messages) {
    if (!this.data.branches) this.data.branches = {};
    if (!this.data.branches[msg_i]) this.data.branches[msg_i] = [];
    this.data.branches[msg_i].push(branch_messages);
    this.queue_save();
  }
  move_to_branch(msg_i, branch_messages) {
    this.create_branch(msg_i, branch_messages);
    Object.keys(branch_messages).forEach((id) => delete this.data.messages[id]);
    this.queue_save();
  }
  /**
   * Cycles to the next branch for a given message index
   * @param {number} msg_i - Message index to cycle branches for
   * @returns {Promise<void>}
   */
  async cycle_branch(msg_i) {
    if (!this.data.branches) this.data.branches = {};
    if (!this.data.branches[msg_i]) this.data.branches[msg_i] = [];
    const current_msg = this.messages.find((msg) => this.data.messages[msg.id] === msg_i);
    if (!current_msg) return console.warn("no current message found for msg_i", msg_i);
    const current_messages = Object.entries(this.data.messages).filter(([_, _msg_i]) => _msg_i >= msg_i).reduce((acc, [id, _msg_i]) => ({ ...acc, [id]: _msg_i }), {});
    this.move_to_branch(msg_i, current_messages);
    const branch = this.data.branches?.[msg_i]?.shift();
    this.data.messages = {
      ...this.data.messages,
      ...branch
    };
    await this.render();
    this.queue_save();
  }
};

// node_modules/smart-blocks/smart_block.js
var SmartBlock2 = class extends SmartEntity2 {
  /**
   * Provides default values for a SmartBlock instance.
   * @static
   * @readonly
   * @returns {Object} The default values.
   */
  static get defaults() {
    return {
      data: {
        text: null,
        length: 0,
        last_read: {
          hash: null,
          at: 0
        }
      },
      _embed_input: ""
      // Stored temporarily
    };
  }
  get block_adapter() {
    if (!this._block_adapter) {
      this._block_adapter = new this.collection.opts.block_adapters.md(this);
    }
    return this._block_adapter;
  }
  /**
   * Initializes the SmartBlock instance by queuing an embed if embedding is enabled.
   * @returns {void}
   */
  init() {
    if (this.settings.embed_blocks) super.init();
  }
  /**
   * Queues the entity for embedding.
   * @returns {void}
   */
  queue_embed() {
    this._queue_embed = this.should_embed;
    this.source?.queue_embed();
  }
  /**
   * Queues the block for import via the source.
   * @returns {void}
   */
  queue_import() {
    this.source?.queue_import();
  }
  /**
   * Updates the block's data, clearing embeddings if necessary and preparing embed input.
   * @param {Object} data - The new data to merge into the block.
   * @returns {boolean} `true` if data was updated successfully.
   */
  update_data(data) {
    if (this.should_clear_embeddings(data)) {
      this.data.embeddings = {};
    }
    super.update_data(data);
    return true;
  }
  /**
   * Determines whether to clear embeddings based on the new data.
   * @param {Object} data - The new data to evaluate.
   * @returns {boolean} `true` if embeddings should be cleared, `false` otherwise.
   */
  should_clear_embeddings(data) {
    if (this.is_new) return true;
    if (this.embed_model && this.vec?.length !== this.embed_model.model_config.dims) return true;
    return false;
  }
  /**
   * Prepares the embed input for the SmartBlock by reading content and generating a hash.
   * @async
   * @returns {Promise<string|false>} The embed input string or `false` if already embedded.
   */
  async get_embed_input(content = null) {
    if (typeof this._embed_input !== "string" || !this._embed_input.length) {
      if (!content) content = await this.read();
      this._embed_input = this.breadcrumbs + "\n" + content;
    }
    return this._embed_input;
  }
  // CRUD
  /**
   * @method read
   * @description Reads the block content by delegating to the block adapter.
   * @async
   * @returns {Promise<string>} The block content.
   */
  async read() {
    try {
      return await this.block_adapter.read();
    } catch (e) {
      if (e.message.includes("BLOCK NOT FOUND")) {
        return 'BLOCK NOT FOUND (run "Prune" to remove)';
      } else {
        throw e;
      }
    }
  }
  /**
   * @method append
   * @description Appends content to this block by delegating to the block adapter.
   * @async
   * @param {string} content
   * @returns {Promise<void>}
   */
  async append(content) {
    await this.block_adapter.append(content);
    this.queue_save();
  }
  /**
   * @method update
   * @description Updates the block content by delegating to the block adapter.
   * @async
   * @param {string} new_block_content
   * @param {Object} [opts={}]
   * @returns {Promise<void>}
   */
  async update(new_block_content, opts = {}) {
    await this.block_adapter.update(new_block_content, opts);
    this.queue_save();
  }
  /**
   * @method remove
   * @description Removes the block by delegating to the block adapter.
   * @async
   * @returns {Promise<void>}
   */
  async remove() {
    await this.block_adapter.remove();
    this.queue_save();
  }
  /**
   * @method move_to
   * @description Moves the block to another location by delegating to the block adapter.
   * @async
   * @param {string} to_key
   * @returns {Promise<void>}
   */
  async move_to(to_key) {
    await this.block_adapter.move_to(to_key);
    this.queue_save();
  }
  // Getters
  /**
   * Retrieves the breadcrumbs representing the block's path within the source.
   * @readonly
   * @returns {string} The breadcrumbs string.
   */
  get breadcrumbs() {
    return this.key.split("/").join(" > ").split("#").slice(0, -1).join(" > ").replace(".md", "");
  }
  /**
   * Determines if the block is excluded from embedding based on headings.
   * @readonly
   * @returns {boolean} `true` if excluded, `false` otherwise.
   */
  get excluded() {
    const block_headings = this.path.split("#").slice(1);
    if (this.source_collection.excluded_headings.some((heading) => block_headings.includes(heading))) return true;
    return this.source?.excluded;
  }
  /**
   * Retrieves the file path of the SmartSource associated with the block.
   * @readonly
   * @returns {string} The file path.
   */
  get file_path() {
    return this.source?.file_path;
  }
  /**
   * Retrieves the file type of the SmartSource associated with the block.
   * @readonly
   * @returns {string} The file type.
   */
  get file_type() {
    return this.source.file_type;
  }
  /**
   * Retrieves the folder path of the block.
   * @readonly
   * @returns {string} The folder path.
   */
  get folder() {
    return this.path.split("/").slice(0, -1).join("/");
  }
  /**
   * Retrieves the embed link for the block.
   * @readonly
   * @returns {string} The embed link.
   */
  get embed_link() {
    return `![[${this.link}]]`;
  }
  /**
   * Determines if the block has valid line range information.
   * @readonly
   * @returns {boolean} `true` if the block has both start and end lines, `false` otherwise.
   */
  get has_lines() {
    return this.lines && this.lines.length === 2;
  }
  /**
   * Determines if the entity is a block based on its key.
   * @readonly
   * @returns {boolean} `true` if it's a block, `false` otherwise.
   */
  get is_block() {
    return this.key.includes("#");
  }
  /**
   * Determines if the block is gone (i.e., the source file or block data no longer exists).
   * @readonly
   * @returns {boolean} `true` if gone, `false` otherwise.
   */
  get is_gone() {
    if (!this.source?.file) return true;
    if (!this.source?.data?.blocks?.[this.sub_key]) return true;
    return false;
  }
  get last_read() {
    return this.data.last_read;
  }
  /**
   * Retrieves the sub-key of the block.
   * @readonly
   * @returns {string} The sub-key.
   */
  get sub_key() {
    return "#" + this.key.split("#").slice(1).join("#");
  }
  /**
   * Retrieves the lines range of the block.
   * @readonly
   * @returns {Array<number>|undefined} An array containing the start and end lines or `undefined` if not set.
   */
  // get lines() { return this.source?.data?.blocks?.[this.sub_key]; }
  get lines() {
    return this.data.lines;
  }
  /**
   * Retrieves the starting line number of the block.
   * @readonly
   * @returns {number|undefined} The starting line number or `undefined` if not set.
   */
  get line_start() {
    return this.lines?.[0];
  }
  /**
   * Retrieves the ending line number of the block.
   * @readonly
   * @returns {number|undefined} The ending line number or `undefined` if not set.
   */
  get line_end() {
    return this.lines?.[1];
  }
  /**
   * Retrieves the link associated with the block, handling page numbers if present.
   * @readonly
   * @returns {string} The block link.
   */
  get link() {
    if (/^.*page\s*(\d+).*$/i.test(this.sub_key)) {
      const number = this.sub_key.match(/^.*page\s*(\d+).*$/i)[1];
      return `${this.source.path}#page=${number}`;
    } else {
      return this.source?.path || "MISSING SOURCE";
    }
  }
  /**
   * Retrieves the display name of the block.
   * @readonly
   * @returns {string} The display name.
   */
  get name() {
    const source_name = this.source?.name;
    if (!source_name) return "MISSING SOURCE";
    const block_path_parts = this.key.split("#").slice(1);
    if (this.should_show_full_path) return [source_name, ...block_path_parts].join(" > ");
    if (block_path_parts[block_path_parts.length - 1][0] === "{") block_path_parts.pop();
    return [source_name, block_path_parts.pop()].join(" > ");
  }
  // uses data.lines to get next block
  get next_block() {
    if (!this.data.lines) return null;
    const next_line = this.data.lines[1] + 1;
    return this.source.blocks?.find((block) => next_line === block.data?.lines?.[0]);
  }
  /**
   * Retrieves the paths of outlinks from the block.
   * @readonly
   * @returns {Array<string>} An array of outlink paths.
   */
  get outlinks() {
    return this.source.outlinks;
  }
  /**
   * Retrieves the path of the SmartBlock.
   * @readonly
   * @returns {string} The path of the SmartBlock.
   */
  get path() {
    return this.key;
  }
  /**
   * Determines if the block should be embedded based on its coverage and size.
   * @readonly
   * @returns {boolean} `true` if it should be embedded, `false` otherwise.
   */
  get should_embed() {
    try {
      if (this.settings?.min_chars && this.size < this.settings.min_chars) return false;
      const match_line_start = this.line_start + 1;
      const match_line_end = this.line_end;
      const { has_line_start, has_line_end } = Object.entries(this.source?.data?.blocks || {}).reduce((acc, [key, range]) => {
        if (!key.startsWith(this.sub_key + "#")) return acc;
        if (range[0] === match_line_start) acc.has_line_start = key;
        if (range[1] === match_line_end) acc.has_line_end = key;
        return acc;
      }, { has_line_start: null, has_line_end: null });
      if (has_line_start && has_line_end) {
        const start_block = this.collection.get(this.source_key + has_line_start);
        if (start_block?.should_embed) {
          const end_block = this.collection.get(this.source_key + has_line_end);
          if (end_block?.should_embed) return false;
        }
      }
      return true;
    } catch (e) {
      console.error(e, e.stack);
      console.error(`Error getting should_embed for ${this.key}: ` + JSON.stringify(e || {}, null, 2));
    }
  }
  /**
   * Retrieves the size of the SmartBlock.
   * @readonly
   * @returns {number} The size of the SmartBlock.
   */
  get size() {
    return this.data.size;
  }
  /**
   * Retrieves the SmartSource associated with the block.
   * @readonly
   * @returns {SmartSource} The associated SmartSource instance.
   */
  get source() {
    return this.source_collection.get(this.source_key);
  }
  /**
   * Retrieves the SmartSources collection instance.
   * @readonly
   * @returns {SmartSources} The SmartSources collection.
   */
  get source_collection() {
    return this.env.smart_sources;
  }
  get source_key() {
    return this.key.split("#")[0];
  }
  get sub_blocks() {
    return this.source?.blocks?.filter((block) => block.key.startsWith(this.key + "#") && block.line_start > this.line_start && block.line_end <= this.line_end) || [];
  }
  // source dependent
  get excluded_lines() {
    return this.source.excluded_lines;
  }
  get file() {
    return this.source.file;
  }
  get is_media() {
    return this.source.is_media;
  }
  get mtime() {
    return this.source.mtime;
  }
  // DEPRECATED
  /**
   * @deprecated Use `source` instead.
   * @readonly
   * @returns {SmartSource} The associated SmartSource instance.
   */
  get note() {
    return this.source;
  }
  /**
   * @deprecated Use `source.key` instead.
   * @readonly
   * @returns {string} The source key.
   */
  get note_key() {
    return this.key.split("#")[0];
  }
};
var smart_block_default2 = {
  class: SmartBlock2,
  actions: {
    find_connections: find_connections3
  }
};

// node_modules/smart-blocks/smart_blocks.js
var SmartBlocks2 = class extends SmartEntities2 {
  /**
   * Initializes the SmartBlocks instance. Currently muted as processing is handled by SmartSources.
   * @returns {void}
   */
  init() {
  }
  get fs() {
    return this.env.smart_sources.fs;
  }
  /**
   * Retrieves the embedding model associated with the SmartSources collection.
   * @readonly
   * @returns {Object|undefined} The embedding model instance or `undefined` if not set.
   */
  get embed_model() {
    return this.source_collection?.embed_model;
  }
  /**
   * Retrieves the embedding model key from the SmartSources collection.
   * @readonly
   * @returns {string|undefined} The embedding model key or `undefined` if not set.
   */
  get embed_model_key() {
    return this.source_collection?.embed_model_key;
  }
  /**
   * Calculates the expected number of blocks based on the SmartSources collection.
   * @readonly
   * @returns {number} The expected count of blocks.
   */
  get expected_blocks_ct() {
    return Object.values(this.source_collection.items).reduce((acc, item) => acc += Object.keys(item.data.blocks || {}).length, 0);
  }
  /**
   * Retrieves the notices system from the environment.
   * @readonly
   * @returns {Object} The notices object.
   */
  get notices() {
    return this.env.smart_connections_plugin?.notices || this.env.main?.notices;
  }
  /**
   * Retrieves the settings configuration for SmartBlocks.
   * @readonly
   * @returns {Object} The settings configuration object.
   */
  get settings_config() {
    return this.process_settings_config({
      "embed_blocks": {
        name: "Utilize Smart Blocks",
        type: "toggle",
        description: "Creates more granular embeddings by splitting sources into smaller chunks. This may improve search results especially for large documents that have well-defined sections.",
        default: true
      },
      ...super.settings_config
    });
  }
  render_settings(container, opts = {}) {
    return this.render_collection_settings(container, opts);
  }
  get data_dir() {
    return "multi";
  }
  /**
   * Retrieves the SmartSources collection instance.
   * @readonly
   * @returns {SmartSources} The SmartSources collection.
   */
  get source_collection() {
    return this.env.smart_sources;
  }
  /**
   * Processes the embed queue. Currently handled by SmartSources, so this method is muted.
   * @async
   * @returns {Promise<void>}
   */
  async process_embed_queue() {
  }
  /**
   * Processes the load queue. Currently muted as processing is handled by SmartSources.
   * @async
   * @returns {Promise<void>}
   */
  async process_load_queue() {
  }
  // TEMP: Methods in sources not implemented in blocks
  /**
   * @async
   * @throws {Error} Throws an error indicating the method is not implemented.
   * @returns {Promise<void>}
   */
  async prune() {
    throw "Not implemented: prune";
  }
  /**
   * @throws {Error} Throws an error indicating the method is not implemented.
   * @returns {void}
   */
  build_links_map() {
    throw "Not implemented: build_links_map";
  }
  /**
   * @async
   * @throws {Error} Throws an error indicating the method is not implemented.
   * @returns {Promise<void>}
   */
  async refresh() {
    throw "Not implemented: refresh";
  }
  /**
   * @async
   * @throws {Error} Throws an error indicating the method is not implemented.
   * @returns {Promise<void>}
   */
  async search() {
    throw "Not implemented: search";
  }
  /**
   * @async
   * @throws {Error} Throws an error indicating the method is not implemented.
   * @returns {Promise<void>}
   */
  async run_refresh() {
    throw "Not implemented: run_refresh";
  }
  /**
   * @async
   * @throws {Error} Throws an error indicating the method is not implemented.
   * @returns {Promise<void>}
   */
  async run_force_refresh() {
    throw "Not implemented: run_force_refresh";
  }
};

// smart-chat-v0/smart_messages.js
var SmartMessages = class extends SmartBlocks2 {
  /**
   * Override for processing load queue
   * @override
   */
  process_load_queue() {
  }
  /**
   * Override for processing import queue
   * @override
   */
  process_source_import_queue() {
  }
  /**
   * @property {string} data_folder - Path to message storage
   * @readonly
   */
  get data_folder() {
    return this.env.opts.env_path + (this.env.opts.env_path ? "/" : "") + "multi/chats";
  }
  /**
   * Override for initialization
   * @override
   */
  init() {
  }
  // disable embed_model for SmartMessages
  get embed_model() {
    return null;
  }
  async process_embed_queue() {
    console.log("skipping embed queue processing for SmartMessages");
  }
};

// smart-chat-v0/components/message.js
function build_html17(message, opts = {}) {
  const content = Array.isArray(message.content) ? message.content.map((part) => {
    if (part.type === "image_url") {
      return " ![[" + part.input.image_path + "]] ";
    }
    if (part.type === "text" && part.input?.key?.length) return " ![[" + part.input.key + "]] ";
    if (part.type === "text" && part.text?.length) return part.text;
  }).join("\n") : message.content;
  const branches = message.thread.get_branches(message.msg_i);
  const has_branches = branches && branches.length > 0;
  let html = `
    <div class="sc-message ${message.role}" id="${message.data.id}">
      <div class="sc-message-content" data-content="${encodeURIComponent(content)}">
        <span>${content}</span>
        <div class="sc-msg-buttons">
          <span class="sc-msg-button" title="Copy message to clipboard">${this.get_icon_html("copy")}</span>
          ${has_branches ? `
            <span class="sc-msg-button cycle-branch" title="Cycle through message variations">${message.branch_i.split("-").pop()} / ${branches.length + 1} ${this.get_icon_html("chevron-right")}</span>
          ` : ""}
          ${message.role === "assistant" ? `
            <span class="sc-msg-button regenerate" title="Regenerate response">${this.get_icon_html("refresh-cw")}</span>
          ` : `
            <span class="sc-msg-button edit" title="Edit message">${this.get_icon_html("edit")}</span>
          `}
        </div>
      </div>
      ${message.role === "user" ? `<textarea class="sc-message-edit" style="display: none;">${content}</textarea>` : ""}
    </div>
  `;
  if (message.role === "user" && message.context?.has_self_ref === true) {
    html += `
      <div class="sc-tool-call-missing-indicator" style="font-style: italic; margin-top: 4px;">
        expecting lookup
      </div>
    `;
  }
  return html;
}
async function render23(message, opts = {}) {
  const html = build_html17.call(this, message, opts);
  const frag = this.create_doc_fragment(html);
  return await post_process20.call(this, message, frag, opts);
}
async function post_process20(message, frag, opts) {
  const copy_button = frag.querySelector(".sc-msg-button:not(.regenerate)");
  if (copy_button) {
    copy_button.addEventListener("click", () => {
      navigator.clipboard.writeText(message.content).then(() => {
        console.log("Message copied to clipboard");
      }).catch((err) => {
        console.error("Failed to copy message: ", err);
      });
    });
  }
  const regenerate_button = frag.querySelector(".sc-msg-button.regenerate");
  if (regenerate_button) {
    regenerate_button.addEventListener("click", async () => {
      const thread = message.thread;
      const msg_i = thread.data.messages[message.data.id];
      if (!thread.data.branches) thread.data.branches = {};
      if (!thread.data.branches[msg_i]) thread.data.branches[msg_i] = [];
      const branch_messages = {};
      Object.entries(thread.data.messages).filter(([_, i]) => i >= msg_i).forEach(([key, i]) => {
        branch_messages[key] = i;
        delete thread.data.messages[key];
      });
      thread.data.branches[msg_i].push(branch_messages);
      await thread.render();
      await thread.complete();
    });
  }
  const cycle_branch_button = frag.querySelector(".sc-msg-button.cycle-branch");
  if (cycle_branch_button) {
    cycle_branch_button.addEventListener("click", async () => {
      await message.thread.cycle_branch(message.msg_i);
    });
  }
  const edit_button = frag.querySelector(".sc-msg-button.edit");
  if (edit_button) {
    const msg_content = frag.querySelector(".sc-message-content");
    const edit_textarea = frag.querySelector(".sc-message-edit");
    edit_button.addEventListener("click", async () => {
      const is_editing = edit_textarea.style.display === "block";
      if (is_editing) {
        const new_content = edit_textarea.value.trim();
        if (new_content !== message.content) {
          const thread = message.thread;
          const msg_i = thread.data.messages[message.data.id];
          const current_messages = Object.entries(thread.data.messages).filter(([_, i]) => i >= msg_i).reduce((acc, [id, i]) => ({ ...acc, [id]: i }), {});
          thread.move_to_branch(msg_i, current_messages);
          msg_content.querySelector("span").textContent = new_content;
          msg_content.setAttribute("data-content", encodeURIComponent(new_content));
          edit_textarea.style.display = "none";
          msg_content.style.display = "block";
          this.safe_inner_html(edit_button, this.get_icon_html("edit"));
          edit_button.title = "Edit message";
          await thread.handle_message_from_user(new_content);
          await thread.render();
        } else {
          edit_textarea.style.display = "none";
          msg_content.style.display = "block";
          this.safe_inner_html(edit_button, this.get_icon_html("edit"));
          edit_button.title = "Edit message";
        }
      } else {
        edit_textarea.style.display = "block";
        this.safe_inner_html(edit_button, this.get_icon_html("check"));
        edit_button.title = "Save changes";
        edit_textarea.focus();
      }
    });
    edit_textarea.addEventListener("keydown", async (e) => {
      if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        edit_button.click();
      }
    });
  }
  const msg_span = frag.querySelector(".sc-message-content > span:first-child");
  const markdown_rendered_frag = await this.render_markdown(msg_span.textContent, message);
  this.empty(msg_span);
  msg_span.appendChild(markdown_rendered_frag);
  return frag;
}

// smart-chat-v0/components/context.js
function build_html18(message, opts = {}) {
  const lookup_results = message.tool_call_output || [];
  if (lookup_results.length === 0) {
    return "";
  }
  const review_context = message.settings?.review_context === true;
  return `
    <div class="sc-context-container" id="${message.data.id}">
      <div class="sc-context-header" tabindex="0" role="button" aria-expanded="false" aria-controls="context-list-${message.data.id}">
        <span>${this.get_icon_html("info")} Context (${lookup_results.length})</span>
        <span class="sc-context-toggle-icon">${this.get_icon_html("chevron-down")}</span>
      </div>
      <ul class="sc-context-list" id="context-list-${message.data.id}" hidden>
        ${lookup_results.map((result, index) => `
          <li class="sc-context-item" data-index="${index}">
            ${review_context ? `<button class="sc-context-remove-btn" title="Remove">${this.get_icon_html("x")}</button>` : ""}
            <span class="sc-context-item-path">${result.key}</span>
            <span class="sc-context-item-score">Score: ${result.score.toFixed(2)}</span>
          </li>
        `).join("")}
        ${review_context ? `
          <li class="sc-context-submit">
            <button class="sc-context-submit-btn">Submit</button>
          </li>
        ` : ""}
      </ul>
    </div>
  `;
}
async function render24(message, opts = {}) {
  const html = build_html18.call(this, message, opts);
  if (!html) return document.createDocumentFragment();
  const frag = this.create_doc_fragment(html);
  return await post_process21.call(this, message, frag, opts);
}
async function post_process21(message, frag, opts) {
  const header = frag.querySelector(".sc-context-header");
  const list = frag.querySelector(".sc-context-list");
  const toggle_icon = frag.querySelector(".sc-context-toggle-icon");
  const review_context = message.settings?.review_context === true;
  if (header && list && toggle_icon) {
    if (review_context) header.setAttribute("aria-expanded", "true");
    else header.setAttribute("aria-expanded", "false");
    header.addEventListener("click", () => {
      const is_expanded = header.getAttribute("aria-expanded") === "true";
      if (is_expanded) {
        header.setAttribute("aria-expanded", "false");
      } else {
        header.setAttribute("aria-expanded", "true");
      }
    });
  }
  if (review_context) {
    const remove_buttons = frag.querySelectorAll(".sc-context-remove-btn");
    remove_buttons.forEach((btn) => {
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        const item = btn.closest(".sc-context-item");
        const index = parseInt(item.getAttribute("data-index"), 10);
        message.tool_call_output.splice(index, 1);
        message.render();
      });
    });
    const submit_button = frag.querySelector(".sc-context-submit-btn");
    if (submit_button) {
      submit_button.addEventListener("click", async (e) => {
        e.stopPropagation();
        const container = e.target.closest(".sc-context-container");
        container.querySelectorAll(".sc-context-remove-btn").forEach((btn) => btn.remove());
        const submit_container = submit_button.closest(".sc-context-submit");
        if (submit_container) {
          submit_container.remove();
        }
        header.setAttribute("aria-expanded", "false");
        await message.thread.complete();
      });
    }
  }
  return frag;
}

// smart-chat-v0/components/tool_calls.js
function build_html19(message, opts = {}) {
  const tool_calls = message.tool_calls || [];
  if (tool_calls.length === 0) {
    return "";
  }
  return `
    <div class="sc-tool-calls-container" id="${message.data.id}">
      ${tool_calls.map((tool_call, index) => `
        <div class="sc-tool-call">
          <div class="sc-tool-call-header" tabindex="0" role="button" aria-expanded="false" aria-controls="${message.data.id}-content">
            <span>${tool_call.function.name}</span>
            <span class="sc-tool-call-toggle-icon">${this.get_icon_html("chevron-down")}</span>
          </div>
          <div class="sc-tool-call-content" id="${message.data.id}-content" hidden>
            <pre><code class="language-json">${JSON.stringify(typeof tool_call.function.arguments === "string" ? JSON.parse(tool_call.function.arguments) : tool_call.function.arguments, null, 2)}</code></pre>
          </div>
        </div>
      `).join("")}
    </div>
  `;
}
async function render25(message, opts = {}) {
  const html = build_html19.call(this, message, opts);
  if (!html) return document.createDocumentFragment();
  const frag = this.create_doc_fragment(html);
  return await post_process22.call(this, message, frag, opts);
}
async function post_process22(message, frag, opts) {
  const tool_call_headers = frag.querySelectorAll(".sc-tool-call-header");
  tool_call_headers.forEach((header) => {
    const content = header.nextElementSibling;
    const toggle_icon = header.querySelector(".sc-tool-call-toggle-icon");
    header.addEventListener("click", () => {
      const is_expanded = header.getAttribute("aria-expanded") === "true";
      if (is_expanded) {
        header.setAttribute("aria-expanded", "false");
        content.hidden = true;
      } else {
        header.setAttribute("aria-expanded", "true");
        content.hidden = false;
      }
    });
    header.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        header.click();
      }
    });
  });
  return frag;
}

// smart-chat-v0/components/system_message.js
function build_html20(message, opts = {}) {
  return `
    <div class="sc-system-message-container" id="${message.data.id}">
      <div class="sc-system-message-header" tabindex="0" role="button" aria-expanded="false" aria-controls="${message.data.id}-content">
        <span>${this.get_icon_html("settings")} System Message</span>
        <span class="sc-system-message-toggle-icon">${this.get_icon_html("chevron-down")}</span>
      </div>
      <div class="sc-system-message-content" id="${message.data.id}-content" hidden>
        <div class="sc-system-message-text">
          <pre>${message.content.map((part) => part.text || part.input?.key).join("\n")}</pre>
        </div>
        <button class="sc-system-message-copy" title="Copy system message">
          ${this.get_icon_html("copy")}
        </button>
      </div>
    </div>
  `;
}
async function render26(message, opts = {}) {
  const html = build_html20.call(this, message, opts);
  const frag = this.create_doc_fragment(html);
  return await post_process23.call(this, message, frag, opts);
}
async function post_process23(message, frag, opts) {
  const header = frag.querySelector(".sc-system-message-header");
  const content = frag.querySelector(".sc-system-message-content");
  const toggle_icon = frag.querySelector(".sc-system-message-toggle-icon");
  const copy_button = frag.querySelector(".sc-system-message-copy");
  const text_container = frag.querySelector(".sc-system-message-text");
  if (header && content && toggle_icon) {
    header.addEventListener("click", () => {
      const is_expanded = header.getAttribute("aria-expanded") === "true";
      header.setAttribute("aria-expanded", !is_expanded);
      content.hidden = is_expanded;
      toggle_icon.style.transform = is_expanded ? "" : "rotate(180deg)";
    });
  }
  if (copy_button && text_container) {
    copy_button.addEventListener("click", () => {
      navigator.clipboard.writeText(text_container.textContent).then(() => {
        copy_button.classList.add("sc-copied");
        setTimeout(() => {
          copy_button.classList.remove("sc-copied");
        }, 1e3);
      }).catch((err) => {
        console.error("Failed to copy system message:", err);
      });
    });
  }
  if (text_container && typeof message.content === "string") {
    const markdown_rendered_frag = await this.render_markdown(message.content, message);
    this.empty(text_container);
    text_container.appendChild(markdown_rendered_frag);
  }
  return frag;
}

// smart-chat-v0/smart_message.js
var SmartMessage = class extends SmartBlock2 {
  /**
   * @static
   * @property {Object} defaults - Default data object for a new message
   * @returns {Object}
   */
  static get defaults() {
    return {
      data: {
        thread_key: null,
        content: null,
        role: null,
        tool_calls: null,
        tool_call_id: null,
        msg_i: null,
        id: null,
        context: {},
        tool_call_output: null
      }
    };
  }
  /**
   * Returns a unique message key based on the thread key and message ID.
   * @returns {string} Unique message identifier.
   */
  get_key() {
    return `${this.data.thread_key}#${this.id}`;
  }
  get msg_i() {
    if (!this.data.msg_i) {
      const msg_i = Object.keys(this.thread.data.messages || {}).length + 1;
      this.data.msg_i = msg_i;
    }
    return this.data.msg_i;
  }
  get branch_i() {
    if (!this.data.branch_i) {
      const branch_i = Date.now() + "-" + ((this.thread.data.branches?.[this.msg_i] || []).length + 1);
      this.data.branch_i = branch_i;
    }
    return this.data.branch_i;
  }
  get id() {
    if (!this.data.id) {
      this.data.id = `${this.role}-${this.msg_i}-${this.branch_i}`;
    }
    return this.data.id;
  }
  /**
   * Initializes the message. If the message is from the user, triggers thread completion.
   * If the message represents a tool output and no review is needed, triggers thread completion.
   *
   * @async
   */
  async init() {
    while (!this.thread) await new Promise((resolve) => setTimeout(resolve, 100));
    if (!this.thread.data.messages[this.id]) {
      this.thread.data.messages[this.id] = this.msg_i;
      await new Promise((resolve) => setTimeout(resolve, 30));
    }
    await this.render();
    if (this.role === "user") {
      await this.thread.complete();
    } else if (this.role === "tool" && !this.settings.review_context) {
      this.thread.complete();
    }
    this.queue_save();
  }
  /**
   * Queues the message for saving via the thread.
   */
  queue_save() {
    this._queue_save = true;
    this.thread?.queue_save();
  }
  /**
   * Renders the message interface in the thread UI.
   * Chooses different templates based on message role and presence of tool calls.
   *
   * @async
   * @param {HTMLElement} [container=this.thread.messages_container] - The container element.
   * @returns {Promise<DocumentFragment>} Rendered message fragment.
   */
  async render(container = this.thread.messages_container) {
    let frag;
    if (this.role === "system") {
      frag = await render26.call(this.smart_view, this);
    } else if (this.tool_calls?.length > 0) {
      frag = await render25.call(this.smart_view, this);
    } else if (this.role === "tool") {
      frag = await this.context_template.call(this.smart_view, this);
    } else {
      frag = await render23.call(this.smart_view, this);
    }
    if (container) {
      this.elm = container.querySelector(`#${this.data.id}`);
      if (this.elm) {
        this.elm.replaceWith(frag);
      } else {
        container.appendChild(frag);
        await new Promise((resolve) => setTimeout(resolve, 30));
      }
    }
    return frag;
  }
  get context_template() {
    return this.env.opts.components.lookup_context || render24;
  }
  /**
   * Converts the message into a request payload that can be sent to the AI model.
   * This involves reading and embedding any referenced content (text or images),
   * and including tool calls or tool call outputs as necessary.
   *
   * @async
   * @returns {Promise<Object>} A request-ready message object.
   */
  async to_request() {
    const this_message = { role: this.role, content: [] };
    await this.#append_internal_link_context(this_message);
    await this.#append_message_content(this_message);
    if (this.tool_calls?.length) {
      this_message.tool_calls = this.tool_calls;
      delete this_message.content;
    }
    if (this.tool_call_id) {
      this_message.tool_call_id = this.tool_call_id;
    }
    if (this.tool_call_output?.length) {
      const output_content = await this.tool_call_output_to_request();
      this_message.content = [{ type: "text", text: output_content }];
    }
    return this_message;
  }
  /**
   * Returns the tool call output as a request-ready string.
   * For the 'lookup' tool, it either returns JSON or formatted text depending on settings.
   *
   * @async
   * @returns {Promise<string>} The tool call output content as a string.
   */
  async tool_call_output_to_request() {
    if (this.tool_name === "lookup") {
      if (this.settings.tool_call_output_as_json) {
        const lookup_collection = this.tool_call_output[0]?.key.includes("#") ? this.env.smart_blocks : this.env.smart_sources;
        const detailed_results = await Promise.all(this.tool_call_output.map(async (result) => ({
          ...result,
          content: await lookup_collection.get(result.key).read()
        })));
        return JSON.stringify(detailed_results);
      }
      const prefix_prompt = get_translated_context_prefix_prompt(this.thread.language);
      let lookup_output = `${prefix_prompt}
`;
      const lookup_content = await this.fetch_content(this.tool_call_output.map((r) => r.key));
      this.tool_call_output.forEach((result, index) => {
        if (lookup_content[index]?.type === "text") {
          lookup_output += `-----------------------
`;
          lookup_output += `/${result.key} (relevance score: ${result.score})
`;
          lookup_output += `---
${lookup_content[index].content}
`;
          lookup_output += `-----------------------

`;
        }
      });
      const suffix_prompt = get_translated_context_suffix_prompt(this.thread.language);
      return lookup_output + suffix_prompt;
    }
    return "";
  }
  /**
   * Fetches and processes content referenced by internal links.
   * Can return text or base64 image data depending on the file type.
   *
   * @async
   * @param {Array<string>} paths - Array of paths to fetch content from
   * @returns {Array<Object>} contents - Array of content objects:
   * @returns {string} contents[].type - Content type ('text' or 'image')
   * @returns {string} [contents[].content] - Text content if type is 'text'
   * @returns {string} [contents[].image_url] - Base64 image URL if type is 'image'
   * @throws {Error} When unable to fetch or process content
   */
  async fetch_content(paths) {
    try {
      const image_extensions = ["png", "jpg", "jpeg", "gif", "svg", "webp", "heic", "heif", "ico"];
      const contents = await Promise.all(paths.map(async (path) => {
        if (path) {
          try {
            const item = this.env.smart_blocks.get(path) || this.env.smart_sources.get(path);
            const file_extension = path.split(".").pop().toLowerCase();
            if (image_extensions.includes(file_extension)) {
              const image_data = await this.env.smart_sources.fs.read(path, "base64");
              const base64_image = `data:image/${file_extension};base64,${image_data}`;
              return { type: "image", image_url: base64_image };
            } else {
              return { type: "text", content: await item.read() };
            }
          } catch (e) {
            console.warn(`Error fetching content for ${path}:`, e);
            return { type: "error", content: "Failed to fetch content" };
          }
        }
      }));
      return contents;
    } catch (error) {
      console.error(`Error fetching internal links content:`, error);
      return [];
    }
  }
  /*** Private Helpers ***/
  /**
   * Appends context content for internal links to the request message.
   * @private
   * @async
   * @param {Object} this_message - The message object being prepared for request.
   */
  async #append_internal_link_context(this_message) {
    if (this.context.internal_links?.length > 0) {
      const internal_links_content = await this.fetch_content(this.context.internal_links);
      let context_text = "";
      this.context.internal_links.forEach((link, index) => {
        const content_item = internal_links_content[index];
        if (content_item.type === "text") {
          if (!context_text.length) context_text += `Context specified in message:
`;
          context_text += `-----------------------
`;
          context_text += `/${link}
---
${content_item.content}
`;
          context_text += `-----------------------
`;
        } else if (content_item.type === "image") {
          this_message.content.push({
            type: "image_url",
            image_url: { url: content_item.image_url }
          });
        } else if (content_item.type === "unsupported") {
          context_text += `Unsupported content in link: ${link}
`;
        } else if (content_item.type === "error") {
          context_text += `Error retrieving content for: ${link}
`;
        }
      });
      if (context_text.length > 0) {
        this_message.content.push({ type: "text", text: context_text });
      }
    }
  }
  /**
   * Appends the main message content (user or assistant text and images) to the request message.
   * @private
   * @async
   * @param {Object} this_message - The message object being prepared for request.
   */
  async #append_message_content(this_message) {
    if (typeof this.content === "string") {
      this_message.content.push({ type: "text", text: this.content });
    } else if (Array.isArray(this.content)) {
      for (const part of this.content) {
        if (part.type === "text") {
          let text = part.text || "";
          if (!text && part.input?.key) {
            text = await this.#safe_read_content(part.input.key);
          }
          this_message.content.push({ type: "text", text });
        } else if (part.type === "image_url") {
          const base64_img = await this.#safe_read_image(part.input.image_path);
          if (base64_img) {
            this_message.content.push({
              type: "image_url",
              image_url: { url: base64_img }
            });
          } else {
            this_message.content.push({
              type: "text",
              text: `Image not found: ${part.input.image_path}`
            });
          }
        }
      }
    }
  }
  /**
   * Safely reads text content from a given key. Returns an empty string if not found.
   * @private
   * @async
   * @param {string} key - The key to read content from.
   * @returns {Promise<string>} The content read, or an empty string if not found.
   */
  async #safe_read_content(key) {
    let text = await this.env.smart_sources.get(key)?.read() || "";
    if (!text) {
      text = await this.env.smart_sources.fs.read(key) || "";
    }
    return text;
  }
  /**
   * Safely reads and base64-encodes an image from a given path.
   * @private
   * @async
   * @param {string} image_path - The path to the image file.
   * @returns {Promise<string|null>} The base64 data URI if successful, else null.
   */
  async #safe_read_image(image_path) {
    try {
      const extension = image_path.split(".").pop();
      const base64_img = await this.env.smart_sources.fs.read(image_path, "base64");
      return `data:image/${extension};base64,${base64_img}`;
    } catch {
      return null;
    }
  }
  /**
   * @property {string} content - Message content
   */
  get content() {
    return this.data.content;
  }
  set content(value) {
    this.data.content = value;
  }
  /**
   * @property {string} role - Message sender role ('user' or 'assistant')
   */
  get role() {
    return this.data.role;
  }
  set role(value) {
    this.data.role = value;
  }
  /**
   * @property {Object} tool_calls - Tool calls
   */
  get tool_calls() {
    return this.data.tool_calls;
  }
  set tool_calls(value) {
    this.data.tool_calls = value;
  }
  /**
   * @property {string} tool_call_id - Tool call ID
   */
  get tool_call_id() {
    return this.data.tool_call_id;
  }
  set tool_call_id(value) {
    this.data.tool_call_id = value;
  }
  /**
   * @property {Array<Object>} tool_call_output - Tool call output
   */
  get tool_call_output() {
    return this.data.tool_call_output;
  }
  set tool_call_output(value) {
    this.data.tool_call_output = value;
  }
  /**
   * @property {string} tool_name - Tool name
   */
  get tool_name() {
    return this.data.tool_name;
  }
  set tool_name(value) {
    this.data.tool_name = value;
  }
  /**
   * @property {Object} context - Message context data
   */
  get context() {
    return this.data.context;
  }
  set context(value) {
    this.data.context = value;
  }
  /**
   * @property {SmartThread} thread - Parent thread reference
   * @readonly
   */
  get thread() {
    return this.source;
  }
  /**
   * @property {SmartMessage} next_message - Next message reference
   * @readonly
   */
  get next_message() {
    return this.thread.messages[this.msg_i];
  }
  /**
   * @property {SmartMessage} previous_message - Previous message reference
   * @readonly
   */
  get previous_message() {
    return this.thread.messages[this.msg_i - 2];
  }
  /**
   * @property {boolean} is_last_message - Whether the message is the last message in the thread
   * @readonly
   */
  get is_last_message() {
    return this.msg_i === Object.keys(this.thread.messages).length;
  }
  /**
   * @property {string} source_key - Key for source reference
   * @readonly
   */
  get source_key() {
    return this.data.thread_key;
  }
  /**
   * @property {SmartThreads} source_collection - Collection reference
   * @readonly
   */
  get source_collection() {
    return this.env.smart_threads;
  }
  /**
   * @property {string} path - Path identifier for the message
   * @readonly
   */
  get path() {
    return this.data.thread_key;
  }
  get settings() {
    return this.thread.settings;
  }
  get has_image() {
    return Array.isArray(this.content) && this.content.some((part) => part.type === "image_url");
  }
};

// smart-chat-v0/sc_thread.js
var SmartThread2 = class extends SmartThread {
  /**
   * Handles the execution of detected tool calls from a message.
   * Currently supports 'lookup' tool calls. Additional tools can be integrated similarly.
   *
   * @async
   * @param {Array<Object>} tool_calls - Array of tool call objects found in the message.
   * @param {Object} msg_data - Data of the message that triggered these tool calls.
   */
  async handle_tool_calls(tool_calls, msg_data) {
    for (const tool_call of tool_calls) {
      try {
        switch (tool_call.function.name) {
          case "lookup":
            await this.handle_lookup_tool_call(tool_call, msg_data);
            break;
          default:
            console.warn(`Unhandled tool call: ${tool_call.function.name}`);
            await this.render_error({ message: `No handler for tool: ${tool_call.function.name}` });
        }
      } catch (error) {
        console.error(`Error handling tool call ${tool_call.function.name}:`, error);
        await this.render_error({ message: `Failed to execute tool: ${tool_call.function.name}`, error });
      }
    }
  }
  /**
   * Handles a 'lookup' tool call by performing a semantic search and storing the results.
   * The results are then added as a tool message in the thread.
   *
   * @async
   * @param {Object} tool_call - The tool call object with function name and arguments.
   * @param {Object} msg_data - The message data that triggered the tool call.
   */
  async handle_lookup_tool_call(tool_call, msg_data) {
    const previous_message = this.messages[this.messages.length - 2];
    const params = this.#build_lookup_params(tool_call.function.arguments, previous_message);
    const lookup_collection = this.env.smart_blocks.settings.embed_blocks ? this.env.smart_blocks : this.env.smart_sources;
    const lookup_results = (await lookup_collection.lookup(params)).map((result) => ({
      key: result.item.key,
      score: result.score
    }));
    const msg_i = Object.keys(this.data.messages || {}).length + 1;
    const branch_i = (this.data.branches?.[msg_i] || []).length + 1;
    await this.env.smart_messages.create_or_update({
      thread_key: this.key,
      tool_call_id: tool_call.id,
      tool_name: tool_call.function.name,
      tool_call_output: lookup_results,
      role: "tool",
      response_id: tool_call.id,
      id: `tool-${msg_i}-${branch_i}`
    });
  }
  /**
   * Builds parameters for the 'lookup' tool call.
   * @private
   * @param {Object|string} args - Tool call arguments, possibly JSON stringified.
   * @param {Object} previous_message - The previous message in the thread (if any).
   * @returns {Object} Formatted lookup parameters.
   */
  #build_lookup_params(args, previous_message) {
    args = typeof args === "string" ? JSON.parse(args) : args;
    const params = {};
    params.hypotheticals = this.#normalize_hypotheticals(args, previous_message);
    params.filter = this.#build_lookup_filter(previous_message);
    return params;
  }
  /**
   * Normalizes 'hypotheticals' argument into an array of strings.
   * @private
   * @param {Object} args - Tool call arguments.
   * @param {Object} previous_message - The previous message in the thread (if any).
   * @returns {Array<string>} Normalized hypotheticals.
   */
  #normalize_hypotheticals(args, previous_message) {
    let hypotheticals;
    if (Array.isArray(args.hypotheticals)) {
      hypotheticals = args.hypotheticals;
    } else if (typeof args.hypotheticals === "object" && args.hypotheticals !== null) {
      hypotheticals = Object.values(args.hypotheticals);
    } else if (typeof args.hypotheticals === "string") {
      hypotheticals = [args.hypotheticals];
    } else {
      console.warn("Invalid hypotheticals. Using fallback content.");
      const fallback_content = previous_message?.content || "No context";
      hypotheticals = [fallback_content];
    }
    return hypotheticals.map((h) => typeof h === "string" ? h : JSON.stringify(h));
  }
  /**
   * Builds a filter object for the lookup tool call based on the previous message context.
   * Uses 'key_starts_with' if there is exactly one folder reference.
   * Uses 'key_starts_with_any' if multiple folder references exist.
   * @private
   * @param {Object} previous_message - The previous message in the thread (if any).
   * @returns {Object} The filter object for the lookup.
   */
  #build_lookup_filter(previous_message) {
    const filter = { limit: this.settings.lookup_limit || 10 };
    const folder_refs = previous_message?.context?.folder_refs;
    if (folder_refs && folder_refs.length > 0) {
      if (folder_refs.length === 1) {
        filter.key_starts_with = folder_refs[0];
      } else {
        filter.key_starts_with_any = folder_refs;
      }
    }
    return filter;
  }
};

// smart-chat-v0/adapters/_adapter.js
var ThreadSourceAdapter = class {
  /**
   * @constructor
   * @param {SmartThread} item - The SmartThread instance this adapter is attached to
   */
  constructor(item) {
    this.item = item;
  }
  /**
   * @property {Object} data - The underlying data of the SmartThread
   * @readonly
   */
  get data() {
    return this.item.data;
  }
  get fs() {
    return this.item.collection.fs;
  }
  get created_at() {
    return this.item.created_at;
  }
  get file_path() {
    return this.item.path;
  }
  /**
   * @property {Object} env - The environment configuration
   * @readonly
   */
  get env() {
    return this.item.env;
  }
  /**
   * Converts adapter file format to `item.source_data{}` format
   * @abstract
   * @throws {Error} Must be implemented by subclasses
   */
  to_source_data() {
    throw new Error("to_source_data() not implemented");
  }
  /**
   * Converts `item.source_data{}` format to adapter file format
   * @abstract
   * @throws {Error} Must be implemented by subclasses
   */
  from_source_data(source_data) {
    throw new Error("from_source_data() not implemented");
  }
  async import() {
    const source_data = await this.read();
    if (!source_data) return console.warn("no source data found for", this);
    this.from_source_data(source_data);
  }
  async read() {
    return await this.fs.read(this.file_path);
  }
  async save() {
    if (Object.keys(this.data.messages).length) {
      this.fs.write(this.file_path, this.to_source_data());
    }
  }
  async rename(new_name) {
    const old_key = this.item.key;
    const old_file_path = this.file_path;
    this.item.messages.forEach((msg) => {
      msg.data.key = msg.key.replace(old_key, new_name);
      msg.data.thread_key = new_name;
      this.item.env.smart_messages.items[msg.key] = msg;
    });
    this.data.path = null;
    this.data.key = new_name;
    this.item.collection.items[new_name] = this.item;
    delete this.item.collection.items[old_key];
    await this.save();
    await this.fs.remove(old_file_path);
    this.item.render();
  }
};

// smart-chat-v0/adapters/json.js
var EnvJsonThreadSourceAdapter = class extends ThreadSourceAdapter {
  static extensions = ["json"];
  static extension = "json";
  extension = "json";
  to_source_data() {
    const all_block_keys = [...Object.keys(this.data.messages)];
    if (Object.keys(this.data.branches).length) {
      const branches = Object.values(this.data.branches);
      const branch_block_keys = {};
      branches.forEach((branch) => {
        branch.forEach((branch_messages) => {
          Object.keys(branch_messages).forEach((key) => {
            branch_block_keys[key] = true;
          });
        });
      });
      all_block_keys.push(...Object.keys(branch_block_keys));
    }
    const blocks = all_block_keys.map((sub_key) => {
      const block_key = this.item.key + "#" + sub_key;
      const block = this.item.env.smart_messages.get(block_key);
      if (!block) {
        console.warn("block not found", block_key);
        return null;
      }
      return {
        ...block.data,
        key: block_key
      };
    }).filter((block) => block);
    return JSON.stringify({
      ...this.item.data,
      blocks
    }, null, 2);
  }
  from_source_data(source_data) {
    const parsed_data = JSON.parse(source_data);
    this.item.data = { ...parsed_data, blocks: void 0 };
    parsed_data.blocks.forEach((block) => {
      this.item.env.smart_messages.items[block.key] = new this.item.env.smart_messages.item_type(
        this.item.env,
        block
      );
    });
  }
};

// src/smart_env.config.js
var smart_env_config3 = {
  env_path: "",
  // env_data_dir: '.smart-env', // added in Plugin class
  collections: {
    smart_sources: {
      process_embed_queue: true
      // trigger embedding on load
    },
    smart_collections: {
      data_adapter: AjsonMultiFileCollectionDataAdapter2
    },
    smart_threads: {
      class: SmartThreads,
      data_adapter: AjsonMultiFileCollectionDataAdapter2,
      // data_adapter: CollectionDataAdapter,
      source_adapters: {
        "json": EnvJsonThreadSourceAdapter,
        "default": EnvJsonThreadSourceAdapter
      }
    },
    smart_messages: {
      class: SmartMessages
    }
  },
  item_types: {
    SmartThread: SmartThread2,
    SmartMessage
  },
  items: {
    smart_block: smart_block_default2,
    smart_source: smart_source_default2
  },
  modules: {
    smart_chat_model: {
      class: SmartChatModel2,
      // DEPRECATED FORMAT: will be changed (requires SmartModel adapters getters update)
      adapters: {
        anthropic: SmartChatModelAnthropicAdapter2,
        azure: SmartChatModelAzureAdapter2,
        // cohere: SmartChatModelCohereAdapter,
        custom: SmartChatModelCustomAdapter2,
        gemini: SmartChatModelGeminiAdapter2,
        groq: SmartChatModelGroqAdapter2,
        lm_studio: SmartChatModelLmStudioAdapter2,
        ollama: SmartChatModelOllamaAdapter2,
        open_router: SmartChatModelOpenRouterAdapter2,
        openai: SmartChatModelOpenaiAdapter2
      },
      http_adapter: new SmartHttpRequest2({
        adapter: SmartHttpObsidianRequestAdapter2,
        obsidian_request_url: import_obsidian26.requestUrl
      })
    },
    smart_fs: {
      class: SmartFs2,
      adapter: SmartFsObsidianAdapter2
    },
    smart_view: {
      class: SmartView2,
      adapter: SmartViewObsidianAdapter2
    }
  },
  components: {
    lookup: render16,
    connections_results: render17,
    smart_chat: render18,
    connections: render15,
    source_inspector: render10,
    smart_sources: {
      // settings: source_settings_component,
      connections: render15
    },
    smart_blocks: {
      connections: render15
    },
    smart_threads: {
      settings: render13,
      thread: render21
    },
    smart_chat_model: {
      settings: render14
    }
  },
  default_settings: {
    is_obsidian_vault: true,
    smart_blocks: {
      embed_blocks: true,
      min_chars: 200
    },
    smart_sources: {
      single_file_data_path: ".smart-env/smart_sources.json",
      min_chars: 200,
      embed_model: {
        adapter: "transformers",
        transformers: {
          legacy_transformers: false,
          model_key: "TaylorAI/bge-micro-v2"
        }
      }
    },
    file_exclusions: "Untitled",
    folder_exclusions: "",
    smart_view_filter: {
      render_markdown: true,
      show_full_path: false,
      exclude_blocks_from_source_connections: false
    }
  }
};

// src/components/connections_result.js
var import_obsidian28 = require("obsidian");

// node_modules/obsidian-smart-env/utils/register_block_hover_popover.js
var import_obsidian27 = require("obsidian");
function register_block_hover_popover(parent, target, env, block_key, plugin) {
  target.addEventListener("mouseover", async (ev) => {
    if (import_obsidian27.Keymap.isModEvent(ev)) {
      const block = env.smart_blocks.get(block_key);
      const markdown = await block?.read();
      if (markdown) {
        const popover = new import_obsidian27.HoverPopover(parent, target);
        const frag = env.smart_view.create_doc_fragment(`<div class="markdown-embed is-loaded">
                <div class="markdown-embed-content node-insert-event">
                  <div class="markdown-preview-view markdown-rendered node-insert-event show-indentation-guide allow-fold-headings allow-fold-lists">
                    <div class="markdown-preview-sizer markdown-preview-section">
                    </div>
                  </div>
                </div>
              </div>`);
        popover.hoverEl.classList.add("smart-block-popover");
        popover.hoverEl.appendChild(frag);
        const sizer = popover.hoverEl.querySelector(".markdown-preview-sizer");
        import_obsidian27.MarkdownRenderer.render(plugin.app, markdown, sizer, "/", popover);
      }
    }
  });
}

// src/components/connections_result.js
async function build_html21(result, opts = {}) {
  const item = result.item;
  const score = result.score;
  return `<div class="temp-container">
    <div
      class="sc-result sc-collapsed"
      data-path="${item.path.replace(/"/g, "&quot;")}"
      data-link="${item.link?.replace(/"/g, "&quot;") || ""}"
      data-collection="${item.collection_key}"
      data-score="${score}"
      data-key="${item.key}"
      draggable="true"
    >
      <span class="header">
        ${this.get_icon_html("right-triangle")}
        <a class="sc-result-file-title" href="#" title="${item.path.replace(/"/g, "&quot;")}" draggable="true">
          <small>${[score?.toFixed(2), item.name].join(" | ")}</small>
        </a>
      </span>
      <ul draggable="true">
        <li class="sc-result-file-title" title="${item.path.replace(/"/g, "&quot;")}" data-collection="${item.collection_key}" data-key="${item.key}"></li>
      </ul>
    </div>
  </div>`;
}
async function render27(result_scope, opts = {}) {
  let html = await build_html21.call(this, result_scope, opts);
  const frag = this.create_doc_fragment(html);
  return await post_process24.call(this, result_scope, frag, opts);
}
async function post_process24(result_scope, frag, opts = {}) {
  const { item } = result_scope;
  const env = item.env;
  const plugin = env.smart_connections_plugin;
  const app2 = plugin.app;
  const filter_settings = env.settings.smart_view_filter;
  const result_elm = frag.querySelector(".sc-result");
  if (!filter_settings.render_markdown) result_elm.classList.add("sc-result-plaintext");
  const render_result = async (_result_elm) => {
    if (!_result_elm.querySelector("li").innerHTML) {
      const collection_key = _result_elm.dataset.collection;
      const entity = env[collection_key].get(_result_elm.dataset.path);
      let markdown;
      if (should_render_embed3(entity)) markdown = `${entity.embed_link}

${await entity.read()}`;
      else markdown = process_for_rendering3(await entity.read());
      let entity_frag;
      if (filter_settings.render_markdown) entity_frag = await this.render_markdown(markdown, entity);
      else entity_frag = this.create_doc_fragment(markdown);
      result_elm.querySelector("li").appendChild(entity_frag);
    }
  };
  const toggle_result = (_result_elm) => {
    _result_elm.classList.toggle("sc-collapsed");
  };
  const handle_result_click = (event) => {
    event.preventDefault();
    event.stopPropagation();
    const target = event.target;
    const _result_elm = target.closest(".sc-result");
    if (target.classList.contains("svg-icon")) {
      toggle_result(_result_elm);
      return;
    }
    const link = _result_elm.dataset.link || _result_elm.dataset.path;
    if (_result_elm.classList.contains("sc-collapsed")) {
      if (import_obsidian28.Keymap.isModEvent(event)) {
        plugin.open_note(link, event);
      } else {
        toggle_result(_result_elm);
      }
    } else {
      plugin.open_note(link, event);
    }
  };
  result_elm.addEventListener("click", handle_result_click.bind(plugin));
  const path = result_elm.querySelector("li").dataset.key;
  result_elm.addEventListener("dragstart", (event) => {
    const drag_manager = app2.dragManager;
    const file_path = path.split("#")[0];
    const file = app2.metadataCache.getFirstLinkpathDest(file_path, "");
    const drag_data = drag_manager.dragFile(event, file);
    drag_manager.onDragStart(event, drag_data);
  });
  if (path.indexOf("{") === -1) {
    result_elm.addEventListener("mouseover", (event) => {
      const linktext_path = path.replace(/#$/, "");
      app2.workspace.trigger("hover-link", {
        event,
        source: "smart-connections-view",
        hoverParent: result_elm.parentElement,
        targetEl: result_elm,
        linktext: linktext_path
      });
    });
  } else {
    register_block_hover_popover(result_elm.parentElement, result_elm, env, path, plugin);
  }
  const observer = new MutationObserver((mutations) => {
    const has_expansion_change = mutations.some((mutation) => {
      const target = mutation.target;
      return mutation.attributeName === "class" && mutation.oldValue?.includes("sc-collapsed") !== target.classList.contains("sc-collapsed");
    });
    if (has_expansion_change && !mutations[0].target.classList.contains("sc-collapsed")) {
      render_result(mutations[0].target);
    }
  });
  observer.observe(result_elm, {
    attributes: true,
    attributeOldValue: true,
    attributeFilter: ["class"]
  });
  plugin.registerDomEvent(result_elm, "contextmenu", (event) => {
    event.preventDefault();
    event.stopPropagation();
    const curr_key = result_elm.closest(".sc-list")?.dataset.key;
    if (!curr_key) {
      return;
    }
    const curr_collection = curr_key.includes("#") ? env.smart_blocks : env.smart_sources;
    const curr_item = curr_collection.get(curr_key);
    if (!curr_item) return;
    const menu = new import_obsidian28.Menu(app2);
    menu.addItem((menu_item) => {
      menu_item.setTitle(`Hide ${item.name}`).setIcon("eye-off").onClick(() => {
        try {
          if (!curr_item.data.hidden_connections) curr_item.data.hidden_connections = {};
          curr_item.data.hidden_connections[result_elm.dataset.key] = Date.now();
          curr_item.queue_save();
          result_elm.style.display = "none";
          curr_item.collection.save();
        } catch (err) {
          new import_obsidian28.Notice("Hide failed \u2013 check console");
          console.error(err);
        }
      });
    });
    menu.addSeparator();
    menu.addItem((menu_item) => {
      menu_item.setTitle(`Unhide All (${Object.keys(curr_item.data.hidden_connections || {}).length})`).setIcon("eye").onClick(() => {
        try {
          if (!curr_item.data.hidden_connections) return;
          delete curr_item.data.hidden_connections;
          curr_item.queue_save();
          result_elm.closest(".sc-connections-view")?.querySelector('[title="Refresh"]')?.click();
          curr_item.collection.save();
        } catch (err) {
          new import_obsidian28.Notice("Unhide failed \u2013 check console");
          console.error(err);
        }
      });
    });
    menu.showAtMouseEvent(event);
  });
  const expanded_view = env.settings.smart_view_filter.expanded_view ?? env.settings.expanded_view;
  if (!expanded_view) return result_elm;
  toggle_result(result_elm);
  return result_elm;
}
function should_render_embed3(entity) {
  if (!entity) return false;
  if (entity.is_media) return true;
  return false;
}
function process_for_rendering3(content) {
  if (content.includes("```dataview")) content = content.replace(/```dataview/g, "```\\dataview");
  if (content.includes("```smart-context")) content = content.replace(/```smart-context/g, "```\\smart-context");
  if (content.includes("```smart-chatgpt")) content = content.replace(/```smart-chatgpt/g, "```\\smart-chatgpt");
  if (content.includes("![[")) content = content.replace(/\!\[\[/g, "! [[");
  return content;
}

// src/components/connections_v1.js
function build_top_bar_buttons2(view) {
  const expanded_view = view.env.settings.smart_view_filter.expanded_view ?? view.env.settings.expanded_view;
  const buttons = [
    { title: "Refresh", icon: "refresh-cw" },
    { title: "Fold all toggle", icon: expanded_view ? "fold-vertical" : "unfold-vertical" },
    { title: "Lookup", icon: "search" },
    { title: "Settings", icon: "settings" },
    { title: "Help", icon: "help-circle" }
  ];
  return buttons.map((btn) => `
    <button
      title="${btn.title}"
      aria-label="${btn.title} button"
    >
      ${this.get_icon_html(btn.icon)}
    </button>
  `).join("");
}
async function build_html22(view, opts = {}) {
  const top_bar_buttons = build_top_bar_buttons2.call(this, view);
  const html = `<div class="sc-connections-view">
    <div class="sc-top-bar">
      <p class="sc-context" data-key="">
        Loading...
      </p>
      ${top_bar_buttons}
    </div>
    <div class="sc-list">
    </div>
    <div class="sc-bottom-bar">
      <span class="sc-context" data-key="" title="Loading context...">
        Loading context...
      </span>
      ${opts.attribution || ""}
    </div>
  </div>`;
  return html;
}
async function render28(view, opts = {}) {
  const html = await build_html22.call(this, view, opts);
  const frag = this.create_doc_fragment(html);
  return await post_process25.call(this, view, frag, opts);
}
async function post_process25(view, frag, opts = {}) {
  const container = frag.querySelector(".sc-list");
  const toggle_button = frag.querySelector("[title='Fold all toggle']");
  toggle_button.addEventListener("click", () => {
    const expanded = view.env.settings.smart_view_filter.expanded_view ?? view.env.settings.expanded_view;
    if (!view.env.settings.smart_view_filter) view.env.settings.smart_view_filter = {};
    view.env.settings.smart_view_filter.expanded_view = !expanded;
    container.querySelectorAll(".sc-result").forEach(async (elm) => {
      if (expanded) {
        elm.classList.add("sc-collapsed");
      } else {
        elm.classList.remove("sc-collapsed");
      }
    });
    const updated_expanded_view = view.env.settings.smart_view_filter.expanded_view;
    this.safe_inner_html(toggle_button, this.get_icon_html(updated_expanded_view ? "fold-vertical" : "unfold-vertical"));
    toggle_button.setAttribute("aria-label", updated_expanded_view ? "Fold all" : "Unfold all");
  });
  const refresh_button = frag.querySelector("[title='Refresh']");
  refresh_button.addEventListener("click", () => {
    view.refresh();
  });
  const lookup_button = frag.querySelector("[title='Lookup']");
  lookup_button?.addEventListener("click", () => {
    view.plugin.open_lookup_view();
  });
  const help_button = frag.querySelector("[title='Help']");
  help_button?.addEventListener("click", () => {
    StoryModal.open(view.plugin, {
      title: "Getting Started With Smart Connections",
      url: "https://smartconnections.app/story/smart-connections-getting-started/?utm_source=connections-view-help"
    });
  });
  const settings_button = frag.querySelector("[title='Settings']");
  settings_button?.addEventListener("click", () => {
    view.open_settings();
  });
  if (typeof opts.post_process === "function") {
    await opts.post_process(view, frag, opts);
  }
  return frag;
}

// src/components/main_settings.js
async function build_html23(scope_plugin) {
  return `
    <div id="smart-connections-settings">
      <div data-user-agreement></div>

      <div id="smart-connections-getting-started-container">
        <button class="sc-getting-started-button">Getting started guide</button>
        <button class="sc-report-bug-button">Report a bug</button>
        <button class="sc-request-feature-button">Request a feature</button>
        <button class="sc-share-workflow-button">Share workflow \u2B50</button>
      </div>

      <div data-connections-settings-container>
        <h2>Connections view</h2>
      </div>

      <div data-smart-settings="env"></div>
    </div>
  `;
}
async function render29(scope_plugin) {
  if (!scope_plugin.env) {
    const load_frag = this.create_doc_fragment(`
      <div><button>Load Smart Environment</button></div>
    `);
    load_frag.querySelector("button").addEventListener("click", (e) => {
      scope_plugin.env.load(true);
      e.target.replaceWith(
        this.create_doc_fragment("<span>Reload settings after Smart Environment loads\u2026</span>")
      );
    });
    return load_frag;
  }
  const html = await build_html23.call(this, scope_plugin);
  const frag = this.create_doc_fragment(html);
  return await post_process26.call(this, scope_plugin, frag);
}
async function post_process26(scope_plugin, frag) {
  const user_agreement_container = frag.querySelector("[data-user-agreement]");
  if (user_agreement_container) {
    const user_agreement = await scope_plugin.env.render_component(
      "user_agreement_callout",
      scope_plugin
    );
    user_agreement_container.appendChild(user_agreement);
  }
  const env_settings_container = frag.querySelector('[data-smart-settings="env"]');
  if (env_settings_container) {
    const env_settings_frag = await scope_plugin.env.render_component(
      "env_settings",
      scope_plugin.env
    );
    env_settings_container.appendChild(env_settings_frag);
  }
  const connections_settings = frag.querySelector("[data-connections-settings-container]");
  if (connections_settings) {
    const connections_settings_frag = await this.render_settings(
      scope_plugin.env.smart_sources.connections_filter_config,
      { scope: { settings: scope_plugin.env.settings } }
    );
    connections_settings.appendChild(connections_settings_frag);
  }
  const header_link = frag.querySelector("#header-callout a");
  if (header_link) {
    header_link.addEventListener("click", (e) => {
      e.preventDefault();
      open_url_externally(scope_plugin, header_link.href);
    });
  }
  const supporter_callout = await scope_plugin.env.render_component(
    "supporter_callout",
    scope_plugin
  );
  frag.appendChild(supporter_callout);
  frag.querySelector(".sc-getting-started-button")?.addEventListener("click", () => {
    StoryModal.open(scope_plugin, {
      title: "Getting Started With Smart Connections",
      url: "https://smartconnections.app/story/smart-connections-getting-started/?utm_source=sc-op-settings"
    });
  });
  frag.querySelector(".sc-report-bug-button")?.addEventListener("click", () => {
    open_url_externally(
      scope_plugin,
      "https://github.com/brianpetro/obsidian-smart-connections/issues/new?template=bug_report.yml"
    );
  });
  frag.querySelector(".sc-request-feature-button")?.addEventListener("click", () => {
    open_url_externally(
      scope_plugin,
      "https://github.com/brianpetro/obsidian-smart-connections/issues/new?template=feature_request.yml"
    );
  });
  frag.querySelector(".sc-share-workflow-button")?.addEventListener("click", () => {
    open_url_externally(
      scope_plugin,
      "https://github.com/brianpetro/obsidian-smart-connections/discussions/new?category=showcase"
    );
  });
  return frag;
}

// smart_env.config.js
var smart_env_config4 = {
  collections: {},
  item_types: {},
  components: {
    connections: render15,
    connections_result: render27,
    connections_results: render17,
    connections_v1: render28,
    lookup: render16,
    main_settings: render29
  }
};

// src/views/smart_view.obsidian.js
var import_obsidian30 = require("obsidian");

// node_modules/obsidian-smart-env/utils/wait_for_env_to_load.js
var import_obsidian29 = require("obsidian");
async function wait_for_env_to_load(scope, opts = {}) {
  const { wait_for_states = ["loaded"] } = opts;
  const container = scope.container || scope.containerEl;
  if (!wait_for_states.includes(scope.env?.state)) {
    let clicked_load_env = false;
    while (scope.env.state === "init" && import_obsidian29.Platform.isMobile && !clicked_load_env) {
      if (container) {
        container.empty();
        scope.env.smart_view.safe_inner_html(container, "<button>Load Smart Environment</button>");
        container.querySelector("button").addEventListener("click", () => {
          scope.env.load(true);
          clicked_load_env = true;
        });
      } else {
        console.log("Waiting for env to load (mobile)...");
      }
      await new Promise((r) => setTimeout(r, 2e3));
    }
    while (!wait_for_states.includes(scope.env.state)) {
      if (container) {
        const loading_msg = scope.env?.obsidian_is_syncing ? "Waiting for Obsidian Sync to finish..." : "Loading Obsidian Smart Environment...";
        container.empty();
        scope.env.smart_view.safe_inner_html(container, loading_msg);
      } else {
        console.log("Waiting for env to load...");
      }
      await new Promise((r) => setTimeout(r, 2e3));
    }
  }
}

// src/views/smart_view.obsidian.js
var SmartObsidianView = class extends import_obsidian30.ItemView {
  /**
   * Creates an instance of SmartObsidianView.
   * @param {any} leaf
   * @param {any} plugin
   */
  constructor(leaf, plugin) {
    super(leaf);
    this.app = plugin.app;
    this.plugin = plugin;
  }
  /**
   * The unique view type. Must be implemented in subclasses.
   * @returns {string}
   */
  static get view_type() {
    throw new Error("view_type must be implemented in subclass");
  }
  /**
   * The display text for this view. Must be implemented in subclasses.
   * @returns {string}
   */
  static get display_text() {
    throw new Error("display_text must be implemented in subclass");
  }
  /**
   * The icon name for this view.
   * @returns {string}
   */
  static get icon_name() {
    return "smart-connections";
  }
  /**
   * Retrieves the Leaf instance for this view type if it exists.
   * @param {import("obsidian").Workspace} workspace
   * @returns {import("obsidian").WorkspaceLeaf | undefined}
   */
  static get_leaf(workspace) {
    return workspace.getLeavesOfType(this.view_type)[0];
  }
  /**
   * Retrieves the view instance if it exists.
   * @param {import("obsidian").Workspace} workspace
   * @returns {SmartObsidianView | undefined}
   */
  static get_view(workspace) {
    const leaf = this.get_leaf(workspace);
    return leaf ? leaf.view : void 0;
  }
  /**
   * Opens the view. If `this.default_open_location` is `'root'`,
   * it will open (or reveal) in a "root" leaf; otherwise, it will
   * open (or reveal) in the right leaf.
   *
   * @param {import("obsidian").Workspace} workspace
   * @param {boolean} [active=true] - Whether the view should be focused when opened.
   */
  static open(workspace, active = true) {
    const existing_leaf = this.get_leaf(workspace);
    if (this.default_open_location === "root") {
      if (existing_leaf) {
        existing_leaf.setViewState({ type: this.view_type, active });
      } else {
        workspace.getLeaf(false).setViewState({ type: this.view_type, active });
      }
    } else {
      if (existing_leaf) {
        existing_leaf.setViewState({ type: this.view_type, active });
      } else {
        workspace.getRightLeaf(false).setViewState({
          type: this.view_type,
          active
        });
      }
      if (workspace.rightSplit?.collapsed) {
        workspace.rightSplit.toggle();
      }
    }
  }
  static is_open(workspace) {
    return this.get_leaf(workspace)?.view instanceof this;
  }
  // instance
  getViewType() {
    return this.constructor.view_type;
  }
  getDisplayText() {
    return this.constructor.display_text;
  }
  getIcon() {
    return this.constructor.icon_name;
  }
  async onOpen() {
    this.app.workspace.onLayoutReady(this.initialize.bind(this));
  }
  async initialize() {
    await wait_for_env_to_load(this);
    this.container.empty();
    this.register_plugin_events();
    this.app.workspace.registerHoverLinkSource(this.constructor.view_type, { display: this.getDisplayText(), defaultMod: true });
    this.render_view();
  }
  register_plugin_events() {
  }
  render_view() {
    throw new Error("render_view must be implemented in subclass");
  }
  get container() {
    return this.containerEl.children[1];
  }
  get env() {
    return this.plugin.env;
  }
  get smart_view() {
    if (!this._smart_view) this._smart_view = this.env.init_module("smart_view");
    return this._smart_view;
  }
  get attribution() {
    return `
      <div class="sc-brand">
        <svg viewBox="0 0 100 100" class="svg-icon smart-connections">
          <path d="M50,20 L80,40 L80,60 L50,100" stroke="currentColor" stroke-width="4" fill="none"></path>
          <path d="M30,50 L55,70" stroke="currentColor" stroke-width="5" fill="none"></path>
          <circle cx="50" cy="20" r="9" fill="currentColor"></circle>
          <circle cx="80" cy="40" r="9" fill="currentColor"></circle>
          <circle cx="80" cy="70" r="9" fill="currentColor"></circle>
          <circle cx="50" cy="100" r="9" fill="currentColor"></circle>
          <circle cx="30" cy="50" r="9" fill="currentColor"></circle>
        </svg>
        <p><a style="font-weight: 700;" href="https://smartconnections.app/">Smart Connections</a></p>
      </div>
    `;
  }
};

// src/views/connections_view.js
var import_obsidian31 = require("obsidian");
var ConnectionsView = class extends SmartObsidianView {
  static get view_type() {
    return "smart-connections-view";
  }
  static get display_text() {
    return "Smart Connections";
  }
  static get icon_name() {
    return "smart-connections";
  }
  register_plugin_events() {
    this.plugin.registerEvent(
      this.app.workspace.on("file-open", (file) => file && this.render_view(file.path))
    );
    this.plugin.registerEvent(this.app.workspace.on("active-leaf-change", (leaf) => {
      if (leaf.view instanceof this.constructor) {
        if (!this.container) return console.log("Connections view event: active-leaf-change: no container, skipping");
        if (typeof this.container.checkVisibility === "function" && this.container.checkVisibility() === false) {
          return console.log("Connections view event: active-leaf-change: not visible, skipping");
        }
        if (import_obsidian31.Platform.isMobile && this.plugin.app.workspace.activeLeaf.view.constructor.view_type === this.constructor.view_type) {
          this.render_view();
          return;
        }
      }
    }));
  }
  /* ------------------------------------------------------------------ */
  async render_view(target = null, container = this.container) {
    if (container.checkVisibility?.() === false) return;
    if (!target) target = this.app.workspace.getActiveFile()?.path;
    if (!target) {
      container.empty();
      container.createEl("p", { text: "No active file to render connections." });
      return;
    }
    const target_key = typeof target === "string" ? target : target.key ?? target.path;
    if (!target_key) {
      container.empty();
      let msg = "No valid target key provided.";
      if (target && typeof target === "object") {
        msg += ` Received target object: ${JSON.stringify(target)}`;
      }
      container.createEl("p", { text: msg });
      return;
    }
    let entity;
    const is_block = target_key.includes("#");
    if (is_block) {
      entity = this.env.smart_blocks.get(target_key);
      if (!entity) {
        console.warn("ConnectionsView: No entity found for block: " + target_key);
        const source_key = target_key.split("#")[0];
        const source2 = this.env.smart_sources.get(source_key);
        if (source2) {
          return this.render_view(source2, container);
        } else {
          container.empty();
          container.createEl("p", { text: 'No block or source found for "' + target_key + '".' });
          return;
        }
      }
    } else {
      entity = this.env.smart_sources.get(target_key);
      if (!entity) {
        console.warn("ConnectionsView: No entity found for source: " + target_key);
        const source2 = this.env.smart_sources.init_file_path(target_key);
        if (source2) {
          this.env.queue_source_re_import(source2);
          container.empty();
          container.createEl("p", { text: "Source not found, but initialized. Requires embedding." });
          container.createEl("button", {
            text: "Embed now"
          }).addEventListener("click", async () => {
            await this.env.run_re_import();
            this.render_view(source2, container);
          });
          return;
        } else {
          container.empty();
          container.createEl("p", { text: 'No source found for "' + target_key + '". Unable to import. Check Smart Environment exclusion settings.' });
          return;
        }
      }
    }
    if (!entity) {
      container.empty();
      container.createEl("p", { text: "No entity found for the current note." });
      return;
    }
    const frag = await this.env.render_component("connections", entity, {
      attribution: this.attribution,
      view: this
      /* hand back reference for heavy refresh */
    });
    container.empty();
    container.appendChild(frag);
  }
  /* ------------------------------------------------------------------ */
  async refresh() {
    const key = this.container.querySelector(".sc-list")?.dataset.key;
    if (!key) return;
    const entity = this.env.smart_sources.get(key);
    if (!entity) return;
    await entity.read();
    entity.queue_import();
    await entity.collection.process_source_import_queue();
    this.render_view(entity.key);
  }
};

// src/views/sc_lookup.obsidian.js
var ScLookupView = class extends SmartObsidianView {
  static get view_type() {
    return "smart-lookup-view";
  }
  static get display_text() {
    return "Smart Lookup";
  }
  static get icon_name() {
    return "search";
  }
  async render_view(query = "", container = this.container) {
    container.empty();
    container.createEl("span", { text: "Loading lookup..." });
    const frag = await this.env.render_component("lookup", this.env.smart_sources, {
      attribution: this.attribution,
      query
    });
    if (container) {
      container.empty();
      container.appendChild(frag);
    }
  }
};

// src/views/smart_chat.obsidian.js
var import_obsidian32 = require("obsidian");
var SmartChatsView = class extends SmartObsidianView {
  static get view_type() {
    return "smart-chat-v0";
  }
  static get display_text() {
    return "Smart Chat (v0 legacy)";
  }
  static get icon_name() {
    return "message-square";
  }
  /**
   * Registers plugin-specific events such as file opening and active leaf changes.
   */
  register_plugin_events() {
  }
  /**
   * Renders the chat view for a specific entity (chat thread).
   * @param {string|null} entity - The path or key of the chat thread to render.
   */
  async render_view(thread_key = null) {
    this.env.smart_view.safe_inner_html(this.container, "Loading...");
    const frag = await this.env.render_component("smart_chat", this, {
      thread_key
    });
    this.container.empty();
    this.container.appendChild(frag);
  }
  /**
   * Opens the chat history view.
   */
  async open_chat_history() {
    if (!this._chat_history_selector) this._chat_history_selector = new ScChatHistoryModal(this.plugin.app, this);
    this._chat_history_selector.open();
  }
  open_thread(thread_name) {
    const thread_key = Object.keys(this.env.smart_threads.items).find((key) => this.thread_key_to_name(key) === thread_name);
    this.render_view(thread_key);
  }
  thread_key_to_name(thread_key) {
    return thread_key.split("/").pop().split(".").shift();
  }
  /**
   * Handles click events on messages, such as copying to clipboard.
   * @param {Event} event - The click event.
   */
  handle_message_click(event) {
    event.preventDefault();
    event.stopPropagation();
    const message = event.target.classList.contains("sc-message-content") ? event.target : event.target.closest(".sc-message-content");
    if (event.target.classList.contains("sc-msg-button")) {
      this.copy_message_to_clipboard(message);
    }
  }
  handle_chat_input_keydown(event) {
    if (!["/", "@", "[", "!"].includes(event.key)) return;
    const chat_input = event.currentTarget;
    const pos = chat_input.selectionStart;
    if (event.key === "@" && (!pos || [" ", "\n"].includes(chat_input.value[pos - 1]))) {
      this.open_omni_modal();
      event.preventDefault();
      event.stopPropagation();
      return;
    } else if (event.key === "[" && chat_input.value[pos - 1] === "[") {
      setTimeout(() => this.open_file_suggestion_modal(), 10);
    } else if (event.key === "/" && (!pos || [" ", "\n"].includes(chat_input.value[pos - 1]))) {
      setTimeout(() => this.open_folder_suggestion_modal(), 10);
    } else if (event.key === "!" && (!pos || [" ", "\n"].includes(chat_input.value[pos - 1]))) {
      setTimeout(() => this.open_image_suggestion_modal(), 10);
    }
  }
  /**
   * Copies the message content to the clipboard.
   * @param {HTMLElement} message - The message element containing the content.
   */
  copy_message_to_clipboard(message) {
    const content = message.dataset.content;
    navigator.clipboard.writeText(content).then(() => {
      this.plugin.notices.show("copied_to_clipboard", { content });
    }).catch((err) => {
      console.error("Failed to copy message: ", err);
      this.plugin.notices.show("copy_failed");
    });
  }
  open_omni_modal() {
    if (!this.omni_selector) this.omni_selector = new ScOmniModal(this.plugin.app, this);
    this.omni_selector.open();
  }
  open_modal(item) {
    switch (item) {
      case "Files":
        this.open_file_suggestion_modal();
        break;
      case "Folders":
        this.open_folder_suggestion_modal();
        break;
      case "Notes":
        this.open_notes_suggestion_modal();
        break;
      case "Images":
        this.open_image_suggestion_modal();
        break;
    }
  }
  // open file suggestion modal
  open_file_suggestion_modal() {
    if (!this.file_selector) this.file_selector = new ScFileSelectModal(this.plugin.app, this);
    this.file_selector.open();
  }
  open_notes_suggestion_modal() {
    if (!this.notes_selector) this.notes_selector = new ScNotesSelectModal(this.plugin.app, this);
    this.notes_selector.open();
  }
  // open folder suggestion modal
  async open_folder_suggestion_modal() {
    if (!this.folder_selector) {
      const folders = this.env.fs.folder_paths;
      this.folder_selector = new ScFolderSelectModal(this.plugin.app, this, folders);
    }
    this.folder_selector.open();
  }
  async open_system_prompt_modal() {
    if (!this.system_prompt_selector) this.system_prompt_selector = new ScSystemPromptSelectModal(this.plugin.app, this);
    this.system_prompt_selector.open();
  }
  async open_image_suggestion_modal() {
    if (!this.image_selector) {
      this.image_selector = new ScImageSelectModal(this.plugin.app, this);
    }
    this.image_selector.open();
  }
  /**
   * Inserts selected text from a suggestion modal into the chat input.
   * @param {string} insert_text - The text to insert.
   */
  insert_selection(insert_text) {
    if (this.textarea.value.endsWith("[[")) this.textarea.value = this.textarea.value.slice(0, -2);
    if (this.textarea.value.endsWith("/")) this.textarea.value = this.textarea.value.slice(0, -1);
    let caret_pos = this.textarea.selectionStart;
    let text_before = this.textarea.value.substring(0, caret_pos);
    let text_after = this.textarea.value.substring(caret_pos, this.textarea.value.length);
    this.textarea.value = text_before + insert_text + text_after;
    this.textarea.selectionStart = caret_pos + insert_text.length;
    this.textarea.selectionEnd = caret_pos + insert_text.length;
    this.textarea.focus();
  }
  get textarea() {
    return this.container.querySelector(".sc-chat-form textarea");
  }
  insert_system_prompt(prompt_file) {
    const system_message = {
      input: {
        key: prompt_file.path
      }
    };
    this.env.smart_threads.get_active_thread().add_system_message(system_message);
    if (this.textarea.value.endsWith("[[")) this.textarea.value = this.textarea.value.slice(0, -2);
  }
};
var ScChatHistoryModal = class extends import_obsidian32.FuzzySuggestModal {
  constructor(app2, view) {
    super(app2);
    this.app = app2;
    this.view = view;
    this.setPlaceholder("Type the name of a chat session...");
  }
  // sort alphabetically & then by startsWith UNITITLED
  getItems() {
    return Object.keys(this.view.env.smart_threads.items).map((key) => this.view.thread_key_to_name(key)).sort((a, b) => a.localeCompare(b)).sort((a, b) => b.startsWith("UNTITLED") ? -1 : 1);
  }
  // if not UNTITLED, remove date after last em dash
  getItemText(item) {
    return item.indexOf("UNTITLED") === -1 ? item.replace(/—[^—]*$/, "") : item;
  }
  // onChooseItem(session) { this.view.open_chat(session); }
  onChooseItem(thread_name) {
    this.view.open_thread(thread_name);
  }
};
var ScOmniModal = class extends import_obsidian32.FuzzySuggestModal {
  constructor(app2, view) {
    super(app2);
    this.app = app2;
    this.view = view;
    this.setPlaceholder("Select input type...");
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "ArrowRight") this.selectActiveSuggestion(e);
    });
    this.setInstructions([
      {
        command: `Enter or \u2192`,
        purpose: "Select a context type"
      }
    ]);
  }
  getItems() {
    return [
      "Files",
      "Folders",
      "Notes",
      // "System Prompt",
      "Images"
    ];
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item) {
    this.view.open_modal(item);
  }
};
var ContextSelectModal = class extends import_obsidian32.FuzzySuggestModal {
  constructor(app2, view) {
    super(app2);
    this.app = app2;
    this.view = view;
    this.setPlaceholder("Find and select a context...");
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Escape" || e.key === "ArrowLeft") {
        this.view.open_omni_modal();
        this.close();
      }
      if (e.key === "Enter") this.selectActiveSuggestion(e);
    });
  }
};
var ScFileSelectModal = class extends ContextSelectModal {
  constructor(app2, view) {
    super(app2, view);
    const mod_key = import_obsidian32.Platform.isMacOS ? `\u2318` : `ctrl`;
    this.setInstructions([
      {
        command: `\u2190`,
        purpose: "Go back"
      },
      {
        command: `\u21B5`,
        purpose: "Insert as linked context"
      },
      {
        command: `${mod_key} \u21B5`,
        purpose: "Insert as system prompt"
      },
      {
        command: `shift \u21B5`,
        purpose: "Insert content inline"
      }
    ]);
  }
  // get all markdown files
  getItems() {
    return this.app.vault.getFiles().sort((a, b) => a.basename.localeCompare(b.basename));
  }
  getItemText(item) {
    return item.basename;
  }
  selectSuggestion(item, evt) {
    if (import_obsidian32.Keymap.isModEvent(evt)) this.view.insert_system_prompt(item.item);
    else {
      const link = `[[${item.item.path}]] `;
      if (evt.shiftKey) this.view.insert_selection("!" + link);
      else this.view.insert_selection(link);
    }
    this.close();
  }
};
var ScNotesSelectModal = class extends ScFileSelectModal {
  getItems() {
    return this.app.vault.getMarkdownFiles().sort((a, b) => a.basename.localeCompare(b.basename));
  }
};
var ScFolderSelectModal = class extends ContextSelectModal {
  constructor(app2, view, folders) {
    super(app2, view);
    this.folders = folders;
    this.setPlaceholder("Type the name of a folder...");
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Escape" || e.key === "ArrowLeft") {
        this.view.open_omni_modal();
        this.close();
      }
    });
  }
  getItems() {
    return this.folders;
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(folder) {
    this.view.insert_selection("/" + folder + "/ ");
  }
};
var ScImageSelectModal = class extends ScFileSelectModal {
  constructor(app2, view) {
    super(app2, view);
    this.setPlaceholder("Type the name of an image...");
  }
  get image_extensions() {
    return [
      "gif",
      "heic",
      "heif",
      "jpeg",
      "jpg",
      "png",
      "webp"
    ];
  }
  getItems() {
    return this.app.vault.getFiles().filter((file) => this.image_extensions.includes(file.extension)).sort((a, b) => a.basename.localeCompare(b.basename));
  }
  getItemText(item) {
    return item.path;
  }
};

// src/views/sc_chatgpt.obsidian.js
var SmartChatGPTView = class extends SmartObsidianView {
  static get view_type() {
    return "smart-chatgpt-view";
  }
  static get display_text() {
    return "Smart ChatGPT";
  }
  static get icon_name() {
    return "bot";
  }
  getViewType() {
    return this.constructor.view_type;
  }
  getDisplayText() {
    return this.constructor.display_text;
  }
  getIcon() {
    return this.constructor.icon_name;
  }
  static get_leaf(workspace) {
    return workspace.getLeavesOfType(this.view_type)?.find((leaf) => leaf.view instanceof this);
  }
  static open(workspace, active = true) {
    if (this.get_leaf(workspace)) this.get_leaf(workspace).setViewState({ type: this.view_type, active });
    else workspace.getRightLeaf(false).setViewState({ type: this.view_type, active });
    if (workspace.rightSplit.collapsed) workspace.rightSplit.toggle();
  }
  onload() {
    console.log("loading view");
    this.initialize();
  }
  initialize() {
    this.containerEl.empty();
    const buttonContainer = this.containerEl.createEl("div", {
      cls: "button-container"
    });
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "8px";
    buttonContainer.style.marginBottom = "8px";
    const refreshButton = buttonContainer.createEl("button", {
      text: "Refresh"
    });
    refreshButton.addEventListener("click", () => {
      this.initialize();
    });
    const copyUrlButton = buttonContainer.createEl("button", {
      text: "Copy URL"
    });
    copyUrlButton.addEventListener("click", () => {
      const current_url = this.frame?.getAttribute("src");
      if (current_url) {
        navigator.clipboard.writeText(current_url);
        if (this.plugin) {
          this.plugin.notices.show("copied_chatgpt_url_to_clipboard");
        }
      }
    });
    this.containerEl.appendChild(this.create());
  }
  create() {
    this.frame = document.createElement("webview", {});
    this.frame.setAttribute("allowpopups", "");
    this.frame.setAttribute("useragent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.191 Safari/537.36");
    this.frame.setAttribute("partition", this.plugin.app.getWebviewPartition());
    this.frame.style.width = "100%";
    this.frame.style.height = "100%";
    this.frame.setAttribute("src", "https://chatgpt.com/");
    return this.frame;
  }
};

// src/views/sc_private_chat.obsidian.js
var import_obsidian33 = require("obsidian");
var SmartPrivateChatView = class extends import_obsidian33.ItemView {
  static get view_type() {
    return "smart-private-chat";
  }
  static get display_text() {
    return "Smart Connections Supporter Private Chat";
  }
  static get icon_name() {
    return "users";
  }
  getViewType() {
    return this.constructor.view_type;
  }
  getDisplayText() {
    return this.constructor.display_text;
  }
  getIcon() {
    return this.constructor.icon_name;
  }
  static get_leaf(workspace) {
    return workspace.getLeavesOfType(this.view_type)?.find((leaf) => leaf.view instanceof this);
  }
  static open(workspace, active = true) {
    if (this.get_leaf(workspace)) this.get_leaf(workspace).setViewState({ type: this.view_type, active });
    else workspace.getRightLeaf(false).setViewState({ type: this.view_type, active });
    if (workspace.rightSplit.collapsed) workspace.rightSplit.toggle();
  }
  onload() {
    console.log("loading view");
    this.initialize();
  }
  initialize() {
    this.containerEl.empty();
    const refreshButton = this.containerEl.createEl("button", {
      text: "Refresh"
    });
    refreshButton.addEventListener("click", () => {
      this.initialize();
    });
    this.containerEl.appendChild(this.create());
  }
  create() {
    this.frame = document.createElement("webview");
    this.frame.setAttribute("nodeintegration", "");
    this.frame.setAttribute("contextisolation", "");
    this.frame.setAttribute("allowpopups", "");
    this.frame.style.width = "100%";
    this.frame.style.height = "100%";
    this.frame.setAttribute("src", "https://chat.smartconnections.app");
    return this.frame;
  }
};

// node_modules/smart-chat-obsidian/src/smart_chat.obsidian.js
var import_obsidian35 = require("obsidian");

// node_modules/smart-chat-obsidian/node_modules/obsidian-smart-env/utils/wait_for_env_to_load.js
var import_obsidian34 = require("obsidian");
async function wait_for_env_to_load2(scope, opts = {}) {
  const { wait_for_states = ["loaded"] } = opts;
  const container = scope.container || scope.containerEl;
  if (!wait_for_states.includes(scope.env?.state)) {
    let clicked_load_env = false;
    while (scope.env.state === "init" && import_obsidian34.Platform.isMobile && !clicked_load_env) {
      if (container) {
        container.empty();
        scope.env.smart_view.safe_inner_html(container, "<button>Load Smart Environment</button>");
        container.querySelector("button").addEventListener("click", () => {
          scope.env.load(true);
          clicked_load_env = true;
        });
      } else {
        console.log("Waiting for env to load (mobile)...");
      }
      await new Promise((r) => setTimeout(r, 2e3));
    }
    while (!wait_for_states.includes(scope.env.state)) {
      if (container) {
        const loading_msg = scope.env?.obsidian_is_syncing ? "Waiting for Obsidian Sync to finish..." : "Loading Obsidian Smart Environment...";
        container.empty();
        scope.env.smart_view.safe_inner_html(container, loading_msg);
      } else {
        console.log("Waiting for env to load...");
      }
      await new Promise((r) => setTimeout(r, 2e3));
    }
  }
}

// node_modules/smart-chat-obsidian/src/smart_chat.obsidian.js
var SmartChatView = class extends import_obsidian35.ItemView {
  /**
   * @param {WorkspaceLeaf} leaf
   * @param {Plugin} plugin
   */
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.plugin.env.create_env_getter(this);
  }
  static last_plugin = null;
  static view_type = "smart-chat-view";
  /**
   * Unique identifier for the view type.
   * @returns {string}
   */
  getViewType() {
    return this.constructor.view_type;
  }
  static view_name = "Smart Chat";
  /**
   * Display text for the workspace tab.
   * @returns {string}
   */
  getDisplayText() {
    return this.constructor.view_name;
  }
  static icon = "smart-chat";
  /**
   * Icon for the view.
   * @returns {string}
   */
  getIcon() {
    return this.constructor.icon;
  }
  /**
   * Called by Obsidian when the view is opened.
   */
  onOpen() {
    this.render();
  }
  get container() {
    return this.containerEl.children[1];
  }
  /**
   * Render the chat component into the view.
   */
  async render() {
    await wait_for_env_to_load2(this);
    this.containerEl.empty();
    const container = await this.env.render_component("chat", this.env.smart_chat_threads, {});
    this.containerEl.appendChild(container);
  }
  static open(plugin = this.last_plugin) {
    const existing = plugin.app.workspace.getLeavesOfType(this.view_type)[0];
    if (existing) {
      existing.setViewState({ type: this.view_type, active: true });
      existing.view?.render();
      return;
    }
    const root_leaf = plugin.app.workspace.getLeaf(true);
    root_leaf.setViewState({ type: this.view_type, active: true });
  }
  /**
   * Registers the Smart Chat view with the plugin.
   * @param {import('obsidian').Plugin} plugin - Obsidian plugin instance.
   */
  static register_view(plugin) {
    this.last_plugin = plugin;
    plugin.registerView(this.view_type, (leaf) => new this(leaf, plugin));
    plugin.addRibbonIcon(this.icon, "Open: " + this.view_name, () => {
      this.open(plugin);
    });
    plugin.addCommand({
      id: "open-" + this.view_type,
      name: "Open " + this.view_name,
      callback: () => this.open(plugin)
    });
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-collections/utils/collection_instance_name_from.js
function collection_instance_name_from3(class_name) {
  if (class_name.endsWith("Item")) {
    return class_name.replace(/Item$/, "").toLowerCase();
  }
  return class_name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase().replace(/y$/, "ie") + "s";
}

// node_modules/smart-chat-obsidian/node_modules/smart-collections/utils/helpers.js
function create_uid3(data) {
  const str = JSON.stringify(data);
  let hash = 0;
  if (str.length === 0) return hash;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
    if (hash < 0) hash = hash * -1;
  }
  return hash.toString() + str.length;
}
function deep_merge4(target, source2) {
  for (const key in source2) {
    if (source2.hasOwnProperty(key)) {
      if (is_obj(source2[key]) && is_obj(target[key])) deep_merge4(target[key], source2[key]);
      else target[key] = source2[key];
    }
  }
  return target;
  function is_obj(item) {
    return item && typeof item === "object" && !Array.isArray(item);
  }
}

// node_modules/smart-chat-obsidian/node_modules/smart-collections/utils/deep_equal.js
function deep_equal3(obj1, obj2, visited = /* @__PURE__ */ new WeakMap()) {
  if (obj1 === obj2) return true;
  if (obj1 === null || obj2 === null || obj1 === void 0 || obj2 === void 0) return false;
  if (typeof obj1 !== typeof obj2 || Array.isArray(obj1) !== Array.isArray(obj2)) return false;
  if (Array.isArray(obj1)) {
    if (obj1.length !== obj2.length) return false;
    return obj1.every((item, index) => deep_equal3(item, obj2[index], visited));
  }
  if (typeof obj1 === "object") {
    if (visited.has(obj1)) return visited.get(obj1) === obj2;
    visited.set(obj1, obj2);
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length) return false;
    return keys1.every((key) => deep_equal3(obj1[key], obj2[key], visited));
  }
  return obj1 === obj2;
}

// node_modules/smart-chat-obsidian/node_modules/smart-collections/item.js
var CollectionItem3 = class _CollectionItem {
  /**
   * Default properties for an instance of CollectionItem.
   * Override in subclasses to define different defaults.
   * @returns {Object}
   */
  static get defaults() {
    return {
      data: {}
    };
  }
  /**
   * @param {Object} env - The environment/context.
   * @param {Object|null} [data=null] - Initial data for the item.
   */
  constructor(env, data = null) {
    env.create_env_getter(this);
    this.config = this.env?.config;
    this.merge_defaults();
    if (data) deep_merge4(this.data, data);
    if (!this.data.class_name) this.data.class_name = this.collection.item_class_name;
  }
  /**
   * Loads an item from data and initializes it.
   * @param {Object} env
   * @param {Object} data
   * @returns {CollectionItem}
   */
  static load(env, data) {
    const item = new this(env, data);
    item.init();
    return item;
  }
  /**
   * Merge default properties from the entire inheritance chain.
   * @private
   */
  merge_defaults() {
    let current_class = this.constructor;
    while (current_class) {
      for (let key in current_class.defaults) {
        const default_val = current_class.defaults[key];
        if (typeof default_val === "object") {
          this[key] = { ...default_val, ...this[key] };
        } else {
          this[key] = this[key] === void 0 ? default_val : this[key];
        }
      }
      current_class = Object.getPrototypeOf(current_class);
    }
  }
  /**
   * Generates or retrieves a unique key for the item.
   * Key syntax supports:
   * - `[i]` for sequences
   * - `/` for super-sources (groups, directories, clusters)
   * - `#` for sub-sources (blocks)
   * @returns {string} The unique key
   */
  get_key() {
    return create_uid3(this.data);
  }
  /**
   * Updates the item data and returns true if changed.
   * @param {Object} data
   * @returns {boolean} True if data changed.
   */
  update_data(data) {
    const sanitized_data = this.sanitize_data(data);
    const current_data = { ...this.data };
    deep_merge4(current_data, sanitized_data);
    const changed = !deep_equal3(this.data, current_data);
    if (!changed) return false;
    this.data = current_data;
    return true;
  }
  /**
   * Sanitizes data for saving. Ensures no circular references.
   * @param {*} data
   * @returns {*} Sanitized data.
   */
  sanitize_data(data) {
    if (data instanceof _CollectionItem) return data.ref;
    if (Array.isArray(data)) return data.map((val) => this.sanitize_data(val));
    if (typeof data === "object" && data !== null) {
      return Object.keys(data).reduce((acc, key) => {
        acc[key] = this.sanitize_data(data[key]);
        return acc;
      }, {});
    }
    return data;
  }
  /**
   * Initializes the item. Override as needed.
   * @param {Object} [input_data] - Additional data that might be provided on creation.
   */
  init(input_data) {
  }
  /**
   * Queues this item for saving.
   */
  queue_save() {
    this._queue_save = true;
  }
  /**
   * Saves this item using its data adapter.
   * @returns {Promise<void>}
   */
  async save() {
    try {
      await this.data_adapter.save_item(this);
      this.init();
    } catch (err) {
      this._queue_save = true;
      console.error(err, err.stack);
    }
  }
  /**
   * Queues this item for loading.
   */
  queue_load() {
    this._queue_load = true;
  }
  /**
   * Loads this item using its data adapter.
   * @returns {Promise<void>}
   */
  async load() {
    try {
      await this.data_adapter.load_item(this);
      this.init();
    } catch (err) {
      this._load_error = err;
      this.on_load_error(err);
    }
  }
  /**
   * Handles load errors by re-queuing for load.
   * Override if needed.
   * @param {Error} err
   */
  on_load_error(err) {
    this.queue_load();
  }
  /**
   * Validates the item before saving. Checks for presence and validity of key.
   * @returns {boolean}
   */
  validate_save() {
    if (!this.key) return false;
    if (this.key.trim() === "") return false;
    if (this.key === "undefined") return false;
    return true;
  }
  /**
   * Marks this item as deleted. This does not immediately remove it from memory,
   * but queues a save that will result in the item being removed from persistent storage.
   */
  delete() {
    this.deleted = true;
    this.queue_save();
  }
  /**
   * Filters items in the collection based on provided options.
   * functional filter (returns true or false) for filtering items in collection; called by collection class
   * @param {Object} filter_opts - Filtering options.
   * @param {string} [filter_opts.exclude_key] - A single key to exclude.
   * @param {string[]} [filter_opts.exclude_keys] - An array of keys to exclude. If exclude_key is provided, it's added to this array.
   * @param {string} [filter_opts.exclude_key_starts_with] - Exclude keys starting with this string.
   * @param {string[]} [filter_opts.exclude_key_starts_with_any] - Exclude keys starting with any of these strings.
   * @param {string} [filter_opts.exclude_key_includes] - Exclude keys that include this string.
   * @param {string[]} [filter_opts.exclude_key_includes_any] - Exclude keys that include any of these strings.
   * @param {string} [filter_opts.exclude_key_ends_with] - Exclude keys ending with this string.
   * @param {string[]} [filter_opts.exclude_key_ends_with_any] - Exclude keys ending with any of these strings.
   * @param {string} [filter_opts.key_ends_with] - Include only keys ending with this string.
   * @param {string} [filter_opts.key_starts_with] - Include only keys starting with this string.
   * @param {string[]} [filter_opts.key_starts_with_any] - Include only keys starting with any of these strings.
   * @param {string} [filter_opts.key_includes] - Include only keys that include this string.
   * @returns {boolean} True if the item passes the filter, false otherwise.
   */
  filter(filter_opts = {}) {
    const {
      exclude_key,
      exclude_keys = exclude_key ? [exclude_key] : [],
      exclude_key_starts_with,
      exclude_key_starts_with_any,
      exclude_key_includes,
      exclude_key_includes_any,
      exclude_key_ends_with,
      exclude_key_ends_with_any,
      key_ends_with,
      key_starts_with,
      key_starts_with_any,
      key_includes,
      key_includes_any
    } = filter_opts;
    if (exclude_keys?.includes(this.key)) return false;
    if (exclude_key_starts_with && this.key.startsWith(exclude_key_starts_with)) return false;
    if (exclude_key_starts_with_any && exclude_key_starts_with_any.some((prefix) => this.key.startsWith(prefix))) return false;
    if (exclude_key_includes && this.key.includes(exclude_key_includes)) return false;
    if (exclude_key_includes_any && exclude_key_includes_any.some((include) => this.key.includes(include))) return false;
    if (exclude_key_ends_with && this.key.endsWith(exclude_key_ends_with)) return false;
    if (exclude_key_ends_with_any && exclude_key_ends_with_any.some((suffix) => this.key.endsWith(suffix))) return false;
    if (key_ends_with && !this.key.endsWith(key_ends_with)) return false;
    if (key_starts_with && !this.key.startsWith(key_starts_with)) return false;
    if (key_starts_with_any && !key_starts_with_any.some((prefix) => this.key.startsWith(prefix))) return false;
    if (key_includes && !this.key.includes(key_includes)) return false;
    if (key_includes_any && !key_includes_any.some((include) => this.key.includes(include))) return false;
    return true;
  }
  /**
   * Parses item data for additional processing. Override as needed.
   */
  parse() {
  }
  get actions() {
    if (!this._actions) {
      this._actions = Object.entries(this.env.opts.items[this.item_type_key].actions || {}).reduce((acc, [k, v]) => {
        acc[k] = v.bind(this);
        return acc;
      }, {});
    }
    return this._actions;
  }
  /**
   * Derives the collection key from the class name.
   * @returns {string}
   */
  static get collection_key() {
    let name = this.name;
    if (name.match(/\d$/)) name = name.slice(0, -1);
    return collection_instance_name_from3(name);
  }
  /**
   * @returns {string} The collection key for this item.
   */
  get collection_key() {
    let name = this.constructor.name;
    if (name.match(/\d$/)) name = name.slice(0, -1);
    return collection_instance_name_from3(name);
  }
  /**
   * Retrieves the parent collection from the environment.
   * @returns {Collection}
   */
  get collection() {
    return this.env[this.collection_key];
  }
  /**
   * @returns {string} The item's key.
   */
  get key() {
    return this.data?.key || this.get_key();
  }
  get item_type_key() {
    let name = this.constructor.name;
    if (name.match(/\d$/)) name = name.slice(0, -1);
    return camel_case_to_snake_case4(name);
  }
  /**
   * A simple reference object for this item.
   * @returns {{collection_key: string, key: string}}
   */
  get ref() {
    return { collection_key: this.collection_key, key: this.key };
  }
  /**
   * @returns {Object} The data adapter for this item's collection.
   */
  get data_adapter() {
    return this.collection.data_adapter;
  }
  /**
   * @returns {Object} The filesystem adapter.
   */
  get data_fs() {
    return this.collection.data_fs;
  }
  /**
   * Access to collection-level settings.
   * @returns {Object}
   */
  get settings() {
    if (!this.env.settings[this.collection_key]) this.env.settings[this.collection_key] = {};
    return this.env.settings[this.collection_key];
  }
  set settings(settings) {
    this.env.settings[this.collection_key] = settings;
    this.env.smart_settings.save();
  }
  // /**
  //  * Render this item into a container using the item's component.
  //  * @deprecated 2024-12-02 Use explicit component pattern from environment
  //  * @param {HTMLElement} container
  //  * @param {Object} opts
  //  * @returns {Promise<HTMLElement>}
  //  */
  // async render_item(container, opts = {}) {
  //   const frag = await this.component.call(this.smart_view, this, opts);
  //   this.env.smart_view.empty(container);
  //   container.appendChild(frag);
  //   return container;
  // }
  /**
   * @deprecated use env.smart_view
   * @returns {Object}
   */
  get smart_view() {
    if (!this._smart_view) this._smart_view = this.env.init_module("smart_view");
    return this._smart_view;
  }
  // /**
  //  * Override in child classes to set the component for this item
  //  * @deprecated 2024-12-02
  //  * @returns {Function} The render function for this component
  //  */
  // get component() { return item_component; }
};
function camel_case_to_snake_case4(str) {
  const result = str.replace(/([A-Z])/g, (match) => `_${match.toLowerCase()}`).replace(/^_/, "").replace(/2$/, "");
  return result;
}

// node_modules/smart-chat-obsidian/node_modules/smart-collections/collection.js
var AsyncFunction3 = Object.getPrototypeOf(async function() {
}).constructor;
var Collection3 = class {
  /**
   * Constructs a new Collection instance.
   *
   * @param {Object} env - The environment context containing configurations and adapters.
   * @param {Object} [opts={}] - Optional configuration.
   * @param {string} [opts.collection_key] - Custom key to override default collection name.
   * @param {string} [opts.data_dir] - Custom data directory path.
   * @param {boolean} [opts.prevent_load_on_init] - Whether to prevent loading items on initialization.
   */
  constructor(env, opts = {}) {
    env.create_env_getter(this);
    this.opts = opts;
    if (opts.collection_key) this.collection_key = opts.collection_key;
    this.env[this.collection_key] = this;
    this.config = this.env.config;
    this.items = {};
    this.loaded = null;
    this._loading = false;
    this.load_time_ms = null;
    this.settings_container = null;
  }
  /**
   * Initializes a new collection in the environment. Override in subclass if needed.
   *
   * @param {Object} env
   * @param {Object} [opts={}]
   * @returns {Promise<void>}
   */
  static async init(env, opts = {}) {
    env[this.collection_key] = new this(env, opts);
    await env[this.collection_key].init();
    env.collections[this.collection_key] = "init";
  }
  /**
   * The unique collection key derived from the class name.
   * @returns {string}
   */
  static get collection_key() {
    let name = this.name;
    if (name.match(/\d$/)) name = name.slice(0, -1);
    return name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
  }
  /**
   * Instance-level init. Override in subclasses if necessary.
   * @returns {Promise<void>}
   */
  async init() {
  }
  /**
   * Creates or updates an item in the collection.
   * - If `data` includes a key that matches an existing item, that item is updated.
   * - Otherwise, a new item is created.
   * After updating or creating, the item is validated. If validation fails, the item is logged and returned without being saved.
   * If validation succeeds for a new item, it is added to the collection and marked for saving.
   *
   * If the item’s `init()` method is async, a promise is returned that resolves once init completes.
   *
   * @param {Object} [data={}] - Data for creating/updating an item.
   * @returns {Promise<Item>|Item} The created or updated item. May return a promise if `init()` is async.
   */
  create_or_update(data = {}) {
    const existing_item = this.find_by(data);
    const item = existing_item ? existing_item : new this.item_type(this.env);
    item._queue_save = !existing_item;
    const data_changed = item.update_data(data);
    if (!existing_item && !item.validate_save()) {
      return item;
    }
    if (!existing_item) {
      this.set(item);
    }
    if (existing_item && !data_changed) return existing_item;
    if (item.init instanceof AsyncFunction3) {
      return new Promise((resolve) => {
        item.init(data).then(() => resolve(item));
      });
    }
    item.init(data);
    return item;
  }
  /**
   * Finds an item by partial data match (first checks key). If `data.key` provided,
   * returns the item with that key; otherwise attempts a match by merging data.
   *
   * @param {Object} data - Data to match against.
   * @returns {Item|null}
   */
  find_by(data) {
    if (data.key) return this.get(data.key);
    const temp = new this.item_type(this.env);
    const temp_data = JSON.parse(JSON.stringify(data, temp.sanitize_data(data)));
    deep_merge4(temp.data, temp_data);
    return temp.key ? this.get(temp.key) : null;
  }
  /**
   * Filters items based on provided filter options or a custom function.
   *
   * @param {Object|Function} [filter_opts={}] - Filter options or a predicate function.
   * @returns {Item[]} Array of filtered items.
   */
  filter(filter_opts = {}) {
    if (typeof filter_opts === "function") {
      return Object.values(this.items).filter(filter_opts);
    }
    filter_opts = this.prepare_filter(filter_opts);
    const results = [];
    const { first_n } = filter_opts;
    for (const item of Object.values(this.items)) {
      if (first_n && results.length >= first_n) break;
      if (item.filter(filter_opts)) results.push(item);
    }
    return results;
  }
  /**
   * Alias for `filter()`
   * @param {Object|Function} filter_opts
   * @returns {Item[]}
   */
  list(filter_opts) {
    return this.filter(filter_opts);
  }
  /**
   * Prepares filter options. Can be overridden by subclasses to normalize filter options.
   *
   * @param {Object} filter_opts
   * @returns {Object} Prepared filter options.
   */
  prepare_filter(filter_opts) {
    return filter_opts;
  }
  /**
   * Retrieves an item by key.
   * @param {string} key
   * @returns {Item|undefined}
   */
  get(key) {
    return this.items[key];
  }
  /**
   * Retrieves multiple items by an array of keys.
   * @param {string[]} keys
   * @returns {Item[]}
   */
  get_many(keys = []) {
    if (!Array.isArray(keys)) {
      console.error("get_many called with non-array keys:", keys);
      return [];
    }
    return keys.map((key) => this.get(key)).filter(Boolean);
  }
  /**
   * Retrieves a random item from the collection, optionally filtered by options.
   * @param {Object} [opts]
   * @returns {Item|undefined}
   */
  get_rand(opts = null) {
    if (opts) {
      const filtered = this.filter(opts);
      return filtered[Math.floor(Math.random() * filtered.length)];
    }
    const keys = this.keys;
    return this.items[keys[Math.floor(Math.random() * keys.length)]];
  }
  /**
   * Adds or updates an item in the collection.
   * @param {Item} item
   */
  set(item) {
    if (!item.key) throw new Error("Item must have a key property");
    this.items[item.key] = item;
  }
  /**
   * Updates multiple items by their keys.
   * @param {string[]} keys
   * @param {Object} data
   */
  update_many(keys = [], data = {}) {
    this.get_many(keys).forEach((item) => item.update_data(data));
  }
  /**
   * Clears all items from the collection.
   */
  clear() {
    this.items = {};
  }
  /**
   * @returns {string} The collection key, can be overridden by opts.collection_key
   */
  get collection_key() {
    return this._collection_key ? this._collection_key : this.constructor.collection_key;
  }
  set collection_key(key) {
    this._collection_key = key;
  }
  /**
   * Lazily initializes and returns the data adapter instance for this collection.
   * @returns {Object} The data adapter instance.
   */
  get data_adapter() {
    if (!this._data_adapter) {
      const AdapterClass = this.get_adapter_class("data");
      this._data_adapter = new AdapterClass(this);
    }
    return this._data_adapter;
  }
  get_adapter_class(type) {
    const config = this.env.opts.collections?.[this.collection_key];
    const adapter_key = type + "_adapter";
    const adapter_module = config?.[adapter_key] ?? this.env.opts.collections?.smart_collections?.[adapter_key];
    if (typeof adapter_module === "function") return adapter_module;
    if (typeof adapter_module?.collection === "function") return adapter_module.collection;
    throw new Error(`No '${type}' adapter class found for ${this.collection_key} or smart_collections`);
  }
  /**
   * Data directory strategy for this collection. Defaults to 'multi'.
   * @returns {string}
   */
  get data_dir() {
    return this.collection_key;
  }
  /**
   * File system adapter from the environment.
   * @returns {Object}
   */
  get data_fs() {
    return this.env.data_fs;
  }
  /**
   * Derives the corresponding item class name based on this collection's class name.
   * @returns {string}
   */
  get item_class_name() {
    let name = this.constructor.name;
    if (name.match(/\d$/)) name = name.slice(0, -1);
    if (name.endsWith("ies")) return name.slice(0, -3) + "y";
    else if (name.endsWith("s")) return name.slice(0, -1);
    return name + "Item";
  }
  /**
   * Derives a readable item name from the item class name.
   * @returns {string}
   */
  get item_name() {
    return this.item_class_name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
  }
  /**
   * Retrieves the item type (constructor) from the environment.
   * @returns {Function} Item constructor.
   */
  get item_type() {
    if (this.opts.item_type) return this.opts.item_type;
    return this.env.item_types[this.item_class_name];
  }
  /**
   * Returns an array of all keys in the collection.
   * @returns {string[]}
   */
  get keys() {
    return Object.keys(this.items);
  }
  /**
   * @deprecated use data_adapter instead (2024-09-14)
   */
  get adapter() {
    return this.data_adapter;
  }
  /**
   * @method process_save_queue
   * @description 
   * Saves items flagged for saving (_queue_save) back to AJSON or SQLite. This ensures persistent storage 
   * of any updates made since last load/import. This method also writes changes to disk (AJSON files or DB).
   */
  async process_save_queue(opts = {}) {
    if (opts.force) {
      Object.values(this.items).forEach((item) => item._queue_save = true);
    }
    await this.data_adapter.process_save_queue(opts);
  }
  /**
   * @alias process_save_queue
   * @returns {Promise<void>}
   */
  async save(opts = {}) {
    await this.process_save_queue(opts);
  }
  /**
   * @method process_load_queue
   * @description 
   * Loads items that have been flagged for loading (_queue_load). This may involve 
   * reading from AJSON/SQLite or re-importing from markdown if needed. 
   * Called once initial environment is ready and collections are known.
   */
  async process_load_queue() {
    await this.data_adapter.process_load_queue();
  }
  /**
   * Retrieves processed settings configuration.
   * @returns {Object}
   */
  get settings_config() {
    return this.process_settings_config({});
  }
  /**
   * Processes given settings config, adding prefixes and handling conditionals.
   *
   * @private
   * @param {Object} _settings_config
   * @param {string} [prefix='']
   * @returns {Object}
   */
  process_settings_config(_settings_config, prefix = "") {
    const add_prefix = (key) => prefix && !key.includes(`${prefix}.`) ? `${prefix}.${key}` : key;
    return Object.entries(_settings_config).reduce((acc, [key, val]) => {
      let new_val = { ...val };
      if (new_val.conditional) {
        if (!new_val.conditional(this)) return acc;
        delete new_val.conditional;
      }
      if (new_val.callback) new_val.callback = add_prefix(new_val.callback);
      if (new_val.btn_callback) new_val.btn_callback = add_prefix(new_val.btn_callback);
      if (new_val.options_callback) new_val.options_callback = add_prefix(new_val.options_callback);
      const new_key = add_prefix(this.process_setting_key(key));
      acc[new_key] = new_val;
      return acc;
    }, {});
  }
  /**
   * Processes an individual setting key. Override if needed.
   * @param {string} key
   * @returns {string}
   */
  process_setting_key(key) {
    return key;
  }
  /**
   * Default settings for this collection. Override in subclasses as needed.
   * @returns {Object}
   */
  get default_settings() {
    return {};
  }
  /**
   * Current settings for the collection.
   * Initializes with default settings if none exist.
   * @returns {Object}
   */
  get settings() {
    if (!this.env.settings[this.collection_key]) {
      this.env.settings[this.collection_key] = this.default_settings;
    }
    return this.env.settings[this.collection_key];
  }
  /**
   * @deprecated use env.smart_view instead
   * @returns {Object} smart_view instance
   */
  get smart_view() {
    if (!this._smart_view) this._smart_view = this.env.init_module("smart_view");
    return this._smart_view;
  }
  /**
   * Renders the settings for the collection into a given container.
   * @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
   * @param {HTMLElement} [container=this.settings_container]
   * @param {Object} opts
   * @returns {Promise<HTMLElement>}
   */
  async render_settings(container = this.settings_container, opts = {}) {
    return await this.render_collection_settings(container, opts);
  }
  /**
   * Helper function to render collection settings.
   * @deprecated use env.render_component('collection_settings', this) instead (2025-05-25: decouple UI from collections)
   * @param {HTMLElement} [container=this.settings_container]
   * @param {Object} opts
   * @returns {Promise<HTMLElement>}
   */
  async render_collection_settings(container = this.settings_container, opts = {}) {
    if (container && (!this.settings_container || this.settings_container !== container)) {
      this.settings_container = container;
    } else if (!container) {
      container = this.env.smart_view.create_doc_fragment("<div></div>");
    }
    this.env.smart_view.safe_inner_html(container, `<div class="sc-loading">Loading ${this.collection_key} settings...</div>`);
    const frag = await this.env.render_component("settings", this, opts);
    this.env.smart_view.empty(container);
    container.appendChild(frag);
    return container;
  }
  /**
   * Unloads collection data from memory.
   */
  unload() {
    this.clear();
    this.unloaded = true;
    this.env.collections[this.collection_key] = null;
  }
  // only show process notice if taking longer than 1 second
  show_process_notice(process2, opts = {}) {
    if (!this.debounce_process_notice) this.debounce_process_notice = {};
    this.debounce_process_notice[process2] = setTimeout(() => {
      this.debounce_process_notice[process2] = null;
      this.env.notices?.show(process2, { collection_key: this.collection_key, ...opts });
    }, 1e3);
  }
  clear_process_notice(process2) {
    if (this.debounce_process_notice?.[process2]) {
      clearTimeout(this.debounce_process_notice[process2]);
      this.debounce_process_notice[process2] = null;
    } else {
      this.env.notices?.remove(process2);
    }
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-actions/smart_action.js
var SmartAction = class extends CollectionItem3 {
  static collection_key = "smart_actions";
  collection_key = "smart_actions";
  async init() {
    if (!this.action_adapter) {
      delete this.collection.items[this.key];
      return;
    }
    await this.action_adapter.load();
  }
  async run_action(params = {}) {
    params = await this.pre_process(params);
    let result = await this.action_adapter.run(params);
    result = await this.post_process(params, result);
    return result;
  }
  async pre_process(params) {
    for (const pre_process of this.action_pre_processes) {
      params = await pre_process.call(this, params);
    }
    return params;
  }
  async post_process(params, result) {
    for (const post_process40 of this.action_post_processes) {
      result = await post_process40.call(this, params, result);
    }
    return result;
  }
  get action_adapters() {
    return this.collection.opts.action_adapters;
  }
  // Decide which adapter based on data.source_type:
  get action_adapter() {
    if (!this._action_adapter) {
      const adapter = this.action_adapters[this.source_type] || this.action_adapters.default;
      this._action_adapter = new adapter(this);
    }
    return this._action_adapter;
  }
  get action_post_processes() {
    return Object.values(this.module?.post_processes || {});
  }
  get action_pre_processes() {
    return Object.values(this.module?.pre_processes || {});
  }
  get active() {
    return this.data.active !== false;
  }
  set active(val) {
    this.data.active = !!val;
  }
  get endpoint() {
    return Object.keys(this.module.openapi?.paths || {})[0] || `/${this.key}`;
  }
  get module() {
    return this.action_adapter.module;
  }
  set module(module2) {
    this.action_adapter.module = module2;
  }
  get openapi() {
    return this.module.openapi;
  }
  get settings() {
    if (!this.env.settings.smart_actions) this.env.settings.smart_actions = {};
    if (!this.env.settings.smart_actions[this.key]) this.env.settings.smart_actions[this.key] = {};
    return this.env.settings.smart_actions[this.key];
  }
  get source_type() {
    return this.data.source_type;
  }
  /**
   * OpenAI tool definition for this action.
   * Delegates to the action adapter.
   * @returns {object|null}
   */
  get as_tool() {
    return this.action_adapter.as_tool;
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-collections/adapters/_adapter.js
var CollectionDataAdapter3 = class {
  /**
   * @constructor
   * @param {Object} collection - The collection instance that this adapter manages.
   */
  constructor(collection) {
    this.collection = collection;
    this.env = collection.env;
  }
  /**
   * The class to use for item adapters.
   * @type {typeof ItemDataAdapter}
   */
  ItemDataAdapter = ItemDataAdapter3;
  /**
   * Optional factory method to create item adapters.
   * If `this.item_adapter_class` is not null, it uses that; otherwise can be overridden by subclasses.
   * @param {Object} item - The item to create an adapter for.
   * @returns {ItemDataAdapter}
   */
  create_item_adapter(item) {
    if (!this.ItemDataAdapter) {
      throw new Error("No item_adapter_class specified and create_item_adapter not overridden.");
    }
    return new this.ItemDataAdapter(item);
  }
  /**
   * Load a single item by its key using an `ItemDataAdapter`.
   * @async
   * @param {string} key - The key of the item to load.
   * @returns {Promise<void>} Resolves when the item is loaded.
   */
  async load_item(key) {
    throw new Error("Not implemented");
  }
  /**
   * Save a single item by its key using its associated `ItemDataAdapter`.
   * @async
   * @param {string} key - The key of the item to save.
   * @returns {Promise<void>} Resolves when the item is saved.
   */
  async save_item(key) {
    throw new Error("Not implemented");
  }
  /**
   * Delete a single item by its key. This may involve updating or removing its file,
   * as handled by the `ItemDataAdapter`.
   * @async
   * @param {string} key - The key of the item to delete.
   * @returns {Promise<void>} Resolves when the item is deleted.
   */
  async delete_item(key) {
    throw new Error("Not implemented");
  }
  /**
   * Process any queued load operations. Typically orchestrates calling `load_item()` 
   * on items that have been flagged for loading.
   * @async
   * @returns {Promise<void>}
   */
  async process_load_queue() {
    throw new Error("Not implemented");
  }
  /**
   * Process any queued save operations. Typically orchestrates calling `save_item()` 
   * on items that have been flagged for saving.
   * @async
   * @returns {Promise<void>}
   */
  async process_save_queue() {
    throw new Error("Not implemented");
  }
  /**
   * Load the item's data from storage if it has been updated externally.
   * @async
   * @param {string} key - The key of the item to load.
   * @returns {Promise<void>} Resolves when the item is loaded.
   */
  async load_item_if_updated(item) {
    const adapter = this.create_item_adapter(item);
    await adapter.load_if_updated();
  }
};
var ItemDataAdapter3 = class {
  /**
   * @constructor
   * @param {Object} item - The collection item instance that this adapter manages.
   */
  constructor(item) {
    this.item = item;
  }
  /**
   * Load the item's data from storage. May involve reading a file and parsing 
   * its contents, then updating `item.data`.
   * @async
   * @returns {Promise<void>} Resolves when the item is fully loaded.
   */
  async load() {
    throw new Error("Not implemented");
  }
  /**
   * Save the item's data to storage. May involve writing to a file or appending 
   * lines in an append-only format.
   * @async
   * @param {string|null} [ajson=null] - An optional serialized representation of the item’s data.
   *                                     If not provided, the adapter should derive it from the item.
   * @returns {Promise<void>} Resolves when the item is saved.
   */
  async save(ajson = null) {
    throw new Error("Not implemented");
  }
  /**
   * Delete the item's data from storage. May involve removing a file or writing 
   * a `null` entry in an append-only file to signify deletion.
   * @async
   * @returns {Promise<void>} Resolves when the item’s data is deleted.
   */
  async delete() {
    throw new Error("Not implemented");
  }
  /**
   * Returns the file path or unique identifier used by this adapter to locate and store 
   * the item's data. This may be a file name derived from the item's key.
   * @returns {string} The path or identifier for the item's data.
   */
  get data_path() {
    throw new Error("Not implemented");
  }
  /**
   * @returns {CollectionDataAdapter} The collection data adapter that this item data adapter belongs to.
   */
  get collection_adapter() {
    return this.item.collection.data_adapter;
  }
  get env() {
    return this.item.env;
  }
  /**
   * Load the item's data from storage if it has been updated externally.
   * @async
   * @returns {Promise<void>} Resolves when the item is loaded.
   */
  async load_if_updated() {
    throw new Error("Not implemented");
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-collections/adapters/_file.js
var FileCollectionDataAdapter3 = class extends CollectionDataAdapter3 {
  /**
   * The class to use for item adapters.
   * @type {typeof ItemDataAdapter}
   */
  ItemDataAdapter = FileItemDataAdapter3;
  /**
   * @returns {Object} Filesystem interface derived from environment or collection settings.
   */
  get fs() {
    return this.collection.data_fs || this.collection.env.data_fs;
  }
};
var FileItemDataAdapter3 = class extends ItemDataAdapter3 {
  /**
   * @returns {Object} Filesystem interface derived from environment or collection settings.
   */
  get fs() {
    return this.item.collection.data_fs || this.item.collection.env.data_fs;
  }
  get data_path() {
    throw new Error("Not implemented");
  }
  async load_if_updated() {
    const data_path = this.data_path;
    if (await this.fs.exists(data_path)) {
      const loaded_at = this.item.loaded_at || 0;
      const data_file_stat = await this.fs.stat(data_path);
      if (data_file_stat.mtime > loaded_at + 1 * 60 * 1e3) {
        console.log(`Smart Collections: Re-loading item ${this.item.key} because it has been updated on disk`);
        await this.load();
      }
    }
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-collections/adapters/ajson_multi_file.js
var class_to_collection_key4 = {
  "SmartSource": "smart_sources",
  "SmartNote": "smart_sources",
  // DEPRECATED
  "SmartBlock": "smart_blocks",
  "SmartDirectory": "smart_directories"
};
var AjsonMultiFileCollectionDataAdapter3 = class extends FileCollectionDataAdapter3 {
  /**
   * The class to use for item adapters.
   * @type {typeof ItemDataAdapter}
   */
  ItemDataAdapter = AjsonMultiFileItemDataAdapter3;
  /**
   * Load a single item by its key.
   * @async
   * @param {string} key
   * @returns {Promise<void>}
   */
  async load_item(key) {
    const item = this.collection.get(key);
    if (!item) return;
    const adapter = this.create_item_adapter(item);
    await adapter.load();
  }
  /**
   * Save a single item by its key.
   * @async
   * @param {string} key
   * @returns {Promise<void>}
   */
  async save_item(key) {
    const item = this.collection.get(key);
    if (!item) return;
    const adapter = this.create_item_adapter(item);
    await adapter.save();
  }
  /**
   * Process any queued load operations.
   * @async
   * @returns {Promise<void>}
   */
  async process_load_queue() {
    this.collection.show_process_notice("loading_collection");
    if (!await this.fs.exists(this.collection.data_dir)) {
      await this.fs.mkdir(this.collection.data_dir);
    }
    const load_queue = Object.values(this.collection.items).filter((item) => item._queue_load);
    if (!load_queue.length) {
      this.collection.clear_process_notice("loading_collection");
      return;
    }
    console.log(`Loading ${this.collection.collection_key}: ${load_queue.length} items`);
    const batch_size = 100;
    for (let i = 0; i < load_queue.length; i += batch_size) {
      const batch = load_queue.slice(i, i + batch_size);
      await Promise.all(batch.map((item) => {
        const adapter = this.create_item_adapter(item);
        return adapter.load().catch((err) => {
          console.warn(`Error loading item ${item.key}`, err);
          item.queue_load();
        });
      }));
    }
    this.collection.loaded = load_queue.length;
    this.collection.clear_process_notice("loading_collection");
  }
  /**
   * Process any queued save operations.
   * @async
   * @returns {Promise<void>}
   */
  async process_save_queue() {
    this.collection.show_process_notice("saving_collection");
    const save_queue = Object.values(this.collection.items).filter((item) => item._queue_save);
    console.log(`Saving ${this.collection.collection_key}: ${save_queue.length} items`);
    const time_start = Date.now();
    const batch_size = 50;
    for (let i = 0; i < save_queue.length; i += batch_size) {
      const batch = save_queue.slice(i, i + batch_size);
      await Promise.all(batch.map((item) => {
        const adapter = this.create_item_adapter(item);
        return adapter.save().catch((err) => {
          console.warn(`Error saving item ${item.key}`, err);
          item.queue_save();
        });
      }));
    }
    const deleted_items = Object.values(this.collection.items).filter((item) => item.deleted);
    if (deleted_items.length) {
      deleted_items.forEach((item) => {
        delete this.collection.items[item.key];
      });
    }
    console.log(`Saved ${this.collection.collection_key} in ${Date.now() - time_start}ms`);
    this.collection.clear_process_notice("saving_collection");
  }
  get_item_data_path(key) {
    return [
      this.collection.data_dir || "multi",
      this.fs?.sep || "/",
      this.get_data_file_name(key) + ".ajson"
    ].join("");
  }
  /**
   * Transforms the item key into a safe filename.
   * Replaces spaces, slashes, and dots with underscores.
   * @returns {string} safe file name
   */
  get_data_file_name(key) {
    return key.split("#")[0].replace(/[\s\/\.]/g, "_").replace(".md", "");
  }
  /**
   * Build a single AJSON line for the given item and data.
   * @param {Object} item 
   * @returns {string}
   */
  get_item_ajson(item) {
    const collection_key = item.collection_key;
    const key = item.key;
    const data_value = item.deleted ? "null" : JSON.stringify(item.data);
    return `${JSON.stringify(`${collection_key}:${key}`)}: ${data_value},`;
  }
};
var AjsonMultiFileItemDataAdapter3 = class extends FileItemDataAdapter3 {
  /**
   * Derives the `.ajson` file path from the collection's data_dir and item key.
   * @returns {string}
   */
  get data_path() {
    return this.collection_adapter.get_item_data_path(this.item.key);
  }
  /**
   * Load the item from its `.ajson` file.
   * @async
   * @returns {Promise<void>}
   */
  async load() {
    try {
      const raw_data = await this.fs.adapter.read(this.data_path, "utf-8", { no_cache: true });
      if (!raw_data) {
        this.item.queue_import();
        return;
      }
      const { rewrite, file_data } = this._parse(raw_data);
      if (rewrite) {
        if (file_data.length) await this.fs.write(this.data_path, file_data);
        else await this.fs.remove(this.data_path);
      }
      const last_import_mtime = this.item.data.last_import?.at || 0;
      if (last_import_mtime && this.item.init_file_mtime > last_import_mtime) {
        this.item.queue_import();
      }
    } catch (e) {
      this.item.queue_import();
    }
  }
  /**
   * Parse the entire AJSON content as a JSON object, handle legacy keys, and extract final state.
   * @private
   * @param {string} ajson 
   * @returns {boolean}
   */
  _parse(ajson) {
    try {
      let rewrite = false;
      if (!ajson.length) return false;
      ajson = ajson.trim();
      const original_line_count = ajson.split("\n").length;
      const json_str = "{" + ajson.slice(0, -1) + "}";
      const data = JSON.parse(json_str);
      const entries = Object.entries(data);
      for (let i = 0; i < entries.length; i++) {
        const [ajson_key, value] = entries[i];
        if (!value) {
          delete data[ajson_key];
          rewrite = true;
          continue;
        }
        const { collection_key, item_key, changed } = this._parse_ajson_key(ajson_key);
        if (changed) {
          rewrite = true;
          data[collection_key + ":" + item_key] = value;
          delete data[ajson_key];
        }
        const collection = this.env[collection_key];
        if (!collection) continue;
        const existing_item = collection.get(item_key);
        if (!value.key) value.key = item_key;
        if (existing_item) {
          existing_item.data = value;
          existing_item._queue_load = false;
          existing_item.loaded_at = Date.now();
        } else {
          const ItemClass = collection.item_type;
          const new_item = new ItemClass(this.env, value);
          new_item._queue_load = false;
          new_item.loaded_at = Date.now();
          collection.set(new_item);
        }
      }
      if (rewrite || original_line_count > entries.length) {
        rewrite = true;
      }
      return {
        rewrite,
        file_data: rewrite ? Object.entries(data).map(([key, value]) => `${JSON.stringify(key)}: ${JSON.stringify(value)},`).join("\n") : null
      };
    } catch (e) {
      if (ajson.split("\n").some((line) => !line.endsWith(","))) {
        console.warn("fixing trailing comma error");
        ajson = ajson.split("\n").map((line) => line.endsWith(",") ? line : line + ",").join("\n");
        return this._parse(ajson);
      }
      console.warn("Error parsing JSON:", e);
      return { rewrite: true, file_data: null };
    }
  }
  _parse_ajson_key(ajson_key) {
    let changed;
    let [collection_key, ...item_key] = ajson_key.split(":");
    if (class_to_collection_key4[collection_key]) {
      collection_key = class_to_collection_key4[collection_key];
      changed = true;
    }
    return {
      collection_key,
      item_key: item_key.join(":"),
      changed
    };
  }
  /**
   * Save the current state of the item by appending a new line to its `.ajson` file.
   * @async
   * @returns {Promise<void>}
   */
  async save(retries = 0) {
    try {
      const ajson_line = this.get_item_ajson();
      await this.fs.append(this.data_path, "\n" + ajson_line);
      this.item._queue_save = false;
    } catch (e) {
      if (e.code === "ENOENT" && retries < 1) {
        const dir = this.collection_adapter.collection.data_dir;
        if (!await this.fs.exists(dir)) {
          await this.fs.mkdir(dir);
        }
        return await this.save(retries + 1);
      }
      console.warn("Error saving item", this.data_path, this.item.key, e);
    }
  }
  /**
   * Build a single AJSON line for the given item and data.
   * @param {Object} item 
   * @returns {string}
   */
  get_item_ajson() {
    return this.collection_adapter.get_item_ajson(this.item);
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-collections/utils/ajson_merge.js
function ajson_merge2(existing, new_obj) {
  if (new_obj === null) return null;
  if (new_obj === void 0) return existing;
  if (typeof new_obj !== "object") return new_obj;
  if (typeof existing !== "object" || existing === null) existing = {};
  const keys = Object.keys(new_obj);
  const length = keys.length;
  for (let i = 0; i < length; i++) {
    const key = keys[i];
    const new_val = new_obj[key];
    const existing_val = existing[key];
    if (Array.isArray(new_val)) {
      existing[key] = new_val.slice();
    } else if (is_object2(new_val)) {
      existing[key] = ajson_merge2(is_object2(existing_val) ? existing_val : {}, new_val);
    } else if (new_val !== void 0) {
      existing[key] = new_val;
    }
  }
  return existing;
}
function is_object2(obj) {
  return obj !== null && typeof obj === "object" && !Array.isArray(obj);
}

// node_modules/smart-chat-obsidian/node_modules/smart-collections/adapters/ajson_single_file.js
var class_to_collection_key5 = {
  "SmartSource": "smart_sources",
  "SmartNote": "smart_sources",
  // DEPRECATED
  "SmartBlock": "smart_blocks",
  "SmartDirectory": "smart_directories"
};
function _parse_ajson_key2(ajson_key) {
  let changed = false;
  let [collection_key, ...item_key] = ajson_key.split(":");
  if (class_to_collection_key5[collection_key]) {
    collection_key = class_to_collection_key5[collection_key];
    changed = true;
  }
  return {
    collection_key,
    item_key: item_key.join(":"),
    changed
  };
}
var AjsonSingleFileCollectionDataAdapter2 = class extends AjsonMultiFileCollectionDataAdapter3 {
  /**
   * Returns the single shared `.ajson` file path for this collection.
   * @param {string} [key] - (unused) Item key, ignored in single-file mode.
   * @returns {string} The single .ajson file path for the entire collection.
   */
  get_item_data_path(key) {
    const file_name = (this.collection?.collection_key || "collection") + ".ajson";
    const sep = this.fs?.sep || "/";
    const dir = this.collection.data_dir || "data";
    return [dir, file_name].join(sep);
  }
  /**
   * Override process_load_queue to parse the entire single-file .ajson once,
   * distributing final states to items.
   *
   * @async
   * @returns {Promise<void>}
   */
  async process_load_queue() {
    this.collection.show_process_notice("loading_collection");
    if (!await this.fs.exists(this.collection.data_dir)) {
      await this.fs.mkdir(this.collection.data_dir);
    }
    const path = this.get_item_data_path();
    if (!await this.fs.exists(path)) {
      for (const item of Object.values(this.collection.items)) {
        if (item._queue_load) {
          item.queue_import?.();
        }
      }
      this.collection.clear_process_notice("loading_collection");
      return;
    }
    const raw_data = await this.fs.read(path, "utf-8", { no_cache: true });
    if (!raw_data) {
      for (const item of Object.values(this.collection.items)) {
        if (item._queue_load) {
          item.queue_import?.();
        }
      }
      this.collection.clear_process_notice("loading_collection");
      return;
    }
    const { rewrite, file_data } = this.parse_single_file_ajson(raw_data);
    if (rewrite) {
      if (file_data.length) {
        await this.fs.write(path, file_data);
      } else {
        await this.fs.remove(path);
      }
    }
    for (const item of Object.values(this.collection.items)) {
      item._queue_load = false;
      item.loaded_at = Date.now();
    }
    this.collection.clear_process_notice("loading_collection");
  }
  /**
   * Helper to parse single-file .ajson content, distributing states to items.
   *
   * @param {string} raw
   * @returns {{ rewrite: boolean, file_data: string }}
   */
  parse_single_file_ajson(raw) {
    let rewrite = false;
    const lines = raw.trim().split("\n").filter(Boolean);
    let data_map = {};
    let line_count = 0;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line.endsWith(",")) {
        rewrite = true;
      }
      const trimmed = line.replace(/,$/, "");
      const combined = "{" + trimmed + "}";
      try {
        const obj = JSON.parse(combined);
        const [fullKey, value] = Object.entries(obj)[0];
        let { collection_key, item_key, changed } = _parse_ajson_key2(fullKey);
        const newKey = `${collection_key}:${item_key}`;
        if (!value) {
          delete data_map[newKey];
          if (changed || newKey !== fullKey) {
            delete data_map[fullKey];
          }
          rewrite = true;
        } else {
          data_map[newKey] = value;
          if (changed || newKey !== fullKey) {
            delete data_map[fullKey];
            rewrite = true;
          }
        }
      } catch (err) {
        console.warn("parse error for line: ", line, err);
        rewrite = true;
      }
      line_count++;
    }
    for (const [ajson_key, val] of Object.entries(data_map)) {
      const [collection_key, ...rest] = ajson_key.split(":");
      const item_key = rest.join(":");
      const collection = this.collection.env[collection_key];
      if (!collection) continue;
      let item = collection.get(item_key);
      if (!item) {
        const ItemClass = collection.item_type;
        item = new ItemClass(this.env, val);
        collection.set(item);
      } else {
        item.data = ajson_merge2(item.data, val);
      }
      item.loaded_at = Date.now();
      item._queue_load = false;
      if (!val.key) val.key = item_key;
    }
    if (line_count > Object.keys(data_map).length) {
      rewrite = true;
    }
    let minimal_lines = [];
    for (const [ajson_key, val] of Object.entries(data_map)) {
      minimal_lines.push(`${JSON.stringify(ajson_key)}: ${JSON.stringify(val)},`);
    }
    return {
      rewrite,
      file_data: minimal_lines.join("\n")
    };
  }
  /**
   * Override process_save_queue for single-file approach.
   * We'll simply call save_item for each queued item, which appends a line to the same `.ajson`.
   *
   * @async
   * @returns {Promise<void>}
   */
  async process_save_queue() {
    this.collection.show_process_notice("saving_collection");
    const save_queue = Object.values(this.collection.items).filter((item) => item._queue_save);
    const time_start = Date.now();
    const batch_size = 50;
    for (let i = 0; i < save_queue.length; i += batch_size) {
      const batch = save_queue.slice(i, i + batch_size);
      await Promise.all(batch.map((item) => {
        const adapter = this.create_item_adapter(item);
        return adapter.save().catch((err) => {
          console.warn(`Error saving item ${item.key}`, err);
          item.queue_save();
        });
      }));
    }
    const deleted_items = Object.values(this.collection.items).filter((item) => item.deleted);
    if (deleted_items.length) {
      deleted_items.forEach((item) => {
        delete this.collection.items[item.key];
      });
    }
    console.log(`Saved (single-file) ${this.collection.collection_key} in ${Date.now() - time_start}ms`);
    this.collection.clear_process_notice("saving_collection");
  }
};
var AjsonSingleFileItemDataAdapter = class extends AjsonMultiFileItemDataAdapter3 {
  /**
   * Overridden to always return the single file path from the parent collection adapter.
   * @returns {string}
   */
  get data_path() {
    return this.collection_adapter.get_item_data_path(this.item.key);
  }
  /**
   * Load logic:
   * In single-file mode, we typically rely on the collection's `process_load_queue()`
   * to parse the entire file. This direct `load()` will do a naive re-parse as well
   * if used individually.
   */
  async load() {
    const path = this.data_path;
    if (!await this.fs.exists(path)) {
      this.item.queue_import?.();
      return;
    }
    try {
      const raw_data = await this.fs.read(path, "utf-8", { no_cache: true });
      if (!raw_data) {
        this.item.queue_import?.();
        return;
      }
      const { rewrite } = this.collection_adapter.parse_single_file_ajson(raw_data);
    } catch (err) {
      console.warn(`Error loading single-file item ${this.item.key}`, err);
      this.item.queue_import?.();
    }
  }
};
var ajson_single_file_default = {
  collection: AjsonSingleFileCollectionDataAdapter2,
  item: AjsonSingleFileItemDataAdapter
};

// node_modules/smart-chat-obsidian/node_modules/smart-actions/adapters/_adapter.js
var SmartActionAdapter = class {
  constructor(item) {
    this.item = item;
    this.module = null;
  }
  async load() {
  }
  /**
   * Run the loaded module’s default (or named) function with given params.
   * @param {Object} params
   * @returns {Promise<any>}
   */
  async run(params) {
    if (!this.module) {
      await this.load();
    }
    const fn = this.module.default || this.module[this.item.key];
    if (typeof fn !== "function") {
      throw new Error(`${this.constructor.name}: No callable export found for action ${this.item.key}`);
    }
    return await fn.call(this.item, params);
  }
  /**
   * Generate an OpenAI-style tool definition for this action.
   * By default it checks `module.tool` or converts `module.openapi`.
   * @returns {object|null}
   */
  get as_tool() {
    if (!this.module) return null;
    if (this.module.tool) return this.module.tool;
    if (this.module.openapi) {
      return convert_openapi_to_tools2(this.module.openapi)[0] || null;
    }
    return null;
  }
};
function convert_openapi_to_tools2(openapi_spec) {
  const tools = [];
  for (const path in openapi_spec.paths || {}) {
    const methods = openapi_spec.paths[path];
    for (const method in methods) {
      const endpoint = methods[method];
      const parameters = endpoint.parameters || [];
      const requestBody = endpoint.requestBody;
      const properties = {};
      const required = [];
      parameters.forEach((param) => {
        properties[param.name] = {
          type: param.schema.type,
          description: param.description || ""
        };
        if (param.required) required.push(param.name);
      });
      if (requestBody) {
        const schema = requestBody.content["application/json"].schema;
        Object.assign(properties, schema.properties);
        if (schema.required) required.push(...schema.required);
      }
      tools.push({
        type: "function",
        function: {
          name: endpoint.operationId || `${method}_${path.replace(/\//g, "_").replace(/[{}]/g, "")}`,
          description: endpoint.summary || endpoint.description || "",
          parameters: {
            type: "object",
            properties,
            required
          }
        }
      });
    }
  }
  return tools;
}

// node_modules/smart-chat-obsidian/node_modules/smart-actions/smart_actions.js
var SmartActions = class extends Collection3 {
  collection_key = "smart_actions";
  static collection_key = "smart_actions";
  data_dir = "smart_actions";
  async init() {
    Object.entries(this.opts.default_actions).forEach(async ([action_key, module2]) => {
      await this.register_included_module(action_key, module2);
    });
  }
  async register_included_module(action_key, module2) {
    const action = await this.create_or_update({
      key: action_key,
      source_type: "included"
    });
    action.module = module2;
    return action;
  }
};
var smart_actions_default = {
  class: SmartActions,
  item_type: SmartAction,
  data_adapter: ajson_single_file_default,
  action_adapters: {
    default: SmartActionAdapter
  }
};

// node_modules/smart-chat-obsidian/src/actions/lookup_context.js
var lookup_context_exports = {};
__export(lookup_context_exports, {
  lookup_context: () => lookup_context,
  render_output: () => render_output,
  tool: () => tool
});
async function lookup_context(params = {}) {
  const env = this.env;
  let {
    hypotheticals = [],
    hypothetical_1,
    hypothetical_2,
    hypothetical_3,
    in_folder,
    context_key,
    ...other_params
  } = params;
  if (typeof hypotheticals === "string") {
    if (hypotheticals.startsWith("[") && hypotheticals.endsWith("]")) {
      hypotheticals = JSON.parse(hypotheticals);
    } else if (hypotheticals.includes("\n")) {
      hypotheticals = hypotheticals.split("\n");
    } else {
      hypotheticals = [hypotheticals];
    }
  }
  if (hypothetical_1) hypotheticals.push(hypothetical_1);
  if (hypothetical_2) hypotheticals.push(hypothetical_2);
  if (hypothetical_3) hypotheticals.push(hypothetical_3);
  if (!hypotheticals?.length) return { error: "hypotheticals is required" };
  let existing_context = null;
  let existing_item_keys = [];
  if (context_key) {
    existing_context = env.smart_contexts.get(context_key);
    if (existing_context?.data?.context_items) {
      existing_item_keys = Object.keys(existing_context.data.context_items);
    }
  }
  if (!other_params.filter) other_params.filter = {};
  if (in_folder && in_folder !== "/") {
    if (env.smart_sources.fs.folders[in_folder]) {
      if (!other_params.filter.key_starts_with) {
        const folder_prefix = in_folder.endsWith("/") ? in_folder : `${in_folder}/`;
        other_params.filter.key_starts_with = folder_prefix;
      }
    } else {
      console.warn(`Folder "${in_folder}" does not exist in the vault. Skipping folder scoping.`);
    }
  }
  if (existing_item_keys.length) {
    if (!Array.isArray(other_params.filter.exclude_keys)) other_params.filter.exclude_keys = [];
    other_params.filter.exclude_keys.push(...existing_item_keys);
  }
  const collection = env.smart_blocks?.settings?.embed_blocks ? env.smart_blocks : env.smart_sources;
  const results = await collection.lookup({ ...other_params, hypotheticals });
  let context;
  if (existing_context) {
    existing_context.add_items(
      results.map((result) => ({ key: result.key, score: result.score }))
    );
    context = existing_context;
  } else {
    context = env.smart_contexts.new_context({
      context_items: results.reduce((acc, result) => {
        acc[result.key] = { d: 0, score: result.score };
        return acc;
      }, {})
    });
  }
  return context.key;
}
var tool = {
  type: "function",
  function: {
    name: "lookup_context",
    description: "Common, frequently used. Performs a semantic search of the user's data. Use to respond to 'Based on my notes...' or any other query that might require surfacing unspecified content. Minimum 3 hypothetical notes predicted to be semantically similar to the notes necessary to fulfill the user's request. Each hypothetical is a semantic representation of content that's likely relevant to the user's request. Hypothetical notes always begin with breadcrumbs containing the hypothetical folder(s) and file name (separated by ' > '). Example: HYPOTHETICAL FOLDER NAME > CHILD FOLDER NAME > FILE NAME: HYPOTHETICAL NOTE CONTENTS. Important: minimum 3.",
    parameters: {
      type: "object",
      properties: {
        hypothetical_1: {
          type: "string",
          description: "Always begin with breadcrumbs containing the hypothetical folder(s) and file name (separated by ' > '). Example: HYPOTHETICAL FOLDER NAME > CHILD FOLDER NAME > FILE NAME: HYPOTHETICAL NOTE CONTENTS. Important: minimum 3."
        },
        hypothetical_2: {
          type: "string",
          description: "Must be distinct from and not share any breadcrumbs with hypothetical_1."
        },
        hypothetical_3: {
          type: "string",
          description: "Must be distinct from hypothetical_1 and hypothetical_2."
        },
        in_folder: {
          type: "string",
          description: "Use only if absolutely required. Exclude unles asked for a specific folder. Limits the lookup to items in this folder."
        }
        // EXCLUDED because used internally and the model currently isn't aware of the current context key
        // context_key: {
        //   type: 'string',
        //   description:
        //     "Optional. The key of an existing SmartContext. When provided, lookup results are appended to this context instead of creating a new one."
        // }
      },
      required: ["hypothetical_1", "hypothetical_2"]
    }
  }
};
async function render_output(env, output, params) {
  const context = env.smart_contexts.get(output);
  if (!context) {
    return `No context found for key: ${output}`;
  }
  return await env.render_component("context_builder", context);
}

// node_modules/smart-chat-obsidian/src/collections/smart_actions.js
smart_actions_default.default_actions = {
  lookup_context: lookup_context_exports
};
var smart_actions_default2 = smart_actions_default;

// node_modules/smart-chat-obsidian/src/utils/add_thread_item.js
function add_thread_item(thread, new_key) {
  if (Object.keys(thread.data.items).length === 0) {
    thread.data.items[new_key] = { _active: true };
    thread.data.items._active = new_key;
  } else {
    let current_node = thread.data.items;
    const active_key_at_level = "_active";
    while (current_node[active_key_at_level] && current_node[current_node[active_key_at_level]]) {
      current_node = current_node[current_node[active_key_at_level]];
    }
    const parent_node = current_node;
    parent_node[new_key] = { _active: true };
    parent_node._active = new_key;
  }
}
function list_thread_items(thread) {
  const active_keys = [];
  let current_node = thread.data.items;
  while (current_node && current_node._active) {
    const active_key = current_node._active;
    if (typeof current_node[active_key] !== "object" || current_node[active_key] === null) break;
    active_keys.push(active_key);
    current_node = current_node[active_key];
  }
  return active_keys;
}

// node_modules/smart-chat-obsidian/src/utils/self_referential_keywords.js
function contains_self_referential_keywords2(user_input, language) {
  const language_settings = ScTranslations_default[language];
  if (!language_settings) return false;
  let check_str = `${user_input}`;
  if (check_str.match(new RegExp(`\\b(${language_settings.pronouns.join("|")})\\b`, "gi"))) return true;
  return false;
}
function get_language_options2() {
  return Object.entries(ScTranslations_default).map(([language, language_settings]) => ({ value: language, name: language_settings.name }));
}
function get_initial_message2(language) {
  const language_settings = ScTranslations_default[language];
  return language_settings.initial_message;
}

// node_modules/smart-chat-obsidian/node_modules/smart-context-obsidian/node_modules/smart-utils/file_tree.js
function build_file_tree_string(paths = []) {
  if (!Array.isArray(paths) || paths.length === 0) return "";
  const root = {};
  for (const path of paths) {
    const isFolder = is_folder_path(path);
    const parts = path.split("/").filter(Boolean);
    let node = root;
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      const isLast = i === parts.length - 1;
      if (isLast) {
        if (isFolder) {
          node[part] = node[part] ?? { __isExplicitFolder: true };
        } else {
          node[part] = null;
        }
      } else {
        node = node[part] ??= {};
      }
    }
  }
  compress_single_child_dirs(root);
  return build_tree_string(root).trimEnd();
}
function is_folder_path(path) {
  return typeof path === "string" && path.endsWith("/");
}
function compress_single_child_dirs(node) {
  if (!node || typeof node !== "object") return;
  for (const key of Object.keys(node)) {
    const child = node[key];
    if (child && typeof child === "object") {
      if (child.__isExplicitFolder) {
        delete child.__isExplicitFolder;
        compress_single_child_dirs(child);
        continue;
      }
      const childKeys = Object.keys(child);
      if (childKeys.length === 1 && child[childKeys[0]] !== null && !child[childKeys[0]].__isExplicitFolder) {
        const mergedKey = `${key}/${childKeys[0]}`;
        node[mergedKey] = child[childKeys[0]];
        delete node[key];
        compress_single_child_dirs(node[mergedKey]);
      } else {
        compress_single_child_dirs(child);
      }
    }
  }
}
function build_tree_string(node, prefix = "") {
  let output = "";
  const entries = Object.entries(node).sort((a, b) => {
    const aIsDir = a[1] !== null;
    const bIsDir = b[1] !== null;
    if (aIsDir && !bIsDir) return -1;
    if (!aIsDir && bIsDir) return 1;
    return a[0].localeCompare(b[0]);
  });
  entries.forEach(([name, child], idx) => {
    const isLast = idx === entries.length - 1;
    const connector = isLast ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ";
    if (child === null) {
      output += `${prefix}${connector}${name}
`;
    } else {
      output += `${prefix}${connector}${name}/
`;
      output += build_tree_string(child, prefix + (isLast ? "    " : "\u2502   "));
    }
  });
  return output;
}

// node_modules/smart-chat-obsidian/node_modules/smart-context-obsidian/src/utils/replace_folder_tree_var.js
function replace_folder_tree_var(prompt) {
  let paths = smart_env.smart_sources?.fs?.folder_paths ?? [];
  paths = paths.map((p) => p.endsWith("/") ? p : p + "/");
  const tree = build_file_tree_string([...new Set(paths)]);
  prompt = prompt.replace(/{{\s*folder_tree\s*}}/gi, tree);
  return prompt;
}

// node_modules/smart-chat-obsidian/src/items/smart_chat_thread.js
var SmartChatThread = class extends CollectionItem3 {
  static get defaults() {
    return {
      data: {
        name: "",
        system_prompt: "",
        items: {}
      }
    };
  }
  get_key() {
    if (!this.data.key) {
      const now = /* @__PURE__ */ new Date();
      const pad = (n) => n.toString().padStart(2, "0");
      const formatted = `Untitled Chat ${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())} ${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;
      this.data.key = formatted;
    }
    return this.data.key;
  }
  /**
   * @property {string} name - Friendly thread name; falls back to key if empty.
   */
  get name() {
    return this.data.name || this.data.key;
  }
  set name(val) {
    this.data.name = val;
  }
  get chat_model() {
    return this.collection.chat_model;
  }
  init_completion(data = {}) {
    const completion_data = {
      key: `${this.key}-${Date.now()}`,
      thread_key: this.key,
      stream: this.collection.settings.stream,
      ...data
    };
    if (this.has_default_system_prompt && !this.completions[0]?.data?.system_message) {
      completion_data.system_message = this.get_system_prompt(completion_data);
    }
    if (!completion_data.context_key) {
      const last_context_key = this.last_completion?.data?.context_key;
      completion_data.context_key = last_context_key || this.env.smart_contexts.new_context().key;
    }
    const completion = new this.env.smart_completions.item_type(this.env, completion_data);
    this.env.smart_completions.set(completion);
    completion.chat_model = this.chat_model;
    this._current_completion = completion;
    add_thread_item(this, completion.key);
    return completion;
  }
  /**
   * Updates the context for the current completion.
   * @param {object|null} context
   */
  update_current_context(context, opts = {}) {
    this.current_completion.data.context_key = context?.key || null;
  }
  get current_completion() {
    if (!this._current_completion || this._current_completion && this._current_completion.data.completion.responses.length !== 0) {
      this._current_completion = this.init_completion();
    }
    return this._current_completion;
  }
  set current_completion(completion) {
    this._current_completion = completion;
  }
  get last_completion() {
    return this.completions.findLast((completion) => completion.response);
  }
  get completion_keys() {
    return list_thread_items(this);
  }
  get completions() {
    return this.completion_keys.map((key) => this.env.smart_completions.get(key)).filter(Boolean);
  }
  get has_default_system_prompt() {
    return this.settings.system_prompt.trim().length > 0;
  }
  /**
   * Build system-prompt text, expanding {{folder_tree}} if present.
   * @param {object} [opts={}]  optional { system_message }
   * @returns {string}
   */
  get_system_prompt(opts = {}) {
    let prompt = this.settings.system_prompt || "";
    if (opts.system_message) {
      prompt = prompt ? `${prompt}

${opts.system_message}` : opts.system_message;
    }
    if (prompt.includes("{{folder_tree}}")) {
      prompt = replace_folder_tree_var(prompt);
    }
    return prompt;
  }
  get messages() {
    return this.completions.map((completion) => completion.messages).flat();
  }
  /**
   * Checks if the user_message contains self-referential pronouns
   * (only if user enabled the detection in settings).
   * @param {string} user_message 
   * @returns {boolean} 
   */
  has_self_referential_pronoun(user_message) {
    if (!user_message) return false;
    if (!this.collection.settings.detect_self_referential) return false;
    const lang = this.collection.settings.language || "en";
    return contains_self_referential_keywords2(user_message, lang);
  }
};

// node_modules/smart-chat-obsidian/src/collections/smart_chat_threads.js
var SmartChatThreads = class extends Collection3 {
  get chat_model() {
    const chat_model_opts = {
      model_config: {},
      settings: this.settings.chat_model,
      reload_model: () => console.log("no reload_model needed"),
      re_render_settings: this.open_settings?.bind(this)
    };
    return this.env.init_module("smart_chat_model", chat_model_opts);
  }
  async open_settings() {
    const plugin = this.env.smart_chat_plugin || this.env.smart_connections_plugin;
    await plugin.app.setting.open();
    await plugin.app.setting.openTabById("smart-chat");
  }
  /**
   * @property {string} settings.active_thread_key - The key of the currently active thread.
   * @returns {SmartChatThread|null}
   */
  get active_thread() {
    const key = this.settings.active_thread_key;
    if (!key) return null;
    const thread = this.get(key) || null;
    if (!thread || thread.deleted) {
      this.settings.active_thread_key = "";
      return null;
    }
    return thread;
  }
  set active_thread(thread) {
    if (!thread?.key) {
      this.settings.active_thread_key = "";
      return;
    }
    this.settings.active_thread_key = thread.key;
  }
  /**
   * Example default settings for chat threads collection:
   */
  static get default_settings() {
    return {
      active_thread_key: "",
      chat_model: {
        adapter: "ollama"
      },
      system_prompt: "",
      detect_self_referential: true,
      review_context: true,
      stream: true,
      language: "en",
      modifier_key_to_send: "shift",
      use_tool_calls: true
    };
  }
  get settings_config() {
    return {
      "language": {
        name: "Language",
        type: "dropdown",
        options_callback: "get_language_options",
        description: "The language for the chat.",
        default: "en"
      },
      "detect_self_referential": {
        name: "Detect Self-Referential Pronouns",
        type: "toggle",
        description: "Trigger lookup when user message references 'my notes', etc."
      },
      "review_context": {
        name: "Review Context",
        type: "toggle",
        description: "Show retrieved context for approval before sending to AI."
      },
      "system_prompt": {
        name: "System Prompt",
        type: "textarea",
        description: "Prepended to every thread as the system role message. You can include {{folder_tree}} to embed your vault's folder structure."
      },
      "stream": {
        name: "Stream",
        type: "toggle",
        description: "Whether to stream the response from the AI."
      },
      "modifier_key_to_send": {
        name: "Modifier key to send with Enter",
        type: "dropdown",
        "option-0": "none|Enter",
        "option-1": "shift|\u21E7 Shift + Enter",
        "option-2": "mod|\u2318/Ctrl + Enter",
        "option-3": "alt|Alt + Enter",
        "option-4": "meta|\u2318/\u229EWin + Enter",
        default: "shift",
        description: "Choose which modifier (if any) is required with Enter to send the chat."
      },
      "use_tool_calls": {
        name: "Use tool calling for actions",
        type: "toggle",
        description: "Reccommended if the model you're using supports it. Turn off to use more-compatible yet less-reliable format."
      }
    };
  }
  get_language_options() {
    return get_language_options2();
  }
  async process_save_queue() {
    await super.process_save_queue();
    await this.env.smart_completions.process_save_queue();
    await this.env.smart_contexts.process_save_queue();
  }
};
var smart_chat_threads_default = {
  class: SmartChatThreads,
  collection_key: "smart_chat_threads",
  data_adapter: AjsonSingleFileCollectionDataAdapter2,
  item_type: SmartChatThread
};

// node_modules/smart-chat-obsidian/node_modules/smart-completions/smart_completions.js
var SmartCompletions2 = class extends Collection3 {
  /**
   * Lazily instantiates and returns a chat_model. Similar to how
   * SmartEntities implements embed_model. You can adapt this
   * depending on how your environment is structured.
   *
   * @returns {Object|null} The chat model instance or null if not configured
   */
  get chat_model() {
    if (!this._chat_model) {
      this._chat_model = this.env.init_module("smart_chat_model", {
        model_config: {},
        settings: this.settings.chat_model ?? this.env.smart_chat_threads?.settings?.chat_model ?? {},
        reload_model: this.reload_chat_model.bind(this),
        re_render_settings: this.re_render_settings?.bind(this) ?? (() => {
          console.log("no re_render_settings");
        })
      });
    }
    return this._chat_model;
  }
  /**
   * Force unload & reload of chat model if user changes adapter or settings.
   */
  reload_chat_model() {
    if (this._chat_model?.unload) {
      this._chat_model.unload();
    }
    this._chat_model = null;
  }
  /**
   * In addition to base collection settings, merges `chat_model.settings_config`.
   * Allows the SmartCompletions UI to show chat-model relevant settings.
   * @returns {Object} Merged settings config
   */
  get settings_config() {
    return {};
  }
  /**
   * (Optional) An array of request adapter classes. SmartCompletion items will invoke these
   * in `run_completion_adapters()`. For example, we can list the context adapter or other custom ones.
   */
  get completion_adapters() {
    if (!this._completion_adapters) {
      this._completion_adapters = {};
      Object.values(this.opts.completion_adapters).forEach((adapter) => {
        this._completion_adapters[adapter.property_name] = adapter;
      });
    }
    return this._completion_adapters;
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-utils/create_hash.js
function murmur_hash_322(input_string, seed = 0) {
  let remainder = input_string.length & 3;
  let bytes = input_string.length - remainder;
  let h1 = seed;
  let c1 = 3432918353;
  let c2 = 461845907;
  let i = 0;
  let k1 = 0;
  let chunk = 0;
  while (i < bytes) {
    chunk = input_string.charCodeAt(i) & 255 | (input_string.charCodeAt(i + 1) & 255) << 8 | (input_string.charCodeAt(i + 2) & 255) << 16 | (input_string.charCodeAt(i + 3) & 255) << 24;
    i += 4;
    k1 = chunk;
    k1 = multiply_322(k1, c1);
    k1 = rotate_left_322(k1, 15);
    k1 = multiply_322(k1, c2);
    h1 ^= k1;
    h1 = rotate_left_322(h1, 13);
    h1 = h1 * 5 + 3864292196 | 0;
  }
  k1 = 0;
  switch (remainder) {
    case 3:
      k1 ^= (input_string.charCodeAt(i + 2) & 255) << 16;
    // falls through
    case 2:
      k1 ^= (input_string.charCodeAt(i + 1) & 255) << 8;
    // falls through
    case 1:
      k1 ^= input_string.charCodeAt(i) & 255;
      k1 = multiply_322(k1, c1);
      k1 = rotate_left_322(k1, 15);
      k1 = multiply_322(k1, c2);
      h1 ^= k1;
      break;
  }
  h1 ^= input_string.length;
  h1 = fmix_322(h1);
  return h1 | 0;
}
function murmur_hash_32_alphanumeric2(input_string, seed = 0) {
  const signed_hash = murmur_hash_322(input_string, seed);
  const unsigned_hash = signed_hash >>> 0;
  return unsigned_hash.toString(36);
}
function multiply_322(a, b) {
  return (a & 65535) * b + ((a >>> 16) * b << 16) | 0;
}
function rotate_left_322(value, shift) {
  return value << shift | value >>> 32 - shift;
}
function fmix_322(h) {
  h ^= h >>> 16;
  h = multiply_322(h, 2246822507);
  h ^= h >>> 13;
  h = multiply_322(h, 3266489909);
  h ^= h >>> 16;
  return h | 0;
}

// node_modules/smart-chat-obsidian/node_modules/smart-utils/coerce_primitives.js
function coerce_primitives2(value) {
  if (typeof value !== "string") {
    return value;
  }
  const trimmed_value = value.trim();
  if (trimmed_value === "true") {
    return true;
  }
  if (trimmed_value === "false") {
    return false;
  }
  const float_pattern = /^-?\d+\.\d+$/;
  if (float_pattern.test(trimmed_value)) {
    const num = parseFloat(trimmed_value);
    if (num.toString() === trimmed_value) {
      return num;
    }
  }
  const int_pattern = /^-?(?:0|[1-9]\d*)$/;
  if (int_pattern.test(trimmed_value)) {
    return Number(trimmed_value);
  }
  return value;
}

// node_modules/smart-chat-obsidian/node_modules/smart-utils/parse_xml_fragments.js
function parse_xml_fragments2(xml_input) {
  if (typeof xml_input !== "string" || xml_input.trim() === "") {
    return null;
  }
  const VERBATIM_TAGS = /* @__PURE__ */ new Set(["think"]);
  const compress_whitespace = (str) => str.replace(/\s+/g, " ").trim();
  const parse_attributes = (str) => {
    if (!str) return {};
    const attrs = {};
    const attr_re = /(\w[\w.\-]*)\s*=\s*"([^"]*)"/g;
    let m;
    while ((m = attr_re.exec(str)) !== null) {
      const [, key, raw_val] = m;
      attrs[key] = coerce_primitives2(raw_val);
    }
    return attrs;
  };
  const attach_child = (map, tag, node) => {
    if (tag in map) {
      const existing = map[tag];
      map[tag] = Array.isArray(existing) ? [...existing, node] : [existing, node];
    } else {
      map[tag] = node;
    }
  };
  const finalize_node = (ctx) => {
    const text_raw = ctx.verbatim ? ctx.text.replace(/^\s*\n/, "").replace(/\s+$/, "") : compress_whitespace(ctx.text);
    if (Object.keys(ctx.children_map).length) {
      ctx.node.contents = ctx.children_map;
    } else if (text_raw !== "") {
      ctx.node.contents = ctx.verbatim ? text_raw : coerce_primitives2(text_raw);
    } else {
      ctx.node.contents = null;
    }
  };
  const cleaned = xml_input.replace(/<!--[\s\S]*?-->/g, "");
  const token_re = /<[^>]+>|[^<]+/g;
  const root_map = {};
  const stack = [];
  let match;
  while ((match = token_re.exec(cleaned)) !== null) {
    const token = match[0];
    if (stack.length) {
      const top = stack[stack.length - 1];
      if (top.verbatim) {
        if (token.startsWith(`</${top.tag_name}`)) {
          stack.pop();
          finalize_node(top);
          if (stack.length === 0) {
            attach_child(root_map, top.tag_name, top.node);
          } else {
            attach_child(stack[stack.length - 1].children_map, top.tag_name, top.node);
          }
          continue;
        }
        top.text += token;
        continue;
      }
    }
    if (token.startsWith("<")) {
      if (token.startsWith("</")) {
        const tag_name = token.slice(2, -1).trim();
        if (!stack.length) return null;
        const ctx = stack.pop();
        if (ctx.tag_name !== tag_name) return null;
        finalize_node(ctx);
        if (stack.length === 0) {
          attach_child(root_map, tag_name, ctx.node);
        } else {
          attach_child(stack[stack.length - 1].children_map, tag_name, ctx.node);
        }
      } else {
        const self_closing = token.endsWith("/>");
        const body = self_closing ? token.slice(1, -2) : token.slice(1, -1);
        const first_space = body.indexOf(" ");
        const tag_name = first_space === -1 ? body : body.slice(0, first_space);
        const attr_str = first_space === -1 ? "" : body.slice(first_space + 1);
        const attributes = parse_attributes(attr_str);
        const node = Object.keys(attributes).length ? { attributes } : {};
        if (self_closing) {
          node.contents = null;
          if (stack.length === 0) {
            attach_child(root_map, tag_name, node);
          } else {
            attach_child(stack[stack.length - 1].children_map, tag_name, node);
          }
        } else {
          stack.push({
            tag_name,
            node,
            text: "",
            children_map: {},
            verbatim: VERBATIM_TAGS.has(tag_name)
          });
        }
      }
    } else {
      if (stack.length) stack[stack.length - 1].text += token;
    }
  }
  while (stack.length) {
    const ctx = stack.pop();
    finalize_node(ctx);
    if (stack.length === 0) {
      attach_child(root_map, ctx.tag_name, ctx.node);
    } else {
      attach_child(stack[stack.length - 1].children_map, ctx.tag_name, ctx.node);
    }
  }
  return Object.keys(root_map).length ? root_map : null;
}

// node_modules/smart-chat-obsidian/node_modules/smart-completions/smart_completion.js
var SmartCompletion2 = class extends CollectionItem3 {
  constructor(env, data = null) {
    super(env, data);
    this.run_adapter_item_constructors();
  }
  run_adapter_item_constructors() {
    for (const [key, AdapterClass] of Object.entries(this.completion_adapters)) {
      AdapterClass.item_constructor?.(this);
    }
  }
  /**
   * Default data structure for a new SmartCompletion item.
   * @static
   * @returns {Object}
   */
  static get defaults() {
    return {
      data: {
        completion: {
          request: {},
          responses: [],
          chat_model: null
        }
      }
    };
  }
  /**
   * get_key
   * Overridden to produce a unique key based on a hash of this.data plus the current timestamp.
   * @returns {string}
   */
  get_key() {
    const hash = murmur_hash_32_alphanumeric2(JSON.stringify(this.data));
    const ts = Date.now();
    return `${hash}-${ts}`;
  }
  /**
   * Called automatically in many cases (via create_or_update).
   * You can also call it manually if needed.
   */
  async init(completion_opts = {}) {
    if (this.data.chat_model_config) {
      this.chat_model = this.env.init_module("smart_chat_model", {
        settings: this.data.chat_model_config
      });
    }
    await this.build_request();
    await this.complete(completion_opts);
    await this.parse_response();
    this.queue_save();
    this.collection.process_save_queue();
  }
  /**
   * Collects or transforms data into a final `completion.request` structure
   * by running any applicable completion adapters.
   * @returns {Promise<void>}
   */
  async build_request() {
    this.data.completion.request = {};
    const adapters = Object.entries(this.completion_adapters).map(([key, AdapterClass]) => ({
      key,
      AdapterClass,
      order: AdapterClass.order ?? 0
    })).sort((a, b) => a.order - b.order);
    for (const { AdapterClass, key } of adapters) {
      const property = AdapterClass.property_name;
      if (property && this.data[property]) {
        const adapter = new AdapterClass(this);
        await adapter.to_request?.();
      }
    }
    return this.data.completion.request;
  }
  async parse_response() {
    const data_keys = Object.keys(this.data);
    for (const key of data_keys) {
      const AdapterClass = this.completion_adapters[key];
      if (AdapterClass) {
        const adapter = new AdapterClass(this);
        await adapter.from_response?.();
      }
    }
    return this.data.completion.responses;
  }
  /**
   * Calls the underlying chat model, stores the response in completion.responses.
   * @returns {Promise<void>}
   */
  async complete(opts = {}) {
    if (!this.data.completion || !this.data.completion.request) {
      console.warn("No completion.request found, skipping complete().");
      return;
    }
    const chat_model = this.get_chat_model(opts);
    this.data.completion.chat_model = {
      model_key: chat_model.model_key,
      platform_key: chat_model.adapter_name
    };
    if (!chat_model) {
      console.warn("No chat model available for SmartCompletion. Check environment config.");
      return;
    }
    try {
      const request_payload = this.data.completion.request;
      const stream = opts.stream;
      const result = stream ? await chat_model.stream(request_payload, this.stream_handlers(opts.stream_handlers)) : await chat_model.complete(request_payload);
      if (!stream) {
        this.data.completion.responses.push({
          timestamp: Date.now(),
          ...result
        });
      }
      const typing_indicator = this.container?.closest(".smart-chat-thread")?.querySelector(".smart-chat-typing-indicator");
      if (typing_indicator) typing_indicator.style.display = "none";
      this.queue_save();
    } catch (err) {
      console.error("Error in SmartCompletion.complete():", err);
    }
  }
  stream_handlers(stream_handlers = {}) {
    return {
      chunk: async (resp) => {
        this.data.completion.responses[0] = {
          timestamp: Date.now(),
          ...resp
        };
        await stream_handlers.chunk?.(this);
      },
      done: async (resp) => {
        this.data.completion.responses[0] = {
          timestamp: Date.now(),
          ...resp
        };
        await stream_handlers.done?.(this);
      },
      error: async (err) => {
        console.error("error", err);
        await stream_handlers.error?.(err);
      }
    };
  }
  /**
   * Access the completion adapters from the parent collection, if any.
   */
  get completion_adapters() {
    return this.collection?.completion_adapters || {};
  }
  /**
   * If a local chat_model config is present, creates a dedicated instance.
   * Otherwise, returns the collection-level chat_model or null.
   * @returns {Object|null}
   */
  get_chat_model() {
    if (this.chat_model) {
      return this.chat_model;
    } else {
      console.log("no chat_model, using collection chat_model");
      return this.collection?.chat_model || null;
    }
  }
  get response() {
    return this.data.completion.responses[0];
  }
  /**
   * @method response_text
   * @returns {string} The best guess at the main text from the model's first response.
   */
  get response_text() {
    const resp = this.data?.completion?.responses[0];
    if (!resp) return "";
    if (Array.isArray(resp.choices) && resp.choices[0]) {
      const choice = resp.choices[0];
      if (choice.message && choice.message.content) {
        return choice.message.content;
      }
      if (choice.text) return choice.text;
    }
    if (resp.text) return resp.text;
    return "";
  }
  get response_structured_output() {
    if (!this.response) return null;
    if (this.action_call) {
      try {
        const parsed2 = JSON.parse(this.action_call);
        return parsed2;
      } catch (e) {
        console.log("failed to parse tool_call in response_structured_output");
      }
    }
    if (!this.response_text) return null;
    const parsed = parse_xml_fragments2(this.response_text);
    if (!parsed) return null;
    return parsed;
  }
  get action_call() {
    const resp = this.response;
    if (!resp) return null;
    return resp.choices?.[0]?.message?.tool_calls?.[0]?.function?.arguments;
  }
  get messages() {
    const messages = [];
    if (this.data.system_message) {
      messages.push({
        role: "system",
        content: this.data.system_message
      });
    }
    if (this.data.user_message) {
      messages.push({
        role: "user",
        content: this.data.user_message
      });
    }
    if (this.response_text) {
      messages.push({
        role: "assistant",
        content: this.response_text
      });
    }
    return messages;
  }
  get is_completed() {
    return this.data.completion.responses.length > 0;
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-completions/utils/insert_user_message.js
function insert_user_message2(request, user_message, opts = {}) {
  if (!user_message) return;
  const { position = "end", new_user_message = false } = opts;
  if (!request.messages) {
    request.messages = [];
  }
  const last_user_index = request.messages.findLastIndex((x) => x.role === "user");
  if (last_user_index === -1 || new_user_message) {
    const new_user_message2 = {
      role: "user",
      content: [{ type: "text", text: user_message }]
    };
    request.messages.push(new_user_message2);
    return;
  }
  const last_user_message = request.messages[last_user_index];
  if (!Array.isArray(last_user_message.content)) {
    last_user_message.content = [
      {
        type: "text",
        text: last_user_message.content
      }
    ];
  }
  if (position === "start") {
    last_user_message.content.unshift({
      type: "text",
      text: user_message
    });
  } else {
    last_user_message.content.push({
      type: "text",
      text: user_message
    });
  }
}

// node_modules/smart-chat-obsidian/node_modules/smart-completions/adapters/_adapter.js
var SmartCompletionAdapter2 = class {
  constructor(item) {
    this.item = item;
  }
  get data() {
    return this.item.data;
  }
  get env() {
    return this.item.env;
  }
  get completion() {
    return this.data.completion;
  }
  get request() {
    return this.item.data.completion.request;
  }
  get response() {
    return this.item.response;
  }
  insert_user_message(user_message, opts = {}) {
    insert_user_message2(this.request, user_message, opts);
  }
  // Override these methods in subclasses
  static get property_name() {
    return null;
  }
  /**
   * @returns {Promise<void>}
   */
  async to_request() {
  }
  /**
   * @returns {Promise<void>}
   */
  async from_response() {
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-completions/utils/insert_image.js
async function insert_image2(request, image_path, fs) {
  const base64_image = await convert_image_to_base642(fs, image_path);
  if (!base64_image) return;
  const last_user_index = request.messages.findLastIndex((x) => x.role === "user");
  const image_content = {
    role: "user",
    content: [{ type: "image_url", image_url: { url: base64_image } }]
  };
  if (last_user_index === -1) {
    request.messages.unshift(image_content);
  }
  const last_user_message = request.messages[last_user_index];
  if (!last_user_message) return console.warn("insert_image: no last_user_message");
  if (!Array.isArray(last_user_message.content)) {
    last_user_message.content = [];
  }
  last_user_message.content.push(image_content.content[0]);
}
async function convert_image_to_base642(fs, image_path) {
  if (!image_path) return;
  const image_exts = ["png", "jpg", "jpeg", "gif", "webp", "svg", "bmp", "ico"];
  const ext = image_path.split(".").pop().toLowerCase();
  if (!image_exts.includes(ext)) return;
  try {
    const base64_data = await fs.read(image_path, "base64");
    const base64_url = `data:image/${ext};base64,${base64_data}`;
    return base64_url;
  } catch (err) {
    console.warn(`Failed to convert image ${image_path} to base64`, err);
  }
}

// node_modules/smart-chat-obsidian/node_modules/smart-completions/utils/insert_pdf.js
async function insert_pdf2(request, pdf_path, fs) {
  const base64_pdf = await convert_pdf_to_base642(fs, pdf_path);
  if (!base64_pdf) return;
  const last_user_index = request.messages.findLastIndex((x) => x.role === "user");
  const pdf_content = {
    role: "user",
    content: [{
      type: "file",
      file: {
        filename: pdf_path.split(/[\\/]/).pop(),
        file_data: `data:application/pdf;base64,${base64_pdf}`
        // <-- Prefix added
      }
    }]
  };
  if (last_user_index === -1) {
    request.messages.unshift(pdf_content);
    return;
  }
  const last_user_message = request.messages[last_user_index];
  if (!last_user_message) return console.warn("insert_pdf: no last_user_message");
  if (!Array.isArray(last_user_message.content)) {
    last_user_message.content = [];
  }
  last_user_message.content.push(pdf_content.content[0]);
}
async function convert_pdf_to_base642(fs, pdf_path) {
  if (!pdf_path) return;
  const ext = pdf_path.split(".").pop().toLowerCase();
  if (ext !== "pdf") return;
  try {
    const base64_data = await fs.read(pdf_path, "base64");
    return base64_data;
  } catch (err) {
    console.warn(`Failed to convert PDF ${pdf_path} to base64`, err);
  }
}

// node_modules/smart-chat-obsidian/node_modules/smart-completions/adapters/context.js
var SmartCompletionContextAdapter2 = class extends SmartCompletionAdapter2 {
  static order = 10;
  static get property_name() {
    return "context_key";
  }
  async to_request() {
    const context_key = this.data.context_key;
    if (!context_key) return;
    const context_opts = this.data.context_opts;
    const context_collection = this.item.env.smart_contexts;
    if (!context_collection) {
      console.warn("No 'smart_contexts' collection found; skipping context adapter.");
      return;
    }
    const ctx_item = context_collection.get(context_key);
    if (!ctx_item) {
      console.warn(`SmartContext not found for key '${context_key}'`);
      return;
    }
    if (!ctx_item.has_context_items) {
      console.warn(`SmartContext '${context_key}' has no context items; skipping context adapter.`);
      return;
    }
    await ctx_item.save();
    let compiled;
    try {
      compiled = await ctx_item.compile(context_opts);
    } catch (err) {
      console.warn("Error compiling ephemeral context", err);
      return;
    }
    if (compiled.context) {
      this.insert_user_message(compiled.context);
      if (this.data.user_message) {
        this.insert_user_message(this.data.user_message, { position: "end" });
      }
    }
    if (compiled.images?.length > 0) {
      await this.insert_images(compiled.images);
    }
    if (compiled.pdfs?.length > 0) {
      await this.insert_pdfs(compiled.pdfs);
    }
  }
  async insert_images(image_paths) {
    if (!Array.isArray(image_paths) || !image_paths.length) return;
    for (const img_path of image_paths) {
      await insert_image2(this.request, img_path, this.item.env.fs);
    }
  }
  async insert_pdfs(pdf_paths) {
    if (!Array.isArray(pdf_paths) || !pdf_paths.length) return;
    for (const pdf_path of pdf_paths) {
      await insert_pdf2(this.request, pdf_path, this.item.env.fs);
    }
  }
  /**
   * No special post-processing after we get model response.
   */
  async from_response() {
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-completions/adapters/user.js
var SmartCompletionUserAdapter2 = class extends SmartCompletionAdapter2 {
  static order = 1;
  /**
   * @returns {string}
   */
  static get property_name() {
    return "user_message";
  }
  get request() {
    return this.item.data.completion.request;
  }
  /**
   * to_request: Checks `data.user`, adds a user message to `request.messages`.
   * @returns {Promise<void>}
   */
  async to_request() {
    const user_message = this.data.user_message;
    const new_user_message = this.data.new_user_message;
    this.insert_user_message(user_message, {
      position: "start",
      // always at start so that other adapters may add again to end (e.g. context adapter)
      new_user_message
    });
  }
  /**
   * from_response: No post-processing needed for default user message.
   * @returns {Promise<void>}
   */
  async from_response() {
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-completions/adapters/action.js
var ActionCompletionAdapter2 = class extends SmartCompletionAdapter2 {
  static get property_name() {
    return "action_key";
  }
  /**
   * @returns {Promise<void>}
   */
  async to_request() {
    const action_key = this.data.action_key;
    if (!action_key) return;
    const thread = this.item.thread;
    if (thread && thread.current_completion !== this.item) return console.log("ActionCompletionAdapter: skipping tools, not the current completion");
    const action_opts = this.data.action_opts;
    const action_collection = this.item.env.smart_actions;
    if (!action_collection) {
      console.warn("No 'smart_actions' collection found; skipping action adapter.");
      return;
    }
    const action_item = action_collection.get(action_key);
    if (!action_item) {
      console.warn(`SmartAction not found for key '${action_key}'`);
      return;
    }
    let tools;
    try {
      const tool2 = action_item.as_tool;
      tools = tool2 ? [tool2] : [];
    } catch (err) {
      console.warn("Error generating action tool", err);
      return;
    }
    if (!tools.length) return;
    if (!this.data.actions) this.data.actions = {};
    this.data.actions[action_key] = true;
    this.insert_tools(tools, { force: true });
  }
  get default_action_params() {
    return this.data.action_opts || {};
  }
  /**
   * @returns {Promise<void>}
   */
  async from_response() {
    console.log("ActionCompletionAdapter: from_response");
    const tool_call = this.response.choices[0].message?.tool_calls?.[0];
    if (!tool_call) return console.warn("No tool call found in response");
    const action_key = tool_call?.function?.name;
    const tool_arguments = tool_call?.function?.arguments;
    if (!action_key) return;
    const action_collection = this.item.env.smart_actions;
    if (!action_collection) return;
    const action_item = action_collection.get(action_key);
    if (!action_item) return;
    let parsed_args = tool_arguments;
    if (typeof parsed_args === "string") {
      try {
        parsed_args = JSON.parse(parsed_args);
      } catch (err) {
        console.warn("Could not parse tool_call arguments", err);
        return;
      }
    }
    const action_params = {
      ...this.default_action_params,
      ...parsed_args
    };
    const result = await action_item.run_action(action_params);
    if (result && typeof result === "object" && result.final) {
      if (!this.item.data.completion.responses[0]) {
        this.item.data.completion.responses[0] = { choices: [{ message: {} }] };
      } else if (!this.item.data.completion.responses[0].choices?.[0]) {
        this.item.data.completion.responses[0].choices = [{ message: {} }];
      }
      this.item.data.completion.responses[0].choices[0].message = {
        ...this.item.data.completion.responses[0].choices[0].message,
        role: "assistant",
        content: result.final
      };
    }
    if (!this.data.actions) this.data.actions = {};
    this.data.actions[action_key] = result;
  }
  /**
   * Insert the ephemeral tools into the request
   * @param {Array<object>} tools
   * @param {object} opts
   * @returns {void}
   */
  insert_tools(tools, opts = {}) {
    this.request.tools = tools;
    if (opts.force) {
      this.request.tool_choice = {
        type: "function",
        function: {
          name: tools[0].function.name
        }
      };
    }
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-completions/adapters/action_xml.js
function scaffold_xml2(root_tag, root_desc, params) {
  return [
    `<${root_tag} instructions="${root_desc}">`,
    ...Object.entries(params).map(
      ([p, v]) => `  <${p} instructions="${v.description || ""}">VALUE</${p}>`
    ),
    `</${root_tag}>`
  ].join("\n");
}
function strip_instruction_attrs2(xml) {
  return xml.replace(/\s+instructions="[^"]*"/g, "");
}
var ActionXmlCompletionAdapter2 = class extends ActionCompletionAdapter2 {
  static get property_name() {
    return "action_xml_key";
  }
  /* ────────────────────────────────────────────────────────────────────────
     REQUEST CONSTRUCTION
     ────────────────────────────────────────────────────────────────────── */
  async to_request() {
    const action_key = this.data.action_xml_key;
    if (!action_key) return;
    const thread = this.item.thread;
    if (thread.current_completion !== this.item) return console.log("ActionXmlCompletionAdapter: skipping tools, not the current completion");
    const action_item = this.env.smart_actions?.get(action_key);
    if (!action_item) {
      return console.warn(`SmartAction '${action_key}' not found`);
    }
    let tools;
    try {
      const tool2 = action_item.as_tool;
      tools = tool2 ? [tool2] : [];
    } catch (err) {
      return console.warn("Unable to compile OpenAPI \u2192 tools", err);
    }
    if (!tools.length) return;
    const func_def = tools[0].function;
    const param_props = func_def.parameters?.properties || {};
    const required_params = func_def.parameters?.required || [];
    this._func_name = func_def.name;
    this._required_params = required_params;
    const action_instruction = [
      "Important Instructions:",
      `1. You must invoke the action '${func_def.name}' exactly once.`,
      "2. You must respond *only* with XML in the exact structure provided below.",
      "3. Replace VALUE with real arguments based on the property-specific instructions below.",
      "4. Do not include any other text or instructions.",
      "5. Follow these property-specific instructions for producing the XML response.",
      "Action Instructions:",
      `- ${func_def.description || ""}`,
      "Property-Specific Instructions:",
      ...Object.entries(param_props).map(
        ([p, v]) => `- ${p}: ${v.description || ""}`
      )
    ].join("\n");
    const xml_scaffold = scaffold_xml2(func_def.name, func_def.description, param_props);
    const xml_template = strip_instruction_attrs2(xml_scaffold);
    const action_instruction_msg = [
      action_instruction,
      `You are ready to invoke the action '${func_def.name}'.`
    ].join("\n");
    const xml_template_msg = [
      `To invoke the action '${func_def.name}', respond *only* with XML in this exact structure (replace VALUE with real arguments based on the action and property-specific instructions above):`,
      xml_template
    ].join("\n");
    this.insert_user_message(action_instruction_msg);
    this.insert_user_message(xml_template_msg);
    this.data.actions ??= {};
    this.data.actions[action_key] = true;
    this.data.action_key = action_key;
  }
  /* ────────────────────────────────────────────────────────────────────────
     RESPONSE PARSING
     ────────────────────────────────────────────────────────────────────── */
  async from_response() {
    const action_key = this.data.action_xml_key;
    if (!action_key) return;
    const assistant_msg = this.response?.choices?.[0]?.message;
    if (!assistant_msg) {
      return console.warn("ActionXmlCompletionAdapter: assistant message not found");
    }
    const func_name = this._func_name || action_key;
    let parsed_xml = this.item?.response_structured_output;
    let root_node = parsed_xml[func_name];
    if (!root_node) {
      const candidate = Object.keys(parsed_xml)[0];
      console.warn(`ActionXmlCompletionAdapter: expected root <${func_name}>, found <${candidate}> \u2013 using candidate`);
      root_node = parsed_xml[candidate];
    }
    if (!root_node) {
      return console.warn(`ActionXmlCompletionAdapter: root tag '${func_name}' not found`);
    }
    const node_to_value = (node) => {
      if (!node || typeof node !== "object") return node;
      const { attributes = {}, contents } = node;
      if (contents === null || typeof contents !== "object") {
        return Object.keys(attributes).length ? { ...attributes, value: contents } : contents;
      }
      const out = {};
      for (const [k, v] of Object.entries(contents)) {
        out[k] = Array.isArray(v) ? v.map(node_to_value) : node_to_value(v);
      }
      return Object.keys(attributes).length ? { ...attributes, ...out } : out;
    };
    const args = node_to_value(root_node);
    const missing = (this._required_params || []).filter(
      (p) => args[p] === void 0 || args[p] === "" || args[p] === null
    );
    if (missing.length) {
      return console.warn(`ActionXmlCompletionAdapter: missing ${missing.join(", ")}`);
    }
    assistant_msg.tool_calls = [
      { function: { name: action_key, arguments: args } }
    ];
    delete assistant_msg.content;
    await super.from_response();
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-completions/adapters/system.js
var SmartCompletionSystemAdapter2 = class extends SmartCompletionAdapter2 {
  /**
   * Identifies the data property that triggers this adapter.
   * @returns {string}
   */
  static get property_name() {
    return "system_message";
  }
  /**
   * to_request: If `data.system_message` is present, prepends a system message to request.messages.
   * @returns {Promise<void>}
   */
  async to_request() {
    const sys_msg = this.data.system_message;
    if (!sys_msg) return;
    if (!this.request.messages) {
      this.request.messages = [];
    }
    this.request.messages.unshift({
      role: "system",
      content: sys_msg
    });
  }
  /**
   * from_response: No post-processing needed here.
   * @returns {Promise<void>}
   */
  async from_response() {
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-completions/index.js
var smart_completions_default_config2 = {
  class: SmartCompletions2,
  data_adapter: AjsonSingleFileCollectionDataAdapter2,
  item_type: SmartCompletion2,
  completion_adapters: {
    // SmartCompletionTemplateAdapter,
    SmartCompletionContextAdapter: SmartCompletionContextAdapter2,
    SmartCompletionUserAdapter: SmartCompletionUserAdapter2,
    ActionCompletionAdapter: ActionCompletionAdapter2,
    ActionXmlCompletionAdapter: ActionXmlCompletionAdapter2,
    SmartCompletionSystemAdapter: SmartCompletionSystemAdapter2
  }
};

// node_modules/smart-chat-obsidian/src/adapters/smart-completions/thread.js
var ThreadCompletionAdapter = class extends SmartCompletionAdapter2 {
  static order = -1;
  /**
   * @returns {string}
   */
  static get property_name() {
    return "thread_key";
  }
  static item_constructor(completion) {
    Object.defineProperty(completion, "thread", {
      get() {
        const thread_key = completion.data.thread_key;
        if (!thread_key) return null;
        return completion.env.smart_chat_threads.get(thread_key);
      }
    });
  }
  /**
   * to_request: Appends messages from the referenced thread.
   * @returns {Promise<void>}
   */
  async to_request() {
    const thread_key = this.data.thread_key;
    if (!thread_key) return;
    const thread = this.item.thread;
    if (thread.current_completion !== this.item) return console.log("ThreadCompletionAdapter: skipping thread, not the current completion");
    const thread_collection = this.item.env.smart_chat_threads;
    if (!thread_collection) {
      console.warn("No 'smart_chat_threads' collection found in environment; skipping thread adapter.");
      return;
    }
    const thread_item = thread_collection.get(thread_key);
    if (!thread_item || !Array.isArray(thread_item.messages)) {
      console.warn(`Thread item '${thread_key}' not found or missing .data.messages array`);
      return;
    }
    if (!this.request.messages) {
      this.request.messages = [];
    }
    const prior_completions = thread_item.completions.slice(0, -1);
    for (let i = 0; i < prior_completions.length; i++) {
      const prior_completion = prior_completions[i];
      this.request.messages.push(...(await prior_completion.build_request()).messages || []);
      this.request.messages.push({ role: "assistant", content: prior_completion.response_text });
    }
    const seen = /* @__PURE__ */ new Set();
    this.request.messages = this.request.messages.filter((msg) => {
      const contentKey = Array.isArray(msg.content) ? JSON.stringify(msg.content) : msg.content;
      if (seen.has(contentKey)) return false;
      seen.add(contentKey);
      return true;
    });
  }
  /**
   * from_response: No post-processing needed for thread.
   * @returns {Promise<void>}
   */
  async from_response() {
    const thread = this.item.thread;
    if (!thread) return console.warn("No thread found");
    setTimeout(() => {
      thread.queue_save();
      thread.collection.process_save_queue();
    }, 1e3);
  }
};

// node_modules/smart-chat-obsidian/src/collections/smart_completions.js
smart_completions_default_config2.completion_adapters["ThreadCompletionAdapter"] = ThreadCompletionAdapter;
var smart_completions_default = smart_completions_default_config2;

// node_modules/smart-chat-obsidian/node_modules/smart-contexts/smart_contexts.js
var SmartContexts = class extends Collection3 {
  static version = 0.1;
  /**
   * new_context
   * @param {object} data
   * @param {object} opts
   * @param {string[]} opts.add_items
   * @returns {SmartContext}
   */
  new_context(data = {}, opts = {}) {
    const item = new this.item_type(this.env, data);
    if (Array.isArray(opts.add_items)) item.add_items(opts.add_items);
    this.set(item);
    item.queue_save();
    return item;
  }
  /**
   * Default settings for all SmartContext items in this collection.
   * @readonly
   */
  get default_settings() {
    return {
      link_depth: 0,
      inlinks: false,
      follow_links_in_excluded: true,
      // NEW: toggle whether to follow outlinks from excluded headings
      excluded_headings: [],
      max_len: 0,
      // 0 => no enforced limit
      templates: {
        "-1": {
          before: `<context>
<file_tree>
{{FILE_TREE}}
</file_tree>`,
          after: `</context>`
        },
        "0": {
          before: `<context_primary path="{{ITEM_PATH}}" mtime="{{ITEM_TIME_AGO}}">`,
          after: `</context_primary>`
        },
        "1": {
          before: `<context_linked path="{{ITEM_PATH}}" mtime="{{ITEM_TIME_AGO}}">`,
          after: `</context_linked>`
        }
      }
    };
  }
  get compile_adapters() {
    if (!this._compile_adapters) {
      this._compile_adapters = {};
      Object.values(this.opts.compile_adapters || {}).forEach((cls) => {
        this._compile_adapters[cls.adapter_key] = cls;
      });
    }
    return this._compile_adapters;
  }
  get settings_config() {
    return {
      inlinks: {
        name: "In-links",
        description: "Include inbound links from other items?",
        type: "toggle"
      },
      excluded_headings: {
        name: "Excluded headings",
        description: "Headings/patterns to exclude; use newline to separate multiple patterns. Case-sensitive",
        type: "textarea_array"
      },
      follow_links_in_excluded: {
        name: "Follow links in excluded headings?",
        description: "If off, any links found inside excluded heading sections are ignored (not followed).",
        type: "toggle"
      },
      context_explanation: {
        type: "html",
        value: `
          <div class="setting-explanation">
            <h5>Context templates</h5>
            <span>Included once in the final output at the beginning (before_context) and end (after_context).</span>
            <br>
            <br>
            <span>Available variables:</span>
            <ul>
              <li><code>{{FILE_TREE}}</code> - Shows hierarchical view of all files</li>
            </ul>
          </div>
        `
      },
      before_context: {
        setting: "templates.-1.before",
        name: "Before context",
        description: "Text inserted at the top of the final output.",
        type: "textarea"
      },
      after_context: {
        setting: "templates.-1.after",
        name: "After context",
        description: "Text inserted at the bottom of the final output.",
        type: "textarea"
      },
      item_explanation: {
        type: "html",
        value: `
          <div class="setting-explanation">
            <h5>Item templates</h5>
            <span>Included once for each item (before_item and after_item).</span>
            <br>
            <br>
            <span>Available variables:</span>
            <ul>
              <li><code>{{ITEM_PATH}}</code> - Full path of the item</li>
              <li><code>{{ITEM_NAME}}</code> - Filename of the item</li>
              <li><code>{{ITEM_EXT}}</code> - File extension</li>
              <li><code>{{ITEM_DEPTH}}</code> - Depth level of the item</li>
              <li><code>{{ITEM_TIME_AGO}}</code> - Time since the item was last modified</li>
            </ul>
          </div>
        `
      },
      before_item: {
        setting: "templates.0.before",
        name: "Before each primary item",
        description: "Text inserted before each depth=0 item.",
        type: "textarea"
      },
      after_item: {
        setting: "templates.0.after",
        name: "After each primary item",
        description: "Text inserted after each depth=0 item.",
        type: "textarea"
      },
      link_explanation: {
        type: "html",
        value: `
          <div class="setting-explanation">
            <h5>Link templates</h5>
            <span>Inserted before/after each link-based item (depth=1,2,...). 
                  Typically used to separate these items from the primary content.
                  <i>Note: links are treated similar to items but are aggregated after all items.</i>
            </span>
            <br>
            <br>
            <span>Available variables:</span>
            <ul>
              <li><code>{{ITEM_PATH}}</code> - Full path of the linked file</li>
              <li><code>{{ITEM_NAME}}</code> - Filename of the linked file</li>
              <li><code>{{ITEM_EXT}}</code> - File extension</li>
              <li><code>{{ITEM_DEPTH}}</code> - Depth level of the link</li>
              <li><code>{{ITEM_TIME_AGO}}</code> - Time since the linked file was last modified</li>
            </ul>
          </div>
        `
      },
      before_link: {
        setting: "templates.1.before",
        name: "Before link item",
        description: "Text inserted before each depth=1 link item.",
        type: "textarea"
      },
      after_link: {
        setting: "templates.1.after",
        name: "After link item",
        description: "Text inserted after each depth=1 link item.",
        type: "textarea"
      }
    };
  }
  get_ref(key) {
    const collection = key.includes("#") ? this.env.smart_blocks : this.env.smart_sources;
    return collection.get(key);
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-contexts/utils/get_snapshot.js
async function get_snapshot(ctx, opts = {}) {
  const snapshot = {
    items: {},
    // depth ⇒ { path ⇒ item }
    truncated_items: [],
    skipped_items: [],
    missing_items: [],
    images: [],
    char_count: opts.items ? Object.values(opts.items).reduce((p, i) => p + i.char_count, 0) : 0
  };
  const seen = new Set(Object.keys(opts.items || {}));
  const keys_at_depth = { 0: ctx.get_item_keys_by_depth(0) };
  const max_depth = opts.link_depth ?? 0;
  for (let depth = 0; depth <= max_depth; depth++) {
    const depth_keys = keys_at_depth[depth] || [];
    if (!depth_keys.length) continue;
    const ctx_items = ctx.get_context_items(depth_keys);
    const curr_depth = snapshot.items[depth] = {};
    for (const item of ctx_items) {
      await item.add_to_snapshot(snapshot, { ...opts, depth });
      seen.add(item.path);
    }
    if (depth !== max_depth) {
      const accumulate = new Set(keys_at_depth[depth + 1] || []);
      for (const context_item of Object.values(curr_depth)) {
        if (!context_item) continue;
        if (opts.inlinks) {
          const inlinks = context_item.inlinks ?? context_item.ref?.inlinks ?? [];
          inlinks.forEach((p) => {
            if (!seen.has(p)) accumulate.add(p);
          });
        }
        const outlinks = context_item.outlinks ?? context_item.ref?.outlinks ?? [];
        outlinks.forEach((p) => {
          if (!seen.has(p)) accumulate.add(p);
        });
      }
      keys_at_depth[depth + 1] = Array.from(accumulate);
    }
  }
  if (opts.items) {
    snapshot.items[0] = { ...snapshot.items[0], ...opts.items };
  }
  return snapshot;
}

// node_modules/smart-chat-obsidian/node_modules/smart-contexts/utils/merge_context_opts.js
function merge_context_opts(context_item, input_opts = {}) {
  const cset = context_item.collection.settings || {};
  const local_opts = context_item.data.context_opts || {};
  const merged_templates = {
    ...cset.templates ? JSON.parse(JSON.stringify(cset.templates)) : {},
    ...local_opts.templates && typeof local_opts.templates === "object" ? local_opts.templates : {},
    ...input_opts.templates && typeof input_opts.templates === "object" ? input_opts.templates : {}
  };
  return {
    ...input_opts,
    link_depth: input_opts.link_depth ?? local_opts.link_depth ?? cset.link_depth ?? 0,
    inlinks: input_opts.inlinks ?? local_opts.inlinks ?? Boolean(cset.inlinks),
    excluded_headings: input_opts.excluded_headings ?? local_opts.excluded_headings ?? (Array.isArray(cset.excluded_headings) ? [...cset.excluded_headings] : []),
    max_len: input_opts.max_len ?? local_opts.max_len ?? cset.max_len ?? 0,
    templates: merged_templates
  };
}

// node_modules/smart-chat-obsidian/node_modules/smart-blocks/parsers/markdown.js
function parse_markdown_blocks3(markdown, opts = {}) {
  const { start_index = 1, line_keys = false } = opts;
  const lines = markdown.split("\n");
  const result = {};
  const heading_stack = [];
  const heading_lines = {};
  const heading_counts = {};
  const sub_block_counts = {};
  const subheading_counts = {};
  let current_list_item = null;
  let current_content_block = null;
  let in_frontmatter = false;
  let frontmatter_started = false;
  const root_heading_key = "#";
  let in_code_block = false;
  sub_block_counts[root_heading_key] = 0;
  for (let i = 0; i < lines.length; i++) {
    const line_number = i + start_index;
    const line = lines[i];
    const trimmed_line = line.trim();
    if (trimmed_line === "---") {
      if (!frontmatter_started) {
        frontmatter_started = true;
        in_frontmatter = true;
        heading_lines["#---frontmatter---"] = [line_number, null];
        continue;
      } else if (in_frontmatter) {
        in_frontmatter = false;
        heading_lines["#---frontmatter---"][1] = line_number;
        continue;
      }
    }
    if (in_frontmatter) {
      continue;
    }
    if (trimmed_line.startsWith("```")) {
      in_code_block = !in_code_block;
      if (!current_content_block) {
        const parent_key = heading_stack.length > 0 ? heading_stack[heading_stack.length - 1].key : root_heading_key;
        if (parent_key === root_heading_key && !heading_lines[root_heading_key]) {
          heading_lines[root_heading_key] = [line_number, null];
        }
        if (parent_key === root_heading_key) {
          current_content_block = { key: root_heading_key, start_line: line_number };
          if (heading_lines[root_heading_key][1] === null || heading_lines[root_heading_key][1] < line_number) {
            heading_lines[root_heading_key][1] = null;
          }
        } else {
          if (sub_block_counts[parent_key] === void 0) {
            sub_block_counts[parent_key] = 0;
          }
          sub_block_counts[parent_key] += 1;
          const n = sub_block_counts[parent_key];
          const key = `${parent_key}#{${n}}`;
          heading_lines[key] = [line_number, null];
          current_content_block = { key, start_line: line_number };
        }
      }
      continue;
    }
    const heading_match = trimmed_line.match(/^(#{1,6})\s*(.+)$/);
    if (heading_match && !in_code_block) {
      const level = heading_match[1].length;
      let title = heading_match[2].trim();
      while (heading_stack.length > 0 && heading_stack[heading_stack.length - 1].level >= level) {
        const finished_heading = heading_stack.pop();
        if (heading_lines[finished_heading.key][1] === null) {
          heading_lines[finished_heading.key][1] = line_number - 1;
        }
      }
      if (heading_stack.length === 0 && heading_lines[root_heading_key] && heading_lines[root_heading_key][1] === null) {
        heading_lines[root_heading_key][1] = line_number - 1;
      }
      if (current_content_block) {
        if (heading_lines[current_content_block.key][1] === null) {
          heading_lines[current_content_block.key][1] = line_number - 1;
        }
        current_content_block = null;
      }
      if (current_list_item) {
        if (heading_lines[current_list_item.key][1] === null) {
          heading_lines[current_list_item.key][1] = line_number - 1;
        }
        current_list_item = null;
      }
      let parent_key = "";
      let parent_level = 0;
      if (heading_stack.length > 0) {
        parent_key = heading_stack[heading_stack.length - 1].key;
        parent_level = heading_stack[heading_stack.length - 1].level;
      } else {
        parent_key = "";
        parent_level = 0;
      }
      if (heading_stack.length === 0) {
        heading_counts[title] = (heading_counts[title] || 0) + 1;
        if (heading_counts[title] > 1) {
          title += `[${heading_counts[title]}]`;
        }
      } else {
        if (!subheading_counts[parent_key]) {
          subheading_counts[parent_key] = {};
        }
        subheading_counts[parent_key][title] = (subheading_counts[parent_key][title] || 0) + 1;
        const count = subheading_counts[parent_key][title];
        if (count > 1) {
          title += `#{${count}}`;
        }
      }
      const level_diff = level - parent_level;
      const hashes = "#".repeat(level_diff);
      const key = parent_key + hashes + title;
      heading_lines[key] = [line_number, null];
      sub_block_counts[key] = 0;
      heading_stack.push({ level, title, key });
      continue;
    }
    const list_match = line.match(/^(\s*)([-*]|\d+\.) (.+)$/);
    if (list_match && !in_code_block) {
      const indentation = list_match[1].length;
      if (indentation === 0) {
        if (current_list_item) {
          if (heading_lines[current_list_item.key][1] === null) {
            heading_lines[current_list_item.key][1] = line_number - 1;
          }
          current_list_item = null;
        }
        if (current_content_block && current_content_block.key !== root_heading_key) {
          if (heading_lines[current_content_block.key][1] === null) {
            heading_lines[current_content_block.key][1] = line_number - 1;
          }
          current_content_block = null;
        }
        let parent_key = heading_stack.length > 0 ? heading_stack[heading_stack.length - 1].key : root_heading_key;
        if (parent_key === root_heading_key && !heading_lines[root_heading_key]) {
          heading_lines[root_heading_key] = [line_number, null];
        }
        if (sub_block_counts[parent_key] === void 0) {
          sub_block_counts[parent_key] = 0;
        }
        sub_block_counts[parent_key] += 1;
        const n = sub_block_counts[parent_key];
        let key;
        if (line_keys) {
          const words = get_longest_words_in_order2(list_match[3], 10);
          key = `${parent_key}#${words}`;
        } else {
          key = `${parent_key}#{${n}}`;
        }
        heading_lines[key] = [line_number, null];
        current_list_item = { key, start_line: line_number };
        continue;
      }
      if (current_list_item) {
        continue;
      }
    }
    if (trimmed_line === "") {
      continue;
    }
    if (!current_content_block) {
      if (current_list_item) {
        if (heading_lines[current_list_item.key][1] === null) {
          heading_lines[current_list_item.key][1] = line_number - 1;
        }
        current_list_item = null;
      }
      let parent_key = heading_stack.length > 0 ? heading_stack[heading_stack.length - 1].key : root_heading_key;
      if (parent_key === root_heading_key) {
        if (!heading_lines[root_heading_key]) {
          heading_lines[root_heading_key] = [line_number, null];
        }
        if (heading_lines[root_heading_key][1] === null || heading_lines[root_heading_key][1] < line_number) {
          heading_lines[root_heading_key][1] = null;
        }
        current_content_block = { key: root_heading_key, start_line: line_number };
      } else {
        if (sub_block_counts[parent_key] === void 0) {
          sub_block_counts[parent_key] = 0;
        }
        sub_block_counts[parent_key] += 1;
        const n = sub_block_counts[parent_key];
        const key = `${parent_key}#{${n}}`;
        heading_lines[key] = [line_number, null];
        current_content_block = { key, start_line: line_number };
      }
    }
  }
  const total_lines = lines.length;
  while (heading_stack.length > 0) {
    const finished_heading = heading_stack.pop();
    if (heading_lines[finished_heading.key][1] === null) {
      heading_lines[finished_heading.key][1] = total_lines + start_index - 1;
    }
  }
  if (current_list_item) {
    if (heading_lines[current_list_item.key][1] === null) {
      heading_lines[current_list_item.key][1] = total_lines + start_index - 1;
    }
    current_list_item = null;
  }
  if (current_content_block) {
    if (heading_lines[current_content_block.key][1] === null) {
      heading_lines[current_content_block.key][1] = total_lines + start_index - 1;
    }
    current_content_block = null;
  }
  if (heading_lines[root_heading_key] && heading_lines[root_heading_key][1] === null) {
    heading_lines[root_heading_key][1] = total_lines + start_index - 1;
  }
  for (const key in heading_lines) {
    result[key] = heading_lines[key];
  }
  return result;
}
function get_longest_words_in_order2(line, n = 3) {
  const words = line.split(/\s+/).sort((a, b) => b.length - a.length).slice(0, n);
  return words.sort((a, b) => line.indexOf(a) - line.indexOf(b)).join(" ");
}

// node_modules/smart-chat-obsidian/node_modules/smart-file-system/utils/glob_to_regex.js
function create_regex3(pattern, { case_sensitive, extended_glob, windows_paths }) {
  const regex_pattern = glob_to_regex_pattern3(pattern, extended_glob);
  const adjusted_pattern = adjust_for_windows_paths3(regex_pattern, windows_paths);
  const flags = case_sensitive ? "" : "i";
  return new RegExp(`^${adjusted_pattern}$`, flags);
}
function adjust_for_windows_paths3(pattern, windows_paths) {
  return windows_paths ? pattern.replace(/\\\//g, "[\\\\/]").replace(/\\\\\\/g, "[\\\\/]") : pattern;
}
function glob_to_regex_pattern3(pattern, extended_glob) {
  let in_class = false;
  let in_brace = 0;
  let result = "";
  for (let i = 0; i < pattern.length; i++) {
    const char = pattern[i];
    switch (char) {
      case "\\":
        if (i + 1 < pattern.length) {
          result += `\\${pattern[i + 1]}`;
          i++;
        } else {
          result += "\\\\";
        }
        break;
      case "/":
        result += "\\/";
        break;
      case "[":
        if (!in_class) {
          const closingIndex = pattern.indexOf("]", i + 1);
          if (closingIndex === -1) {
            result += "\\[";
          } else {
            in_class = true;
            if (pattern[i + 1] === "!") {
              result += "[^";
              i++;
            } else {
              result += "[";
            }
          }
        } else {
          result += "\\[";
        }
        break;
      case "]":
        if (in_class) {
          in_class = false;
          result += "]";
        } else {
          result += "\\]";
        }
        break;
      case "{":
        if (!in_class) {
          const closingIndex = pattern.indexOf("}", i + 1);
          if (closingIndex === -1) {
            result += "\\{";
          } else {
            in_brace++;
            result += "(";
          }
        } else {
          result += "\\{";
        }
        break;
      case "}":
        if (!in_class && in_brace > 0) {
          in_brace--;
          result += ")";
        } else {
          result += "\\}";
        }
        break;
      case ",":
        if (!in_class && in_brace > 0) {
          result += "|";
        } else {
          result += ",";
        }
        break;
      case "*":
        if (!in_class) {
          if (i + 1 < pattern.length && pattern[i + 1] === "*") {
            result += ".*";
            i++;
          } else {
            result += "[^/]*";
          }
        } else {
          result += "\\*";
        }
        break;
      case "?":
        if (!in_class) {
          result += "[^/]";
        } else {
          result += "\\?";
        }
        break;
      // We escape these to ensure they remain literal
      case "(":
      case ")":
      case "+":
      case "|":
      case "^":
      case "$":
      case ".":
        result += `\\${char}`;
        break;
      default:
        result += char;
        break;
    }
  }
  if (in_class) {
    result += "]";
    in_class = false;
  }
  if (extended_glob) {
    result = result.replace(/\\\+\\\((.*?)\\\)/g, "($1)+").replace(/\\\@\\\((.*?)\\\)/g, "($1)").replace(/\\\!\\\((.*?)\\\)/g, "(?!$1).*").replace(/\\\?\\\((.*?)\\\)/g, "($1)?").replace(/\\\*\\\((.*?)\\\)/g, "($1)*");
  }
  return result;
}
function glob_to_regex3(pattern, options = {}) {
  const default_options = {
    case_sensitive: true,
    extended_glob: false,
    windows_paths: false
  };
  const merged_options = { ...default_options, ...options };
  if (pattern === "") {
    return /^$/;
  }
  if (pattern === "*" && !merged_options.windows_paths) {
    return /^[^/]+$/;
  }
  if (pattern === "**" && !merged_options.windows_paths) {
    return /^.+$/;
  }
  return create_regex3(pattern, merged_options);
}

// node_modules/smart-chat-obsidian/node_modules/smart-file-system/utils/match_glob.js
function match_glob(pattern, str, options = {}) {
  const regex = glob_to_regex3(pattern, options);
  return regex.test(str);
}

// node_modules/smart-chat-obsidian/node_modules/smart-contexts/utils/respect_exclusions.js
function normalise_heading(heading) {
  return heading.replace(/\[\d+\]$/, "").replace(/#\{\d+\}$/, "").trim();
}
function strip_excluded_headings(content, excluded_list) {
  const blocks_map = parse_markdown_blocks3(content, { start_index: 0 });
  if (!Object.keys(blocks_map).length) return [content, [], 0];
  const exclusions = [];
  let lines = content.split("\n");
  for (const [block_key, line_range] of Object.entries(blocks_map)) {
    const parts = block_key.split("#").filter(Boolean);
    if (!parts.length) continue;
    const raw_heading = parts[parts.length - 1].trim();
    const heading = normalise_heading(raw_heading);
    for (const pattern of excluded_list) {
      if (match_glob(pattern, heading, { case_sensitive: false })) {
        for (let i = line_range[0]; i <= line_range[1]; i++) {
          lines[i] = null;
        }
        exclusions.push(pattern);
        break;
      }
    }
  }
  lines = lines.filter(Boolean);
  const new_content = lines.join("\n");
  const removed_char_count = content.length - new_content.length;
  return [new_content, exclusions, removed_char_count];
}

// node_modules/smart-chat-obsidian/node_modules/smart-sources/utils/get_markdown_links.js
function get_markdown_links3(content) {
  const result = [];
  const markdown_link_re = /\[([^\]]+?)\]\(([^)]+?)\)/g;
  const wikilink_re = /\[\[([^\|\]]+?)(?:\|([^\]]+?))?\]\]/g;
  const normalise_target = (raw) => {
    const trimmed = raw.trim();
    if (/^[a-zA-Z][\w+\-.]*:\/\//.test(trimmed)) return trimmed;
    try {
      return decodeURIComponent(trimmed);
    } catch (_) {
      return trimmed.replace(/%20/gi, " ");
    }
  };
  let m;
  while ((m = markdown_link_re.exec(content)) !== null) {
    const title = m[1];
    const target = normalise_target(m[2]);
    const line_no = content.slice(0, m.index).split("\n").length;
    result.push({ title, target, line: line_no });
  }
  while ((m = wikilink_re.exec(content)) !== null) {
    const target_raw = m[1];
    const title = m[2] || target_raw;
    const target = normalise_target(target_raw);
    const line_no = content.slice(0, m.index).split("\n").length;
    result.push({ title, target, line: line_no });
  }
  return result.sort(
    (a, b) => a.line - b.line || a.target.localeCompare(b.target)
  );
}

// node_modules/smart-chat-obsidian/node_modules/smart-contexts/context_item.js
var BaseContextItem = class {
  constructor(ctx, key) {
    ctx.env.create_env_getter(this);
    this.ctx = ctx;
    this.key = key;
    const ctx_data = ctx.data?.context_items?.[key];
    if (ctx_data && typeof ctx_data === "object" && "content" in ctx_data) {
      this.content = String(ctx_data.content ?? "");
    }
  }
  get name() {
    return this.path.split("/").pop();
  }
  get path() {
    return this.key;
  }
  /* fallback empty link arrays so link‑depth traversal works */
  get inlinks() {
    return this._inlinks ?? [];
  }
  get outlinks() {
    return this._outlinks ?? [];
  }
  set inlinks(links) {
    this._inlinks = Array.isArray(links) ? links : [];
  }
  set outlinks(links) {
    links = links.map((link) => {
      const link_ref = link?.target || link;
      if (link_ref.startsWith("http")) return null;
      const link_path = this.env.smart_sources.fs.get_link_target_path(link_ref, this.key);
      return link_path;
    }).filter((link_path) => link_path);
    this._outlinks = Array.isArray(links) ? links : [];
  }
  async add_to_snapshot(snapshot, opts = {}) {
    if (typeof this.content !== "string") return;
    this.outlinks = get_markdown_links3(this.content);
    const [clean, exclusions, excluded_char_count] = strip_excluded_headings(this.content, opts.excluded_headings ?? []);
    const depth = opts.depth || 0;
    if (!snapshot.items[depth]) snapshot.items[depth] = {};
    snapshot.items[depth][this.key] = {
      path: this.key,
      content: clean,
      char_count: clean.length,
      mtime: Date.now(),
      // inline items have no mtime
      exclusions,
      excluded_char_count,
      inlinks: this.inlinks,
      outlinks: this.outlinks
    };
    snapshot.char_count += clean.length;
  }
  async find_connections(opts = {}) {
    return await this.env.smart_sources.lookup({ hypotheticals: [
      this.data.content
    ] });
  }
};
var SourceContextItem = class extends BaseContextItem {
  constructor(context, ref) {
    super(context, ref.key);
    this.ref = ref;
  }
  get inlinks() {
    return this.ref.inlinks || [];
  }
  get outlinks() {
    return this.ref.outlinks || [];
  }
  async add_to_snapshot(snapshot, opts) {
    let raw = await this.ref.read();
    if (!opts.calculating && raw.split("\n").some((line) => line.startsWith("```dataview"))) {
      raw = await this.ref.read({ render_output: true });
      this.ref.data.outlinks = get_markdown_links3(raw);
    }
    const [content, exclusions, excluded_char_count] = strip_excluded_headings(raw, opts.excluded_headings ?? []);
    if (!snapshot.items) snapshot.items = [];
    if (!snapshot.items[0]) snapshot.items[0] = {};
    snapshot.items[0][this.path] = {
      ref: this.ref,
      path: this.path,
      mtime: this.ref.mtime,
      content,
      char_count: content.length,
      exclusions,
      excluded_char_count
    };
    snapshot.char_count += content.length;
  }
  async find_connections(opts = {}) {
    return await this.ref.find_connections(opts);
  }
};
var ImageContextItem = class extends BaseContextItem {
  async add_to_snapshot(snapshot) {
    if (!snapshot.images) snapshot.images = [];
    snapshot.images.push(this.path);
  }
};
var PdfContextItem = class extends BaseContextItem {
  async add_to_snapshot(snapshot) {
    if (!snapshot.pdfs) snapshot.pdfs = [];
    snapshot.pdfs.push(this.path);
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-contexts/utils/image_extension_regex.js
var image_extension_regex = /\.(png|jpe?g|gif|bmp|webp|svg|ico|mp4)$/i;

// node_modules/smart-chat-obsidian/node_modules/smart-contexts/smart_context.js
var SmartContext = class extends CollectionItem3 {
  static version = 1;
  static get defaults() {
    return {
      data: {
        key: "",
        context_items: {},
        context_opts: {}
      }
    };
  }
  /**
   * add_item
   * @param {string|object} item
   */
  add_item(item) {
    let key;
    if (typeof item === "object") {
      key = item.key || item.path;
    } else {
      key = item;
    }
    const context_item = {
      d: 0,
      ...typeof item === "object" ? item : {}
    };
    if (!key) return console.error("SmartContext: add_item called with invalid item", item);
    this.data.context_items[key] = context_item;
    this.queue_save();
  }
  /**
   * add_items
   * @param {string[]|object[]} items
   */
  add_items(items) {
    if (!Array.isArray(items)) {
      items = [items];
    }
    items.forEach((item) => this.add_item(item));
  }
  /**
   * Return *ContextItem* instances (any depth) for a given key array.
   * @param {string[]} keys
   */
  get_context_items(keys = this.context_item_keys) {
    return keys.map((k) => this.get_context_item(k)).filter(Boolean);
  }
  /** Map any key to ContextItem subclass */
  get_context_item(key) {
    const ctx_item = this.data?.context_items?.[key];
    if (ctx_item && typeof ctx_item === "object" && "content" in ctx_item) {
      return new BaseContextItem(this, key);
    }
    if (image_extension_regex.test(key)) return new ImageContextItem(this, key);
    if (key.endsWith(".pdf")) return new PdfContextItem(this, key);
    const src = this.env.smart_sources.get(key) || this.env.smart_blocks.get(key);
    return src ? new SourceContextItem(this, src) : null;
  }
  /**
   * get_snapshot
   * Gathers items at depth=0..link_depth, respects exclusions, and tracks truncated/skipped items.
   * @async
   * @param {object} opts
   * @returns {Promise<object>} context_snapshot - an object with .items[0], .items[1], etc.
   */
  async get_snapshot(opts = {}) {
    const merged_opts = merge_context_opts(this, opts);
    return await get_snapshot(this, merged_opts);
  }
  /**
   * compile
   * Delegates to a compile adapter from this.collection.compile_adapters.
   * By default uses the 'default' adapter unless opts.adapter_key is given.
   * @async
   * @param {object} [opts={}]
   * @returns {Promise<object|string>} Typically {context, stats} from the template adapter
   */
  async compile(opts = {}) {
    const adapter_key = opts.adapter_key || "default";
    const adapter_class = this.collection.compile_adapters[adapter_key];
    if (!adapter_class) {
      throw new Error(`SmartContext: Compile adapter not found: ${adapter_key}`);
    }
    const adapter = new adapter_class(this);
    return adapter.compile(opts);
  }
  /**
   * @method get_ref
   * @deprecated moving to using ContextItem instances
   * Looks up a reference in the environment. Distinguishes block vs source by '#' presence.
   */
  get_ref(key) {
    return this.collection.get_ref(key);
  }
  get_item_keys_by_depth(depth) {
    return Object.keys(this.data.context_items).filter((k) => {
      const item_depth = this.data.context_items[k].d;
      if (item_depth === depth) return true;
      if (typeof item_depth === "undefined" && depth === 0) return true;
      return false;
    });
  }
  get context_item_keys() {
    return Object.keys(this.data?.context_items || {});
  }
  /**
   * If no user-provided key, fallback to a stable hash of the context_items.
   */
  get key() {
    if (!this.data.key) {
      this.data.key = Date.now().toString();
    }
    return this.data.key;
  }
  get has_context_items() {
    return Object.keys(this.data.context_items || {}).length > 0;
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-contexts/adapters/_adapter.js
var ContextCompileAdapter = class {
  /**
   * @static
   * @type {string}
   * Identifies this adapter by a short, unique key. The collection
   * will store it in a map at `collection.compile_adapters[adapter_key]`.
   */
  static adapter_key = "raw";
  /**
   * @constructor
   * @param {SmartContext} context_item
   */
  constructor(context_item) {
    this.context_item = context_item;
  }
  /**
   * @method compile
   * Returns the snapshot as-is (no further transformations).
   * @param {object} [opts={}]
   * @returns {Promise<object>} The snapshot from get_snapshot().
   */
  async compile(opts = {}) {
    const snapshot = await this.context_item.get_snapshot(opts);
    return snapshot;
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-contexts/utils/compiler.js
async function compile_snapshot(context_snapshot, merged_opts) {
  const depths = Object.keys(context_snapshot.items).map((d) => parseInt(d, 10)).sort((a, b) => a - b);
  const chunks = [];
  for (const depth of depths) {
    const items = context_snapshot.items[depth] || {};
    const { before_raw, after_raw } = get_templates_for_depth(depth, merged_opts);
    for (const [path, item] of Object.entries(items)) {
      const placeholders = build_item_placeholders(path, depth, item.mtime);
      chunks.push({
        path,
        mtime: item.mtime,
        before_tpl: replace_vars(before_raw, placeholders),
        item_text: item.content,
        after_tpl: replace_vars(after_raw, placeholders)
      });
    }
  }
  const skipped_items = new Set(context_snapshot.skipped_items || []);
  const truncated_items = new Set(context_snapshot.truncated_items || []);
  const max_len = merged_opts.max_len || 0;
  const result_pieces = [];
  for (const chunk of chunks) {
    if (!max_len) {
      const joined = [chunk.before_tpl, chunk.item_text, chunk.after_tpl].join("\n");
      result_pieces.push(joined);
      continue;
    }
    const template_len = chunk.before_tpl.length + chunk.after_tpl.length;
    const leftover_for_text = max_len - template_len;
    const text_len = chunk.item_text.length;
    if (text_len <= leftover_for_text) {
      const joined = [chunk.before_tpl, chunk.item_text, chunk.after_tpl].join("\n");
      result_pieces.push(joined);
    } else {
      truncated_items.add(chunk.path);
      const partial = chunk.item_text.slice(0, leftover_for_text);
      const joined = [chunk.before_tpl, partial, chunk.after_tpl].join("\n");
      result_pieces.push(joined);
    }
  }
  let raw_output = result_pieces.join("\n");
  const top_before_raw = merged_opts.templates?.["-1"]?.before || "";
  const top_after_raw = merged_opts.templates?.["-1"]?.after || "";
  const want_tree = top_before_raw.includes("{{FILE_TREE}}") || top_after_raw.includes("{{FILE_TREE}}");
  let file_tree_str = "";
  if (want_tree) {
    const all_paths = chunks.map((c) => c.path);
    file_tree_str = create_file_tree_string(all_paths);
  }
  const wrap_before = replace_vars(top_before_raw, { FILE_TREE: file_tree_str });
  const wrap_after = replace_vars(top_after_raw, { FILE_TREE: file_tree_str });
  let final_context = "";
  const wrap_has_content = wrap_before.length > 0 || wrap_after.length > 0;
  if (!wrap_has_content) {
    final_context = raw_output + "\n";
  } else {
    final_context = wrap_before + "\n" + raw_output + "\n" + wrap_after + "\n";
  }
  const final_len = final_context.length;
  const stats = {
    char_count: final_len,
    depth_count: depths.length,
    truncated_items: Array.from(truncated_items),
    skipped_items: Array.from(skipped_items)
  };
  return {
    context: final_context.trim(),
    stats,
    images: context_snapshot.images,
    pdfs: context_snapshot.pdfs
  };
}
function get_templates_for_depth(depth, merged_opts) {
  let before_template_depth = depth;
  let before_raw = merged_opts.templates?.[before_template_depth]?.before;
  while (typeof before_raw !== "string" && before_template_depth > -1) {
    before_template_depth--;
    before_raw = merged_opts.templates?.[before_template_depth]?.before;
  }
  let after_template_depth = depth;
  let after_raw = merged_opts.templates?.[after_template_depth]?.after;
  while (typeof after_raw !== "string" && after_template_depth > -1) {
    after_template_depth--;
    after_raw = merged_opts.templates?.[after_template_depth]?.after;
  }
  return { before_raw, after_raw };
}
function build_item_placeholders(path, depth, mtime) {
  const name = path.substring(path.lastIndexOf("/") + 1);
  const dot_pos = name.lastIndexOf(".");
  const ext = dot_pos > 0 ? name.slice(dot_pos + 1) : "";
  return {
    ITEM_PATH: path.replace("external:", ""),
    ITEM_NAME: name,
    ITEM_EXT: ext,
    ITEM_DEPTH: depth,
    ITEM_TIME_AGO: convert_to_time_ago(mtime)
  };
}
function convert_to_time_ago(timestamp) {
  const now = Date.now();
  let diffMs = now - timestamp;
  if (timestamp < 1e12) {
    diffMs = now - timestamp * 1e3;
  }
  const seconds = Math.floor(diffMs / 1e3);
  const intervals = [
    { label: "year", seconds: 31536e3 },
    { label: "month", seconds: 2592e3 },
    { label: "day", seconds: 86400 },
    { label: "hour", seconds: 3600 },
    { label: "minute", seconds: 60 },
    { label: "second", seconds: 1 }
  ];
  for (const interval of intervals) {
    const count = Math.floor(seconds / interval.seconds);
    if (count >= 1) {
      return `${count} ${interval.label}${count > 1 ? "s" : ""} ago`;
    }
  }
  return "just now";
}
function replace_vars(template, replacements) {
  if (!template) return "";
  let out = template;
  for (const [k, v] of Object.entries(replacements)) {
    const safe_v = v !== void 0 && v !== null ? String(v) : "";
    out = out.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), safe_v);
  }
  return out;
}
function create_file_tree_string(all_paths) {
  const root = {};
  for (const p of all_paths) {
    let cursor = root;
    const parts = p.split("/");
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      if (i === parts.length - 1) {
        cursor[part] = null;
      } else {
        if (!cursor[part]) cursor[part] = {};
        cursor = cursor[part];
      }
    }
  }
  compress_single_child_dirs2(root);
  return build_tree_string2(root);
}
function compress_single_child_dirs2(node) {
  if (!node || typeof node !== "object") return;
  const keys = Object.keys(node);
  for (const k of keys) {
    const child = node[k];
    if (child && typeof child === "object") {
      const childKeys = Object.keys(child);
      if (childKeys.length === 1) {
        const subKey = childKeys[0];
        const subChild = child[subKey];
        if (subChild !== null) {
          const combined = k + "/" + subKey;
          node[combined] = subChild;
          delete node[k];
          compress_single_child_dirs2(node[combined]);
        } else {
        }
      } else {
        compress_single_child_dirs2(child);
      }
    }
  }
}
function build_tree_string2(node, prefix = "") {
  let res = "";
  const entries = Object.entries(node).sort((a, b) => {
    const a_is_dir = a[1] !== null;
    const b_is_dir = b[1] !== null;
    if (a_is_dir && !b_is_dir) return -1;
    if (!a_is_dir && b_is_dir) return 1;
    return a[0].localeCompare(b[0]);
  });
  entries.forEach(([name, subnode], idx) => {
    const is_last = idx === entries.length - 1;
    const connector = is_last ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ";
    if (subnode === null) {
      res += prefix + connector + name + "\n";
    } else {
      res += prefix + connector + name + "/\n";
      const next_prefix = prefix + (is_last ? "    " : "\u2502   ");
      res += build_tree_string2(subnode, next_prefix);
    }
  });
  return res;
}

// node_modules/smart-chat-obsidian/node_modules/smart-contexts/adapters/default.js
var DefaultContextCompileAdapter = class extends ContextCompileAdapter {
  static adapter_key = "default";
  /**
   * @method compile
   * Builds a snapshot via get_snapshot, then calls compile_snapshot.
   * @param {object} [opts={}]
   * @returns {Promise<{context: string, stats: object}>}
   */
  async compile(opts = {}) {
    const snapshot = await this.context_item.get_snapshot(opts);
    const merged_opts = merge_context_opts(this.context_item, opts);
    return compile_snapshot(snapshot, merged_opts);
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-contexts/index.js
var smart_contexts_default_config = {
  class: SmartContexts,
  data_adapter: AjsonSingleFileCollectionDataAdapter2,
  compile_adapters: {
    DefaultContextCompileAdapter
  },
  item_type: SmartContext
};

// node_modules/smart-chat-obsidian/src/collections/smart_contexts.js
var smart_contexts_default = smart_contexts_default_config;

// node_modules/smart-chat-obsidian/src/components/chat.css
var css_sheet4 = new CSSStyleSheet();
css_sheet4.replaceSync(`/**
 * chat.css
 *
 * Styles for top-level chat container, top bar, brand area, etc.
 * Note: No more body-level overrides.
 */

/* The main chat container */
.smart-chat-chat-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  max-height: 100%;
  background: var(--background-primary);
  color: var(--text-normal);
  transition: background var(--anim-duration-moderate) var(--anim-motion-smooth);
  margin: 0;
  padding: 0;
}

/* The area that can contain multiple threads (currently just 1 in use) */
.smart-chat-threads-container {
  display: flex;
  flex: 1;
  overflow-y: auto;
  min-height: 0;
}

/* Top Bar */
.smart-chat-top-bar-container {
  flex: 0 0 auto;
  display: flex;
  align-items: center;
  gap: var(--size-4-2);
  padding: var(--size-4-3) var(--size-4-4);
  background: linear-gradient(
    135deg,
    var(--background-secondary-alt),
    var(--background-secondary)
  );
  border-bottom: var(--border-width) solid var(--background-modifier-border);
  position: sticky;
  top: 0;
  z-index: var(--layer-menu);
}
.smart-chat-top-bar-container button {
  background: none;
  border: none;
  color: var(--icon-color);
  cursor: pointer;
  display: flex;
  align-items: center;
  transition:
    color var(--anim-duration-fast) var(--anim-motion-smooth),
    opacity var(--anim-duration-fast) var(--anim-motion-smooth);
}
.smart-chat-top-bar-container button:hover {
  color: var(--icon-color-hover);
  opacity: var(--icon-opacity-hover);
}

.smart-chat-chat-name-input {
  flex: 1;
  background: var(--background-modifier-form-field);
  border: var(--border-width) solid var(--background-modifier-border);
  padding: var(--size-4-2) var(--size-4-3);
  border-radius: var(--radius-s);
  color: var(--text-normal);
  transition: border-color var(--anim-duration-fast) var(--anim-motion-smooth);
}
.smart-chat-chat-name-input:focus {
  outline: none;
  border-color: var(--interactive-accent-hover);
}

/* Brand area at bottom */
.smart-chat-brand {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  padding: var(--size-4-2);
  background-color: var(--background-secondary-alt);
  border-top: var(--border-width) solid var(--background-modifier-border);
  color: var(--text-muted);
  font-size: var(--font-ui-small);
  gap: var(--size-4-1);
  box-shadow: var(--shadow-s);
}
.smart-chat-brand svg.smart-connections {
  width: var(--size-4-6);
  height: var(--size-4-6);
  margin-bottom: var(--size-4-2);
  color: var(--text-normal);
}
.smart-chat-brand p {
  margin: 0;
  color: var(--text-faint);
}
.smart-chat-brand a {
  text-decoration: none;
  color: var(--text-accent);
  font-weight: 700;
}

@keyframes save_confirmation {
  0% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.4); }
  70% { box-shadow: 0 0 0 10px rgba(46, 204, 113, 0); }
  100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); }
}

.smart-chat-name-saved {
  animation: save_confirmation 1s ease-out;
  background-color: rgba(46, 204, 113, 0.1);
  transition: background-color 1s ease;
}

.sc-tree-item .sc-tree-score {
  font-size: 0.8rem;
  cursor: pointer;
  font-weight: 500;
}`);
var chat_default = css_sheet4;

// node_modules/smart-chat-obsidian/src/chat_history_modal.js
var import_obsidian36 = require("obsidian");
var ChatHistoryModal = class extends import_obsidian36.FuzzySuggestModal {
  /**
   * @param {Object} plugin - Main plugin instance with `app` and `env`.
   */
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
    this.env = this.plugin.env;
    this.shift_enter = false;
    this.setPlaceholder("Search existing chat threads...");
    this.setInstructions([
      { command: "Enter", purpose: "Open the selected thread" },
      { command: "Shift+Enter", purpose: "Delete the selected thread" }
    ]);
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && e.shiftKey) {
        e.preventDefault();
        this.shift_enter = true;
        this.selectActiveSuggestion(e);
      }
    });
  }
  /**
   * Returns a list of thread items from `smart_chat_threads`.
   * @returns {Array<Object>}
   */
  getItems() {
    return Object.values(this.env.smart_chat_threads.items).filter(
      (thread) => thread.completions.length > 1 || thread.completions.length === 1 && thread.completions[0].response
    );
  }
  /**
   * Called to get the display text for each thread in the suggestions list.
   * @param {Object} thread
   * @returns {string}
   */
  getItemText(thread) {
    return thread.name;
  }
  /**
   * Invoked when the user picks a suggestion.
   * If SHIFT+Enter was pressed, sets thread.confirm_deletion = true.
   * Then sets the chosen thread active and re-renders the chat UI.
   * @param {Object} thread
   */
  onChooseItem(thread) {
    if (this.shift_enter) {
      thread.confirm_deletion = true;
    }
    this.env.smart_chat_threads.active_thread = thread;
    SmartChatView.open(this.plugin);
  }
};

// node_modules/smart-chat-obsidian/node_modules/obsidian-smart-env/modals/story.js
var import_obsidian37 = require("obsidian");

// node_modules/smart-chat-obsidian/node_modules/obsidian-smart-env/utils/open_url_externally.js
function open_url_externally2(plugin, url) {
  const webviewer = plugin.app.internalPlugins?.plugins?.webviewer?.instance;
  window.open(url, webviewer ? "_external" : "_blank");
}

// node_modules/smart-chat-obsidian/node_modules/obsidian-smart-env/modals/story.js
var StoryModal2 = class _StoryModal extends import_obsidian37.Modal {
  constructor(plugin, { title, url }) {
    super(plugin.app);
    this.plugin = plugin;
    this.title = title;
    this.url = url;
  }
  static open(plugin, story_url) {
    const modal = new _StoryModal(plugin, story_url);
    modal.open();
  }
  onOpen() {
    this.titleEl.setText(this.title);
    this.modalEl.addClass("sc-story-modal");
    const container = this.contentEl.createEl("div", {
      cls: "sc-story-container"
    });
    if (import_obsidian37.Platform.isMobile) {
      const btn = container.createEl("button", { text: "Open in browser" });
      btn.addEventListener("click", () => {
        open_url_externally2(this.plugin, this.url);
        this.close();
      });
      return;
    } else {
      const webview = container.createEl("webview", {
        attr: { src: this.url, allowpopups: "" }
      });
      webview.style.width = "100%";
      webview.style.height = "100%";
      webview.addEventListener("did-navigate", (event) => {
        const new_url = event.url || webview.getAttribute("src");
        if (new_url && new_url !== this.url) {
          open_url_externally2(this.plugin, new_url);
          this.close();
        }
      });
    }
  }
  onClose() {
    this.contentEl.empty();
  }
};

// node_modules/smart-chat-obsidian/src/components/chat.js
function build_html24(chat_threads_collection, opts = {}) {
  return `<div>
    <div class="smart-chat-chat-container">
      <div class="smart-chat-top-bar-container">
        <input
          class="smart-chat-chat-name-input"
          type="text"
          value=""
          placeholder="Add name to save this chat"
        />
        <button title="New Chat" id="smart-chat-new-chat-button">
          ${this.get_icon_html("plus")}
        </button>
        <button title="Chat History" id="smart-chat-chat-history-button">
          ${this.get_icon_html("history")}
        </button>
        <button title="Chat Settings" id="smart-chat-chat-settings-button">
          ${this.get_icon_html("settings")}
        </button>
        <button title="Chat Help" id="smart-chat-help-button">
          ${this.get_icon_html("help-circle")}
        </button>
      </div>
      <div class="smart-chat-threads-container"></div>
      <div class="smart-chat-brand">
        ${this.get_icon_html("smart-chat")}
        <p>
          <a style="font-weight: 700;" href="https://smartconnections.app/">
            Smart Chat
          </a>
        </p>
      </div>
    </div>
  </div>`;
}
async function render30(chat_threads_collection, opts = {}) {
  const html = await build_html24.call(this, chat_threads_collection, opts);
  const frag = this.create_doc_fragment(html);
  chat_threads_collection.container = frag.querySelector(".smart-chat-chat-container");
  this.apply_style_sheet(chat_default);
  post_process27.call(this, chat_threads_collection, chat_threads_collection.container, opts);
  return chat_threads_collection.container;
}
async function post_process27(chat_threads_collection, container, opts = {}) {
  const env = chat_threads_collection.env;
  const threads_container = chat_threads_collection.container.querySelector(".smart-chat-threads-container");
  let active_thread = chat_threads_collection.active_thread;
  const plugin = env.smart_chat_plugin || env.smart_connections_plugin;
  if (!active_thread) {
    const all_threads = Object.values(chat_threads_collection.items).filter(
      (thread) => !thread.deleted
    );
    if (all_threads.length === 0) {
      console.log("No threads exist, creating a new thread...");
      active_thread = await chat_threads_collection.create_or_update();
      chat_threads_collection.active_thread = active_thread;
    } else {
      active_thread = all_threads[0];
      chat_threads_collection.active_thread = active_thread;
    }
  }
  if (threads_container && active_thread) {
    this.empty(threads_container);
    const thread_frag = await env.render_component("thread", active_thread, opts);
    threads_container.appendChild(thread_frag);
  }
  const thread_name_input = container.querySelector(".smart-chat-chat-name-input");
  if (thread_name_input) {
    thread_name_input.value = active_thread.name;
    const renameHandler = (current_thread) => {
      const new_val = thread_name_input.value.trim();
      if (!new_val || new_val === current_thread.name) {
        return;
      }
      rename_thread(chat_threads_collection, current_thread, new_val);
      thread_name_input.classList.add("smart-chat-name-saved");
      setTimeout(() => {
        thread_name_input.classList.remove("smart-chat-name-saved");
      }, 1e3);
    };
    const get_current_thread_from_event = (e) => {
      const chat_container = e.target.closest(".smart-chat-chat-container");
      const thread_key = chat_container.querySelector("[data-thread-key]").dataset.threadKey;
      return chat_threads_collection.get(thread_key);
    };
    thread_name_input.addEventListener("blur", (e) => {
      const current_thread = get_current_thread_from_event(e);
      renameHandler(current_thread);
    });
    thread_name_input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const current_thread = get_current_thread_from_event(e);
        renameHandler(current_thread);
        thread_name_input.blur();
      }
    });
  }
  const new_chat_button = chat_threads_collection.container.querySelector("#smart-chat-new-chat-button");
  if (new_chat_button) {
    new_chat_button.addEventListener("click", async (e) => {
      e.preventDefault();
      const new_thread = await chat_threads_collection.create_or_update();
      chat_threads_collection.active_thread = new_thread;
      if (threads_container) {
        this.empty(threads_container);
      }
      const thread_frag = await env.render_component("thread", new_thread, opts);
      threads_container.appendChild(thread_frag);
      if (thread_name_input) {
        thread_name_input.value = new_thread.name;
      }
    });
  }
  const chat_settings_button = chat_threads_collection.container.querySelector("#smart-chat-chat-settings-button");
  if (chat_settings_button) {
    chat_settings_button.addEventListener("click", async (e) => {
      e.preventDefault();
      open_plugin_settings(plugin.app);
    });
  }
  const chat_history_button = chat_threads_collection.container.querySelector("#smart-chat-chat-history-button");
  if (chat_history_button) {
    chat_history_button.addEventListener("click", async (e) => {
      e.preventDefault();
      const chat_history_modal = new ChatHistoryModal(plugin);
      chat_history_modal.open();
    });
  }
  container.querySelector("#smart-chat-help-button")?.addEventListener(
    "click",
    () => StoryModal2.open(plugin, {
      title: "Getting Started With Smart Chat",
      url: "https://smartconnections.app/story/smart-connections-getting-started/?utm_source=smart-chat-help#page=chat-interface-1"
    })
  );
  return container;
}
async function open_plugin_settings(app2) {
  await app2.setting.open();
  await app2.setting.openTabById("smart-chat");
}
function rename_thread(collection, thread, new_name) {
  thread.data.name = new_name;
  thread.queue_save();
  collection.process_save_queue();
}

// node_modules/smart-chat-obsidian/src/utils/chat_context_utils.js
function thread_has_user_message(thread) {
  const last_two = thread?.completions?.slice(-2) || [];
  return last_two.some((c) => c?.data?.user_message);
}

// node_modules/smart-chat-obsidian/node_modules/smart-context-obsidian/src/views/context_selector_modal.js
var import_obsidian38 = require("obsidian");

// node_modules/smart-chat-obsidian/node_modules/smart-context-obsidian/node_modules/smart-file-system/utils/ignore.js
var TEXT_FILE_EXTENSIONS = [
  ".asm",
  ".bat",
  ".c",
  ".cfg",
  ".clj",
  ".conf",
  ".cpp",
  ".cs",
  ".css",
  ".csv",
  ".d",
  ".dart",
  ".ejs",
  ".elm",
  ".erl",
  ".f",
  ".go",
  ".gradle",
  ".groovy",
  ".h",
  ".hbs",
  ".hpp",
  ".hs",
  ".html",
  ".ini",
  ".jade",
  ".java",
  ".js",
  ".json",
  ".jsx",
  ".kt",
  ".less",
  ".lisp",
  ".log",
  ".lua",
  ".m",
  ".makefile",
  ".md",
  ".mdx",
  ".ml",
  ".mjs",
  ".mustache",
  ".pas",
  ".php",
  ".pl",
  ".properties",
  ".pug",
  ".py",
  ".r",
  ".rb",
  ".rs",
  ".sass",
  ".scala",
  ".scheme",
  ".scss",
  ".sh",
  ".sql",
  ".svelte",
  ".swift",
  ".tcl",
  ".tex",
  ".tpl",
  ".ts",
  ".tsx",
  ".twig",
  ".txt",
  ".vb",
  ".vue",
  ".xml",
  ".yaml",
  ".yml",
  ".canvas"
];
var NO_EXTENSION_TEXT_FILES = [
  "Dockerfile",
  "Appfile",
  "Matchfile",
  "Deliverfile",
  "Gymfile",
  "Fastfile",
  "Gemfile",
  "Guardfile",
  "Jenkinsfile",
  "Makefile",
  "Procfile",
  "Rakefile"
];
function is_text_file(file_path) {
  const last_dot_index = file_path.lastIndexOf(".");
  if (last_dot_index === -1) {
    if (NO_EXTENSION_TEXT_FILES.some((file) => file_path.endsWith(file))) {
      return true;
    }
    return false;
  }
  const ext = file_path.substring(last_dot_index).toLowerCase();
  return TEXT_FILE_EXTENSIONS.includes(ext);
}

// node_modules/smart-chat-obsidian/node_modules/smart-context-obsidian/src/utils/get_all_leaves.js
function get_all_leaves(app2) {
  const leaves = [];
  const recurse = (container) => {
    if (container.children) {
      for (const child of container.children) {
        recurse(child);
      }
    }
    if (container.type === "leaf") {
      leaves.push(container);
    }
  };
  recurse(app2.workspace.rootSplit);
  return leaves;
}

// node_modules/smart-chat-obsidian/node_modules/smart-context-obsidian/src/utils/get_all_open_file_paths.js
function get_all_open_file_paths(app2) {
  const leaves = get_all_leaves(app2);
  const files_set = [];
  for (const leaf of leaves) {
    const file_path = leaf.view?.state?.file ?? leaf.view?.file?.path;
    if (file_path && is_text_file(file_path)) {
      files_set.push(file_path);
    }
  }
  return files_set;
}

// node_modules/smart-chat-obsidian/node_modules/smart-context-obsidian/src/utils/is_leaf_visible.js
function is_leaf_visible(leaf) {
  const parent = leaf.parent;
  if (!parent) {
    return leaf.containerEl && leaf.containerEl.offsetParent !== null;
  }
  if ("activeTab" in parent) {
    return parent.activeTab === leaf && leaf.containerEl && leaf.containerEl.offsetParent !== null;
  }
  return leaf.containerEl && leaf.containerEl.offsetParent !== null;
}

// node_modules/smart-chat-obsidian/node_modules/smart-context-obsidian/src/utils/get_visible_open_files.js
function get_visible_open_files(app2) {
  const leaves = get_all_leaves(app2);
  const visible_files = /* @__PURE__ */ new Set();
  for (const leaf of leaves) {
    if (!is_leaf_visible(leaf)) continue;
    const file = leaf.view?.file;
    if (file && is_text_file(file.path)) {
      visible_files.add(file);
    }
  }
  return [...visible_files].map((file) => file.path);
}

// node_modules/smart-chat-obsidian/node_modules/smart-context-obsidian/src/utils/send_context_changed_event.js
function send_context_changed_event(container, next_ctx) {
  container.dispatchEvent(new CustomEvent("smart-env:context-changed", {
    detail: { context: next_ctx },
    bubbles: true,
    composed: true
  }));
}

// node_modules/smart-chat-obsidian/node_modules/smart-context-obsidian/src/views/context_selector_modal.js
var ContextSelectorModal = class extends import_obsidian38.FuzzySuggestModal {
  static open(env, opts) {
    const plugin = env.smart_context_plugin || env.smart_chat_plugin || env.smart_connections_plugin || env.plugin;
    if (!env.context_selector_modal) {
      if (env.smart_context_plugin?.ContextSelectorModal) {
        env.context_selector_modal = new env.smart_context_plugin.ContextSelectorModal(plugin, opts);
      } else env.context_selector_modal = new this(plugin, opts);
    }
    env.context_selector_modal.open(opts);
    return env.context_selector_modal;
  }
  static close(env) {
    env.context_selector_modal.close(true);
    env.context_selector_modal = null;
  }
  /**
   * @param {import('../../main.js').default} plugin
   * @param {Object} [opts={}]
   * @param {SmartContext} [opts.ctx]
   */
  constructor(plugin, opts = {}) {
    super(plugin.app);
    this.app = plugin.app;
    this.plugin = plugin;
    this.opts = opts;
    this.ctx = opts.ctx ?? null;
    this.setInstructions([
      { command: "Enter", purpose: "Add to context" },
      { command: "\u2318/Ctrl + Enter", purpose: "Open named context in builder" },
      { command: "Esc", purpose: "Close" }
    ]);
    this.plugin.env.create_env_getter(this);
    this.mod_key_was_held = false;
    this.containerEl.addEventListener("keydown", (e) => {
      if (e.key === "Escape") this.close(true);
    });
    this.modalEl.addEventListener("keydown", (e) => {
      this.mod_key_was_held = import_obsidian38.Keymap.isModifier(e, "Mod");
      if (e.key === "Enter") this.selectActiveSuggestion(e);
    });
    this.resultContainerEl.addEventListener("click", (e) => {
      this.mod_key_was_held = import_obsidian38.Keymap.isModifier(e, "Mod");
    });
  }
  /* ───────────────────────────────────────────────────────────── */
  /**
   * Sort an array of context entries according to:
   *   – priority 0 → item has in/out‑links with the current active note
   *   – priority 1 → item modified within the last 24 h
   *   – priority 2 → all remaining items
   * Within each priority group items are ordered alphabetically.
   *
   * @param {Array<Object>} entries
   * @returns {Array<Object>} sorted copy
   */
  sort_context_entries(entries) {
    const active_file = this.app.workspace.getActiveFile();
    let active_src = null;
    if (active_file) {
      active_src = this.env.smart_sources.get(active_file.path);
    }
    const linked_keys = /* @__PURE__ */ new Set();
    if (active_src) {
      active_src.outlinks.forEach((k) => linked_keys.add(k));
      active_src.inlinks.forEach((k) => linked_keys.add(k));
    }
    const recent_cutoff = Date.now() - 24 * 60 * 60 * 1e3;
    const get_key = (entry) => entry?.item?.key || entry?.key || entry?.path || "";
    const get_src = (entry) => entry?.item || entry;
    const priority = (entry) => {
      const key = get_key(entry);
      const src = get_src(entry);
      if (linked_keys.has(key)) return 0;
      if (src?.mtime && src.mtime >= recent_cutoff) return 1;
      return 2;
    };
    return [...entries].sort((a, b) => {
      const pa = priority(a);
      const pb = priority(b);
      if (pa !== pb) return pa - pb;
      return get_key(a).localeCompare(get_key(b));
    });
  }
  /* ───────────────────────────────────────────────────────────── */
  ensure_ctx() {
    if (this.ctx) return this.ctx;
    this.ctx = this.env.smart_contexts.new_context({}, {
      add_items: this.opts.initial_context_items
    });
    return this.ctx;
  }
  async open(opts = this.opts) {
    if (opts.ctx) this.ctx = opts.ctx;
    if (opts.opener_container) this.add_opener_container(opts.opener_container);
    this.opts = opts;
    await this.render();
    super.open();
    this.focus_input();
  }
  async render() {
    this.modalEl.style.display = "flex";
    this.modalEl.style.flexDirection = "column";
    this.modalEl.style.height = "100%";
    const prompt_results = this.modalEl.querySelector(".prompt-results");
    if (prompt_results) {
      prompt_results.style.flex = "1 1 50%";
      prompt_results.style.minHeight = "0";
      prompt_results.style.overflowY = "auto";
    }
    const ctx = this.ensure_ctx();
    const builder_container = await this.env.render_component(
      "context_builder",
      ctx,
      {
        ...this.opts
      }
    );
    builder_container.addEventListener("smart-env:context-changed", (e) => {
      const updated_ctx = e.detail.context;
      this.ctx = updated_ctx;
      this.opts.ctx = updated_ctx;
      this.updateSuggestions();
      this.render();
    });
    builder_container.classList.add("modal");
    const actions_el = builder_container.querySelector(".sc-context-actions");
    if (ctx.has_context_items) {
      const clear_btn = document.createElement("button");
      clear_btn.textContent = "Clear";
      clear_btn.addEventListener("click", () => {
        ctx.data.context_items = {};
        ctx.queue_save();
        ctx.collection.process_save_queue();
        this.updateSuggestions();
        this.render();
      });
      actions_el.appendChild(clear_btn);
      const copy_btn = await this.env.render_component(
        "copy_to_clipboard_button",
        ctx
      );
      actions_el.appendChild(copy_btn);
    }
    if (!actions_el.querySelector('button[data-done="true"]')) {
      const done_btn = document.createElement("button");
      done_btn.dataset.done = "true";
      done_btn.textContent = "Done";
      done_btn.addEventListener("click", () => {
        this.close(true);
      });
      actions_el.appendChild(done_btn);
    }
    this.modalEl.querySelector(".sc-context-builder")?.remove();
    this.modalEl.prepend(builder_container);
  }
  get suggestions() {
    return this.opts.suggestions ?? [];
  }
  set suggestions(suggestions) {
    this.opts.suggestions = suggestions;
  }
  getItems() {
    const suggestions = this.suggestions?.filter(
      (s) => !this.ctx?.data?.context_items[s.item.key]
    );
    if (suggestions?.length) {
      const special_items2 = [];
      special_items2.push({
        name: "Back",
        items: {}
      });
      if (suggestions.some((s) => s.depth)) {
        const depth_1 = suggestions.filter((s) => s.depth <= 1);
        const depth_2 = suggestions.filter((s) => s.depth <= 2);
        const depth_3 = suggestions.filter((s) => s.depth <= 3);
        if (depth_1.length)
          special_items2.push({ name: `Add all to depth 1 (${depth_1.length})`, items: depth_1 });
        if (depth_2.length)
          special_items2.push({ name: `Add all to depth 2 (${depth_2.length})`, items: depth_2 });
        if (depth_3.length)
          special_items2.push({ name: `Add all to depth 3 (${depth_3.length})`, items: depth_3 });
      }
      if (suggestions.some((s) => s.score)) {
        const all_connections = suggestions.filter((s) => s.score);
        special_items2.push({
          name: `Add all connections (${all_connections.length})`,
          items: all_connections
        });
      }
      return [...special_items2, ...suggestions];
    }
    let special_items = this.opts.special_items ?? [];
    const visible_open_files = Array.from(get_visible_open_files(this.app)).map((f) => {
      return { item: this.env.smart_sources.get(f) };
    });
    if (visible_open_files.length) {
      special_items.push({
        name: "Visible open files",
        items: visible_open_files
      });
      const all_open_files = Array.from(get_all_open_file_paths(this.app)).map((f) => {
        return { item: this.env.smart_sources.get(f) };
      });
      if (all_open_files.length && visible_open_files.length !== all_open_files.length) special_items.push({
        name: "All open files",
        items: all_open_files
      });
    }
    special_items = special_items.map((i) => {
      if (i.items) {
        i.items = i.items.filter(
          (item) => item.item && !this.ctx?.data?.context_items[item.item.key]
        );
        i.name = `${i.name} (+${i.items.length})`;
      }
      return i;
    }).filter((i) => {
      if (i.items) return i.items.length > 0;
      return true;
    });
    const unselected = Object.values(this.env.smart_sources.items).filter(
      (src) => !this.ctx?.data?.context_items[src.key]
    );
    const sorted_unselected = this.sort_context_entries(unselected);
    return [...special_items, ...sorted_unselected];
  }
  getItemText(item) {
    if (item.score) {
      return `${item.score.toFixed(2)} | ${item.item.path}`;
    }
    if (item.depth) {
      return `${item.depth} | ${item.item.path}`;
    }
    if (item.items && item.name) {
      return item.name;
    }
    return item.path;
  }
  onChooseSuggestion(selection) {
    if (selection.item.name === "Back") {
      this.suggestions = null;
      this.updateSuggestions();
      return;
    }
    this.ensure_ctx();
    if (selection.item.items) {
      for (const special_item of selection.item.items) {
        if (!this.ctx.data.context_items[special_item.item.key]) {
          this.ctx.data.context_items[special_item.item.key] = { d: 0 };
        }
      }
      this.updateSuggestions();
      this.render();
      return;
    }
    const item = selection.item?.item ?? selection.item;
    if (!this.ctx.data.context_items[item.key]) {
      this.ctx.data.context_items[item.key] = { d: 0 };
      this.updateSuggestions();
      this.render();
    }
  }
  focus_input() {
    setTimeout(() => this.inputEl.focus(), 100);
  }
  close(should_close = false) {
    if (should_close) super.close();
  }
  onClose(should_close = false) {
    while (this.opener_containers?.length) {
      const container = this.opener_containers.pop();
      if (container.isConnected) {
        send_context_changed_event(container, this.ctx);
      }
    }
  }
  /**
   * Add a container to the list of opener containers.
   * This is used to send context changed events when the modal is closed.
   * @param {HTMLElement|NodeList|Array<HTMLElement>|function} container - The container to add.
   * If a function is passed, it will be called to get the container(s).
   */
  add_opener_container(container) {
    if (!this.opener_containers) this.opener_containers = [];
    if (typeof container === "function") container = container();
    if (Array.isArray(container) || container instanceof NodeList) {
      container.forEach((c) => this.add_opener_container(c));
      return;
    }
    if (!(container instanceof HTMLElement)) {
      console.warn("ContextSelectorModal: opener_container must be an HTMLElement, received:", container);
      return;
    }
    if (!this.opener_containers.includes(container)) {
      this.opener_containers.push(container);
    }
  }
  load_suggestions(suggestions) {
    this.suggestions = suggestions;
    this.updateSuggestions();
    this.render();
  }
};

// node_modules/smart-chat-obsidian/node_modules/smart-context-obsidian/src/components/context_builder.css
var css_sheet5 = new CSSStyleSheet();
css_sheet5.replaceSync(`.sc-context-builder {
  padding: 6px 8px;
  display: flex;
  flex: 0 1 auto;
  flex-direction: column;
  width: 100%;
  overflow: auto;
  &.modal {
    max-height: 50%;
  }
  .sc-context-header {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    .sc-context-actions {
      display: flex;
      align-items: center;
      gap: 6px;
    }
  }
  .sc-context-body {
    flex: 1 1 auto;
    overflow: auto;
  }
  .sc-context-footer {
    flex: 0 1 auto;
    .sc-context-actions {
      display: flex;
      align-items: center;
      gap: 6px;
      justify-content: flex-end;
    }
  }
}


.sc-context-tree ul {
  list-style: none;
  margin: 0 0 0 .8em;
  padding: 0;
}
.sc-context-tree .sc-tree-item {
  gap: 4px;
  padding: 2px 0;
  overflow: auto;

  &.dir {
    &> span {
      opacity: 0.8;
    }
    &> span::after {
      content: '/';
    }
  }
  .sc-tree-label {
    cursor: pointer;
  }
}
.sc-context-tree .sc-tree-remove,
.sc-context-tree .sc-tree-connections,
.sc-context-tree .sc-tree-links {
  cursor: pointer;
  opacity: .8;
}
.sc-context-tree .sc-tree-remove:hover,
.sc-context-tree .sc-tree-connections:hover,
.sc-context-tree .sc-tree-links:hover {
  opacity: 1;
}`);
var context_builder_default = css_sheet5;

// node_modules/smart-chat-obsidian/src/components/chat_context_builder.js
function build_html25(ctx, opts = {}) {
  return `<div>
    <div class="sc-context-builder sc-chat-context-builder" data-context-key="${ctx.data.key}">
      <div class="sc-context-header"></div>
      <div class="sc-context-body">
        <div class="sc-context-tree"></div>
      </div>
      <div class="sc-context-footer">
        <div class="sc-context-stats"></div>
        <div class="sc-context-actions"></div>
      </div>
    </div>
  </div>`;
}
async function render31(ctx, opts = {}) {
  const html = build_html25.call(this, ctx, opts);
  const frag = this.create_doc_fragment(html);
  const ctx_container = frag.querySelector(".sc-context-builder");
  this.apply_style_sheet(context_builder_default);
  await post_process28.call(this, ctx, ctx_container, opts);
  return ctx_container;
}
async function post_process28(ctx, container, opts = {}) {
  const env = ctx?.env;
  const completion = opts.completion;
  const thread = completion.thread;
  const actions_el = container.querySelector(".sc-context-actions");
  this.empty(actions_el);
  completion.thread.container?.querySelector(".smart-chat-add-context-button")?.remove();
  if (Object.keys(ctx.data.context_items || {}).length === 0) {
    const btn = document.createElement("button");
    btn.className = "smart-chat-add-context-button";
    btn.textContent = "Add context";
    btn.addEventListener("click", () => {
      ContextSelectorModal.open(completion.env, {
        ctx: null,
        opener_container: container
      });
    });
    const wrap = document.createElement("div");
    wrap.className = "smart-chat-add-context-container";
    wrap.appendChild(btn);
    container.appendChild(wrap);
    return container;
  }
  if (completion === thread.current_completion) {
    const edit_btn = document.createElement("button");
    edit_btn.textContent = "Edit context";
    edit_btn.addEventListener(
      "click",
      () => ContextSelectorModal.open(env, {
        ctx,
        opener_container: container
      })
    );
    actions_el.appendChild(edit_btn);
  } else {
    console.log("Not current completion, skipping edit button");
    container.classList.add("sc-context-done");
  }
  if (thread_has_user_message(thread)) {
    const retrieve_btn = document.createElement("button");
    retrieve_btn.textContent = "Retrieve more";
    retrieve_btn.addEventListener("click", () => {
      const action_property = thread.collection.settings.use_tool_calls ? "action_key" : "action_xml_key";
      const next_completion = thread.init_completion({
        [action_property]: "lookup_context",
        // Preserve the last user question so the model knows *why*
        user_message: thread.last_completion.data.user_message ?? "",
        action_opts: {
          context_key: ctx.key
        }
      });
      env.render_component("completion", next_completion).then((next_container) => {
        thread.message_container.appendChild(next_container);
      });
      container.classList.add("sc-context-done");
    });
    actions_el.appendChild(retrieve_btn);
  }
  if (thread_has_user_message(thread)) {
    const send_btn = document.createElement("button");
    send_btn.textContent = "Send";
    send_btn.addEventListener("click", async () => {
      actions_el.innerHTML = "";
      const typing = completion.thread?.message_container?.closest(".smart-chat-thread")?.querySelector(".smart-chat-typing-indicator");
      if (typing) typing.style.display = "block";
      await completion.env.render_component("completion", completion, {
        should_complete: true
      });
    });
    actions_el.appendChild(send_btn);
  }
  const tree_el = container.querySelector(".sc-context-tree");
  const context_tree_container = await ctx.env.render_component("context_tree", ctx, {
    ...opts
  });
  const context_items_with_score = Object.entries(ctx.data.context_items).filter(([key, value]) => {
    return value?.score !== void 0 && value?.score !== null;
  }).forEach(([key, value]) => {
    const label = context_tree_container.querySelector(`.sc-tree-item[data-path="${key}"]`);
    if (label) {
      const score_span = this.create_doc_fragment(`<span class="sc-tree-score" title="Relevance score">${value.score.toFixed(2)}</span>`);
      label.insertAfter(score_span, label.querySelector(".sc-tree-remove"));
    }
  });
  ;
  tree_el.replaceWith(
    context_tree_container
  );
  const stats_el = container.querySelector(".sc-context-stats");
  stats_el.replaceWith(
    await ctx.env.render_component("context_stats", ctx, { ...opts })
  );
  return container;
}

// node_modules/smart-chat-obsidian/src/components/chat_model_settings.js
async function render32(env, opts = {}) {
  const smart_chat_model_settings_config = env.smart_chat_threads?.chat_model?.settings_config;
  return await this.render_settings(smart_chat_model_settings_config, {
    scope: env.smart_chat_threads?.chat_model
  });
}

// node_modules/smart-chat-obsidian/src/components/chat_thread_settings.js
async function render33(env, opts = {}) {
  return await this.render_settings(env.smart_chat_threads.settings_config, {
    scope: env.smart_chat_threads
  });
}

// node_modules/smart-chat-obsidian/src/components/completion.css
var css_sheet6 = new CSSStyleSheet();
css_sheet6.replaceSync(`/**
 * completion.css
 * 
 * Styles for the container that holds a single "completion" sequence (user + context + assistant).
 */

.smart-chat-completion-sequence {
  display: flex;
  flex-direction: column;
  gap: var(--size-4-3);
  user-select: text;
  container-type: inline-size;
}


@keyframes messageEntry {
  from {
    transform: translateY(10px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

/**
 * message_assistant.css
 * 
 * Styles for an assistant message bubble.
 */

.smart-chat-message.assistant {
  align-self: flex-start;
  background-color: var(--background-secondary);
  color: var(--text-normal);
  position: relative;
}

.smart-chat-message.assistant .smart-chat-message-actions {
  display: flex;
  align-items: center;
  height: 100%;
  justify-content: flex-end;
}

/* "Sexier" gradient button styling. */
.smart-chat-message-copy-button {
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  color: var(--text-on-accent);
  border: none;
  border-radius: var(--radius-s);
  padding: 0.35rem 0.6rem;
  font-size: var(--font-ui-smaller);
  font-weight: 600;
  transition: all 0.2s ease;
  cursor: pointer;
}

.smart-chat-message-copy-button:hover {
  transform: translateY(-1px);
  box-shadow: var(--shadow-m);
  background-color: var(--interactive-accent-hover);
}

.smart-chat-message-copy-button:active {
  transform: translateY(0px);
  box-shadow: var(--shadow-xs);
}


/**
 * message_user.css
 * 
 * Styles for a user message bubble.
 */

.smart-chat-message.user {
  align-self: flex-end;
  background-color: var(--interactive-accent);
  color: var(--text-on-accent);
}

/**
 * message_system.css
 * 
 * Styles for a system (prompt) message. 
 * This is displayed in a smaller, dim style (not a bubble).
 */

.smart-chat-message{
  display: flex;
  flex-direction: column;
  position: relative;
  border-radius: var(--radius-m);
  padding: var(--size-4-3);
  line-height: var(--line-height-normal);
  font-size: var(--font-text-size);
  animation: messageEntry var(--anim-duration-fast) var(--anim-motion-smooth);
  box-shadow: var(--shadow-s);

  .smart-chat-message-content {
    &> p {
      margin: 0;
    }
  }

  &.system, &.action {
    display: block !important;
    background: none !important;
    box-shadow: none !important;
    border: none !important;
    margin: 0 0 var(--size-4-3) 0;
    padding: 0 !important;
    color: var(--text-faint);
    font-size: var(--font-ui-small);

    .smart-chat-message-content {
      background: none !important;
      padding: 0 !important;
      margin: 0;
      box-shadow: none !important;
      color: var(--text-faint);
      font-size: var(--font-ui-small);
    }
  }
  &.system::before {
    content: "System: ";
    font-weight: bold;
    font-size: var(--font-ui-smaller);
  }
  &.action::before {
    content: "Action: ";
    font-weight: bold;
    font-size: var(--font-ui-smaller);
  }
}

/**
 * Only apply max-width: 70% if container is > 600px */
@container (min-width: 600px) {
  .smart-chat-message {
    max-width: 70%;
  }
}

/**
 * context_builder.css
 * 
 * Styles for the in-between context-review block, letting user select or deselect context items.
 */

.sc-context-builder.smart-chat-message {
  align-self: center;
  background-color: var(--background-modifier-hover);
  color: var(--text-normal);
  flex-direction: column;
  gap: var(--size-4-2);
  max-width: 95%;
}

/* .smart-chat-completion-sequence:has(.smart-chat-message.user), */
.smart-chat-completion-sequence:has(.sc-context-done),
.smart-chat-completion-sequence:has(.smart-chat-message.assistant){
  .sc-tree-remove,
  .sc-tree-connections,
  .sc-tree-links,
  .sc-context-actions {
    display: none;
  }
}`);
var completion_default = css_sheet6;

// node_modules/smart-chat-obsidian/src/components/completion.js
function build_html26(completion, opts = {}) {
  return `<div>
    <div class="smart-chat-completion-sequence" data-completion-key="${completion.key}">
    </div>
  </div>`;
}
async function render34(completion, opts = {}) {
  if (!completion.container) {
    const html = await build_html26.call(this, completion, opts);
    const frag = this.create_doc_fragment(html);
    completion.container = frag.querySelector(".smart-chat-completion-sequence");
    this.apply_style_sheet(completion_default);
  }
  post_process29.call(this, completion, completion.container, opts);
  return completion.container;
}
async function post_process29(completion, sequence_container, opts = {}) {
  if (!completion.system_elm && completion.data.system_message) {
    completion.system_elm = true;
    completion.system_elm = await completion.env.render_component("message_system", completion);
    completion.container.appendChild(completion.system_elm);
  }
  const model_info_container = await completion.env.render_component("message_model_info", completion);
  if (model_info_container) {
    if (completion.model_info_elm) {
      completion.model_info_elm.replaceWith(model_info_container);
    } else {
      completion.container.appendChild(model_info_container);
    }
  }
  completion.model_info_elm = model_info_container;
  if (!completion.user_elm && completion.data.user_message) {
    completion.user_elm = await completion.env.render_component("message_user", completion);
    completion.container.appendChild(completion.user_elm);
    scroll();
  }
  if (!completion.action_elm && completion.data.action_key) {
    const action_frag = await completion.env.render_component("message_action", completion);
    completion.action_elm = action_frag.querySelector(".smart-chat-message.action");
    completion.container.appendChild(completion.action_elm);
  }
  if ((opts.should_complete || completion.data.user_message) && completion.data.completion.responses.length === 0) {
    const typing_indicator = completion.container.closest(".smart-chat-thread")?.querySelector(".smart-chat-typing-indicator");
    if (typing_indicator) typing_indicator.style.display = "block";
    await completion.init({
      stream: completion.env.smart_chat_threads.settings.stream,
      stream_handlers: {
        chunk: async (c) => {
          while (this.handling_chunk) {
            await new Promise((resolve) => setTimeout(resolve, 100));
          }
          this.handling_chunk = true;
          if (!c.response_elm && c.response_text) {
            c.response_elm = await c.env.render_component("message_assistant", c, { await_post_process: true });
            c.content_elm = c.response_elm.querySelector(".smart-chat-message-content");
            completion.container.appendChild(c.response_elm);
          } else if (c.response_text && c.content_elm) {
            this.empty(c.content_elm);
            const partialFrag = await c.env.render_component("message_assistant", c, { await_post_process: true });
            const partialMessage = partialFrag.querySelector(".smart-chat-message-content");
            if (partialMessage) {
              c.content_elm.append(...partialMessage.childNodes);
            }
          }
          await update_action_message.call(this, c);
          scroll();
          this.handling_chunk = false;
        },
        done: async (c) => {
          while (this.handling_chunk) {
            await new Promise((resolve) => setTimeout(resolve, 100));
          }
          this.handling_chunk = true;
          if (c.response_elm && c.content_elm) {
            this.empty(c.content_elm);
            const finalFrag = await c.env.render_component("message_assistant", c, { await_post_process: true });
            const finalMessage = finalFrag.querySelector(".smart-chat-message-content");
            if (finalMessage) {
              c.content_elm.append(...finalMessage.childNodes);
            }
          }
          await update_action_message.call(this, c);
          scroll();
          this.handling_chunk = false;
        },
        error: (err) => {
          console.error("stream error", err);
          this.handling_chunk = false;
        }
      }
    });
    completion.thread.queue_save();
    completion.queue_save();
    completion.thread.collection.process_save_queue();
  }
  if (!completion.data.context_key) {
    const last_context_key = completion.thread.last_completion?.data?.context_key;
    const context = last_context_key ? completion.env.smart_contexts.get(last_context_key) : completion.env.smart_contexts.new_context();
    completion.data.context_key = context.key;
  }
  const is_tool_call_only = Boolean(completion.data.action_key);
  if (!is_tool_call_only && !completion.context_elm) {
    await render_context_container();
  }
  if (!completion.response_elm && completion.response_text) {
    completion.response_elm = await completion.env.render_component("message_assistant", completion);
    completion.container.appendChild(completion.response_elm);
  }
  await update_action_message.call(this, completion);
  scroll();
  if (completion.data.actions?.lookup_context) {
    const typing_indicator = completion.container.closest(".smart-chat-thread")?.querySelector(".smart-chat-typing-indicator");
    if (typing_indicator) typing_indicator.style.display = "none";
  }
  if (completion.thread?.last_completion?.key === completion.key) {
    const next_completion = completion.thread.init_completion();
    completion.env.render_component("completion", next_completion).then((next_container) => {
      completion.thread.message_container.appendChild(next_container);
    });
  }
  async function render_context_container() {
    const context = completion.env.smart_contexts.get(completion.data.context_key);
    if (context) {
      const context_container = await completion.env.render_component(
        "chat_context_builder",
        context,
        { completion }
      );
      completion.context_elm = context_container;
      completion.container.querySelector(".sc-context-builder")?.remove();
      completion.container.appendChild(completion.context_elm);
      context_container.addEventListener("smart-env:context-changed", (e) => {
        const updated_ctx = e.detail.context;
        completion.thread.update_current_context(updated_ctx);
        render_context_container();
      });
    }
  }
  function scroll() {
    const message_container = completion.container.closest(".smart-chat-message-container");
    if (message_container) {
      message_container.scrollTop = message_container.scrollHeight;
    }
    return sequence_container;
  }
  return sequence_container;
}
async function update_action_message(completion) {
  if (completion.action_elm && completion.action_call) {
    this.empty(completion.action_elm);
    const action_call_frag = await completion.env.render_component("message_action", completion, { await_post_process: true });
    const action_call_elm = action_call_frag.querySelector(".smart-chat-message.action");
    this.empty(completion.action_elm);
    completion.action_elm.append(...action_call_elm.childNodes);
  }
}

// node_modules/smart-chat-obsidian/src/components/confirm_delete.js
function build_html27(chat_thread, opts = {}) {
  return `
    <div class="smart-chat-confirm-delete-overlay" style="
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(0,0,0,0.6);
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      z-index: 9999;
    ">
      <div class="smart-chat-confirm-delete-dialog" style="
        background: var(--background-primary);
        border: 1px solid var(--background-modifier-border);
        padding: 16px;
        border-radius: 6px;
        max-width: 400px;
        text-align: center;
      ">
        <p style="margin-bottom: 12px; font-size: var(--font-ui-medium);">
          Are you sure you want to delete this chat thread?
        </p>
        <div style="display: flex; gap: 12px; justify-content: center;">
          <button class="smart-chat-confirm-delete-confirm">
            Confirm
          </button>
          <button class="smart-chat-confirm-delete-cancel">
            Cancel
          </button>
        </div>
      </div>
    </div>
  `;
}
async function render35(chat_thread, opts = {}) {
  const html = build_html27(chat_thread, opts);
  const frag = this.create_doc_fragment(html);
  post_process30.call(this, chat_thread, frag, opts);
  return frag;
}
function post_process30(chat_thread, frag, opts = {}) {
  const confirmOverlay = frag.querySelector(".smart-chat-confirm-delete-overlay");
  if (!confirmOverlay) return frag;
  const confirmBtn = confirmOverlay.querySelector(".smart-chat-confirm-delete-confirm");
  const cancelBtn = confirmOverlay.querySelector(".smart-chat-confirm-delete-cancel");
  confirmBtn?.addEventListener("click", async (e) => {
    e.preventDefault();
    chat_thread.delete();
    await chat_thread.collection.process_save_queue();
    SmartChatView.open();
  });
  cancelBtn?.addEventListener("click", (e) => {
    e.preventDefault();
    chat_thread.confirm_deletion = false;
    SmartChatView.open();
  });
  return frag;
}

// node_modules/smart-chat-obsidian/src/components/message_action.js
function build_html28(completion, opts = {}) {
  const action = completion.data.action_key;
  let action_data = completion.action_call;
  if (typeof action_data === "string") {
    if (action_data.endsWith('"}')) {
    } else if (action_data.endsWith('",')) {
      action_data = action_data.slice(0, -1) + "}";
    } else if (action_data.endsWith('","')) {
      action_data = action_data.slice(0, -2) + '"}';
    } else if (action_data.endsWith('"')) {
      action_data = action_data + "}";
    } else if (action_data.endsWith("{")) {
      action_data = action_data + "}";
    } else if (action_data.endsWith('":')) {
      action_data = action_data + '""}';
    } else if (!action_data.endsWith("]}")) {
      action_data = action_data + '"}';
    }
    if (action_data.includes("[") && !action_data.includes("]")) {
      action_data = action_data.slice(0, -1) + "]}";
    }
    try {
      const parsed = JSON.parse(action_data);
      if (parsed.final) delete parsed.final;
      action_data = JSON.stringify(parsed, null, 2);
    } catch (e) {
      console.warn("Failed to parse action_data as JSON:", e, completion.action_call, action_data);
      const last_good_i = action_data.lastIndexOf('",');
      if (last_good_i !== -1) {
        action_data = action_data.slice(0, last_good_i) + '"}';
        try {
          action_data = JSON.stringify(JSON.parse(action_data), null, 2);
        } catch (e2) {
          action_data = "Failed to parse action call.";
          console.warn("Failed to parse action_data as JSON:", e2, completion.action_call, action_data);
        }
      }
    }
  } else if (action_data && typeof action_data === "object") {
    action_data = JSON.stringify(action_data, null, 2);
  } else {
    action_data = "...";
  }
  return `<div>
    <div class="smart-chat-message action">
      <div class="smart-chat-message-content">${action}${action_data ? `<pre style="white-space: pre-wrap;">${action_data}</pre>` : ""}</div>
    </div>
  </div>`;
}
async function render36(completion, opts = {}) {
  const html = build_html28(completion, opts);
  const frag = this.create_doc_fragment(html);
  if (opts.await_post_process) {
    await post_process31.call(this, completion, frag, opts);
  } else {
    post_process31.call(this, completion, frag, opts);
  }
  return frag;
}
function post_process31(completion, frag, opts = {}) {
  return frag;
}

// node_modules/smart-chat-obsidian/src/components/message_assistant.js
var import_obsidian40 = require("obsidian");

// node_modules/smart-chat-obsidian/node_modules/obsidian-smart-env/utils/open_note.js
var import_obsidian39 = require("obsidian");
async function open_note(plugin, target_path, event = null, opts = {}) {
  const { new_tab = false } = opts;
  const env = plugin.env;
  if (target_path.includes(".pdf#page=")) {
    return plugin.app.workspace.openLinkText(target_path, "/");
  }
  if (target_path.endsWith("#")) target_path = target_path.slice(0, -1);
  let target_file;
  let block = null;
  if (target_path.includes("#")) {
    const [file_path] = target_path.split("#");
    target_file = plugin.app.metadataCache.getFirstLinkpathDest(file_path, "");
    block = env.smart_blocks.get(target_path);
  } else {
    target_file = plugin.app.metadataCache.getFirstLinkpathDest(target_path, "");
  }
  if (!target_file) {
    console.warn(`[open_note] Unable to resolve file for ${target_path}`);
    return;
  }
  let leaf;
  if (event) {
    const is_mod = import_obsidian39.Keymap.isModEvent(event);
    const is_alt = import_obsidian39.Keymap.isModifier(event, "Alt");
    if (is_mod && is_alt) {
      leaf = plugin.app.workspace.splitActiveLeaf("vertical");
    } else if (is_mod || new_tab) {
      leaf = plugin.app.workspace.getLeaf(true);
    } else {
      leaf = plugin.app.workspace.getMostRecentLeaf();
    }
  } else {
    leaf = plugin.app.workspace.getMostRecentLeaf();
  }
  await leaf.openFile(target_file);
  if (typeof block?.line_start === "number") {
    const { editor } = leaf.view;
    const pos = { line: block.line_start, ch: 0 };
    editor.setCursor(pos);
    editor.scrollIntoView({ to: pos, from: pos }, true);
  }
}

// node_modules/smart-chat-obsidian/src/components/message_assistant.js
async function build_html29(completion, opts = {}) {
  return `
    <div class="smart-chat-message assistant">
      <div class="smart-chat-message-content"></div>
      <div class="smart-chat-message-actions">
        <span 
          class="smart-chat-message-copy-button" 
          title="Copy raw markdown"
          aria-label="Copy raw markdown to clipboard"
        >
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
            viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <path d="M8 17L8 5C8 3.89543 8.89543 3 10 3H18C19.1046 3 20 3.89543 20 5V17"
              stroke="currentColor" />
            <rect x="4" y="7" width="14" height="14" rx="2" stroke="currentColor" />
          </svg>
        </span>
      </div>
    </div>
  `;
}
async function render37(completion, opts = {}) {
  const html = await build_html29.call(this, completion, opts);
  const frag = this.create_doc_fragment(html);
  if (opts.await_post_process) return await post_process32.call(this, completion, frag, opts);
  else post_process32.call(this, completion, frag, opts);
  return frag;
}
async function post_process32(completion, frag, opts = {}) {
  const container = frag.querySelector(".smart-chat-message-content");
  const copy_button = frag.querySelector(".smart-chat-message-copy-button");
  this.empty(container);
  const plugin = completion.env.smart_chat_plugin || completion.env.smart_connections_plugin;
  await import_obsidian40.MarkdownRenderer.render(
    plugin.app,
    completion.response_text,
    container,
    "",
    new import_obsidian40.Component()
  );
  copy_button?.addEventListener("click", async () => {
    try {
      if (!navigator?.clipboard?.writeText) {
        console.warn("Clipboard API not available.");
        return;
      }
      await navigator.clipboard.writeText(completion.response_text || "");
      new import_obsidian40.Notice("Copied to clipboard");
    } catch (err) {
      console.error("Failed to copy raw markdown:", err);
    }
  });
  container.querySelectorAll("a[href]").forEach((a) => {
    const href = a.getAttribute("href");
    if (!href) return;
    a.addEventListener("click", (e) => {
      e.preventDefault();
      if (/^(https?:|obsidian:)/i.test(href)) {
        if (href.startsWith("http")) {
          window.open(href, "external");
        } else {
          plugin.app.workspace.openLinkText(href, "/");
        }
        return;
      }
      open_note(plugin, href, e);
    });
    if (!href.includes("://")) {
      let file_path = a.getAttribute("href");
      if (!file_path.endsWith(".md")) file_path += ".md";
      const file = plugin?.app?.metadataCache?.getFirstLinkpathDest(file_path, "");
      if (!file) return;
      a.addEventListener("dragstart", (e) => {
        const drag_data = plugin?.app?.dragManager?.dragFile(e, file);
        plugin?.app?.dragManager?.onDragStart(e, drag_data);
      });
      a.addEventListener("mouseover", (e) => {
        const parent = a.parentElement;
        plugin.app.workspace.trigger("hover-link", {
          event: e,
          source: "smart-chat-view",
          hoverParent: parent,
          targetEl: a,
          linktext: file.path
        });
      });
    }
  });
  return frag;
}

// node_modules/smart-chat-obsidian/src/components/message_model_info.js
function build_html30(completion, opts = {}) {
  const model_key = completion.data.completion?.chat_model?.model_key ?? completion.chat_model?.model_key;
  const platform_key = completion.data.completion?.chat_model?.adapter_name ?? completion.data.completion?.chat_model?.platform_key ?? completion.chat_model?.adapter_name;
  return (
    /* html */
    `<div class="wrapper">
    <div class="model-info" data-model-key="${model_key}" data-platform-key="${platform_key}">
      <div class="smart-chat-message-content">
        Model: <code>${model_key}</code> (<code>${platform_key}</code>)
      </div>
    </div>
  </div>`
  );
}
async function render38(completion, opts = {}) {
  if (!should_show_model_info(completion)) return null;
  const html = build_html30(completion, opts);
  const frag = this.create_doc_fragment(html);
  const container = frag.querySelector(".model-info");
  return container;
}
function should_show_model_info(completion) {
  const thread = completion.thread;
  if (!thread) return true;
  const idx = thread.completions.findIndex((x) => x.key === completion.key);
  if (idx === 0) return true;
  const prev = thread.last_completion;
  const cm_prev = prev?.data?.completion?.chat_model;
  const cm_curr = completion === thread.current_completion ? {
    model_key: completion.chat_model.model_key,
    platform_key: completion.chat_model.adapter_name
  } : completion.data?.completion?.chat_model;
  if (!cm_prev) return true;
  if (!cm_curr) return true;
  return cm_prev.platform_key !== cm_curr.platform_key || cm_prev.model_key !== cm_curr.model_key;
}

// node_modules/smart-chat-obsidian/src/components/message_system.css
var css_sheet7 = new CSSStyleSheet();
css_sheet7.replaceSync(`.expandable-system-message {
  transition: max-height 0.2s cubic-bezier(.4,0,.2,1), background 0.15s;
}
.expandable-system-message.collapsed {
  cursor: pointer;
}
.expandable-system-message.collapsed:hover,
.expandable-system-message.collapsed:focus {
  background: var(--background-modifier-hover);
  /* Removed outline/border */
}
.expandable-system-message:focus {
  outline: 1.5px solid var(--background-modifier-border-focus, #888);
}

/* Gradient overlay and indicator bar for collapsed state */
.expand-indicator-bar {
  position: absolute;
  left: 0; right: 0; bottom: 0;
  height: 2.5em;
  pointer-events: none;
  background: linear-gradient(
    to bottom,
    /* Use background-primary with alpha for both stops */
    rgba(var(--background-primary), 0) 0%,
    rgba(var(--background-primary), 0.95) 80%
  );
  display: flex;
  align-items: flex-end;
  justify-content: center;
  z-index: 1;
}

.expand-indicator-bar .expand-indicator {
  pointer-events: auto;
  background: var(--background-primary, #fff);
  border-radius: 0.7em;
  font-size: 0.95em;
  padding: 0.1em 0.7em;
  margin-bottom: 0.3em;
  font-weight: 500;
  box-shadow: 0 1px 4px rgba(0,0,0,0.04);
  cursor: pointer;
  border: none;
  transition: background 0.15s, color 0.15s;
}

.expandable-system-message.collapsed + .expand-indicator-bar .expand-indicator:hover,
.expandable-system-message.collapsed + .expand-indicator-bar .expand-indicator:focus {
  background: var(--background-modifier-hover, #f0f0f0);
  color: var(--text-normal, #333);
}
`);
var message_system_default = css_sheet7;

// node_modules/smart-chat-obsidian/src/components/message_system.js
function build_html31(completion, opts = {}) {
  const text = (completion.data.system_message || "(No system prompt set)").trim();
  const line_count = (text.match(/\n/g) || []).length + 1;
  const needs_collapse = line_count > 10;
  return `<div>
    <div class="smart-chat-message system">
      <div class="smart-chat-message-content" style="position:relative;">
        <pre class="expandable-system-message"${needs_collapse ? ' tabindex="0"' : ' style="max-height:none;overflow:visible;cursor:auto;"'}>
${text}
        </pre>
        ${needs_collapse ? `<div class="expand-indicator-bar"><span class="expand-indicator" style="user-select:none;">\u25BC More</span></div>` : ""}
      </div>
    </div>
  </div>`;
}
function set_collapsed(pre, indicator_bar, collapsed) {
  if (collapsed) {
    pre.classList.add("collapsed");
    pre.style.display = "-webkit-box";
    pre.style.webkitBoxOrient = "vertical";
    pre.style.webkitLineClamp = "10";
    pre.style.maxHeight = "calc(10 * 1.4em)";
    pre.style.overflow = "hidden";
    pre.style.cursor = "pointer";
    pre.title = "Click or press Enter/Space to expand";
    pre.style.lineHeight = "1.4em";
    if (indicator_bar) indicator_bar.style.display = "";
  } else {
    pre.classList.remove("collapsed");
    pre.style.display = "block";
    pre.style.webkitLineClamp = "";
    pre.style.maxHeight = "none";
    pre.style.overflow = "visible";
    pre.style.cursor = "auto";
    pre.title = "Click or press Enter/Space to collapse";
    pre.style.lineHeight = "1.4em";
    if (indicator_bar) indicator_bar.style.display = "none";
  }
}
async function render39(completion, opts = {}) {
  const html = build_html31(completion, opts);
  this.apply_style_sheet(message_system_default);
  const frag = this.create_doc_fragment(html);
  const container = frag.querySelector(".smart-chat-message.system");
  post_process33.call(this, completion, container, opts);
  return container;
}
function post_process33(completion, frag, opts = {}) {
  const pre = frag.querySelector(".expandable-system-message");
  const indicator_bar = frag.querySelector(".expand-indicator-bar");
  if (pre && indicator_bar) {
    set_collapsed(pre, indicator_bar, true);
    pre.addEventListener("click", function() {
      const collapsed = pre.style.maxHeight !== "none";
      set_collapsed(pre, indicator_bar, !collapsed);
    });
    pre.addEventListener("keydown", function(e) {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        const collapsed = pre.style.maxHeight !== "none";
        set_collapsed(pre, indicator_bar, !collapsed);
      }
    });
  }
  return frag;
}

// node_modules/smart-chat-obsidian/src/components/message_user.js
var import_obsidian41 = require("obsidian");
function build_html32(completion, opts = {}) {
  const text = completion.data.user_message || "";
  return `
    <div class="smart-chat-message user">
      <div class="smart-chat-message-content">
        ${text}
      </div>
    </div>
  `;
}
async function render40(completion, opts = {}) {
  const html = await build_html32.call(this, completion, opts);
  const frag = this.create_doc_fragment(html);
  post_process34.call(this, completion, frag, opts);
  return frag;
}
async function post_process34(completion, frag, opts = {}) {
  const content = frag.querySelector(".smart-chat-message-content");
  this.empty(content);
  const plugin = completion.env.smart_chat_plugin || completion.env.smart_connections_plugin;
  await import_obsidian41.MarkdownRenderer.render(
    plugin.app,
    completion.data.user_message,
    content,
    "",
    new import_obsidian41.Component()
  );
  return frag;
}

// node_modules/smart-chat-obsidian/src/components/overlay_requires_settings.js
function build_html33(opts = {}) {
  return `
    <div class="smart-chat-confirm-missing-config-overlay" style="
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(0,0,0,0.6);
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      z-index: 9999;
    ">
      <div class="smart-chat-confirm-missing-config-dialog" style="
        background: var(--background-primary);
        border: 1px solid var(--background-modifier-border);
        padding: 16px;
        border-radius: 6px;
        max-width: 420px;
        text-align: center;
      ">
        <p style="margin-bottom: 12px; font-size: var(--font-ui-medium);">
          ${opts?.message || "No chat model configured or missing API key. Please update your Smart Chat settings."}
        </p>
        <div style="display: flex; gap: 12px; justify-content: center;">
          <button class="smart-chat-open-settings">
            Open Settings
          </button>
        </div>
      </div>
    </div>
  `;
}
async function render41(chat_thread, opts = {}) {
  const html = build_html33.call(this, opts);
  const frag = this.create_doc_fragment(html);
  post_process35.call(this, chat_thread, frag, opts);
  return frag;
}
function post_process35(chat_thread, frag, opts = {}) {
  const overlayEl = frag.querySelector(".smart-chat-confirm-missing-config-overlay");
  if (!overlayEl) return frag;
  const openSettingsBtn = overlayEl.querySelector(".smart-chat-open-settings");
  if (openSettingsBtn) {
    openSettingsBtn.addEventListener("click", (e) => {
      e.preventDefault();
      chat_thread.collection.open_settings();
      overlayEl.remove();
    });
  }
  return frag;
}

// node_modules/smart-chat-obsidian/src/components/thread.css
var css_sheet8 = new CSSStyleSheet();
css_sheet8.replaceSync(`.smart-chat-thread {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  position: relative;
  overflow: hidden;
  max-height: 100%;
  /* watermark */
  /* background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='300' height='50' viewBox='0 0 300 50'%3E%3Ctext x='50%25' y='50%25' font-family='Arial, sans-serif' font-size='24' font-weight='bold' fill='rgba(255, 255, 255, 0.07)' text-anchor='middle' dominant-baseline='middle'%3ESmart Chat%3C/text%3E%3C/svg%3E"); */
  /* friendly chat icon watermark */
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 24 24' fill='none' stroke='rgba(255, 255, 255, 0.07)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M2 4c0-1.1.9-2 2-2h16c1.1 0 2 .9 2 2v11c0 1.1-.9 2-2 2h-8l-5 4v-4H4c-1.1 0-2-.9-2-2Z'/%3E%3Cpath d='M7 8c.5.3 1.3.3 1.8 0'/%3E%3Cpath d='M15.2 8c.5.3 1.3.3 1.8 0'/%3E%3Cpath d='M8 11.5c1 .8 2.5 1.2 4 1.2s3-.4 4-1.2'/%3E%3C/svg%3E");
  
  background-repeat: no-repeat;
  background-position: center;
  background-size: 13% auto;
}

/* Thread message container area (scrollable) */
.smart-chat-message-container {
  display: flex;
  flex-direction: column;
  gap: var(--size-4-3);
  flex: 1 1 auto;
  overflow-y: auto;
  padding: var(--size-4-4);
  scroll-behavior: smooth;
}

.smart-chat-default-message {
  display: flex;
  align-items: center;
  flex-direction: column;
  color: var(--text-muted);
  font-size: var(--font-ui-medium);
  height: 100%;
  margin-top: auto;
  margin-bottom: auto;
  opacity: 0.7;
  text-align: center;
  padding: var(--size-4-6);
}


.smart-chat-config-error-notice {
  display: none;
}

/* The bottom input row */
.smart-chat-chat-form {
  max-height: 50vh;
  overflow-y: auto;
  flex: 0 0 auto;
  display: flex;
  flex-direction: column; /* stacked: system prompt area, then user input row */
  gap: var(--size-4-2);
  border-top: var(--border-width) solid var(--background-modifier-border);
  padding: var(--size-4-3) var(--size-4-4);
  background: var(--background-secondary);
  position: sticky;
  bottom: 0;
  z-index: var(--layer-menu);

  &:has(.smart-chat-chat-input[data-has-content="false"]) {
    #smart-chat-send-button {
      background-color: var(--interactive-accent-disabled);
      color: var(--text-on-accent-disabled);
      cursor: not-allowed;
    }
  }
}

/* System message container & label. */
.smart-chat-system-message-container {
  display: flex;
  flex-direction: row;
  gap: var(--size-4-1);
  justify-content: space-between;

  [contenteditable]:empty::before {
    content: attr(placeholder);
    color: var(--text-muted);
    pointer-events: none;
    overflow: visible;
  }
  [contenteditable] {
    position: relative;
    flex-grow: 1;
  }
}
.smart-chat-system-message-label {
  cursor: pointer;
  color: var(--text-faint);
  font-size: var(--font-ui-smaller);
  user-select: none;
  /* hide/show controlled in JS */
}
.smart-chat-system-message {
  display: none; /* toggled visible by JS */
  color: var(--text-muted);
  font-size: var(--font-ui-small);
  background: none;
  border: 1px solid var(--background-modifier-border);
  padding: var(--size-4-2);
  border-radius: var(--radius-s);
  outline: none;
  min-height: 1.5em;
}

.smart-chat-chat-input-row {
  display: flex;
  align-items: flex-end;
  gap: var(--size-4-2);
}

.smart-chat-chat-input {
  width: 100%;
  min-height: var(--size-4-5);
  resize: none;
  background: var(--background-modifier-form-field);
  border: var(--border-width) solid var(--background-modifier-border);
  color: var(--text-normal);
  border-radius: var(--radius-s);
  padding: var(--size-4-3);
  transition: border-color var(--anim-duration-fast) var(--anim-motion-smooth);
  font-family: var(--font-text);
  font-size: var(--font-text-size);

  &:empty::before, &[data-has-content="false"]::before {
    content: attr(placeholder);
    color: var(--text-muted);
    pointer-events: none;
    font-size: var(--font-smaller);
  }

  &> span {
    white-space: normal;
  }
}
.smart-chat-chat-input:focus {
  outline: none;
  border-color: var(--interactive-accent-hover);
}

.smart-chat-btn-container {
  display: flex;
  align-items: center;
  gap: var(--size-4-2);
}

#smart-chat-abort-button {
  cursor: pointer;
  color: var(--icon-color);
  transition: color var(--anim-duration-fast) var(--anim-motion-smooth);
}
#smart-chat-abort-button:hover {
  color: var(--icon-color-hover);
}

#smart-chat-send-button {
  background-color: var(--interactive-accent);
  color: var(--text-on-accent);
  border: none;
  border-radius: 50%;
  width: var(--size-4-10);
  height: var(--size-4-10);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: var(--shadow-s);
  transition:
    transform var(--anim-duration-fast) var(--anim-motion-smooth),
    box-shadow var(--anim-duration-fast) var(--anim-motion-smooth);
}
#smart-chat-send-button:hover {
  transform: scale(1.1);
  box-shadow: var(--shadow-m);
}


/* Typing indicator */
.smart-chat-typing-indicator {
  display: none;
  align-items: center;
  height: 24px;
  padding: 0 var(--size-4-4);
  margin-bottom: var(--size-4-3);
  color: var(--text-muted);
}
.smart-chat-typing-dots {
  display: flex;
  gap: var(--size-2-2);
  justify-content: center;
  align-items: center;
}
.smart-chat-typing-dot {
  width: 6px;
  height: 6px;
  background-color: var(--text-muted);
  border-radius: 50%;
  animation: bounce var(--anim-duration-slow) infinite var(--anim-motion-swing);
}
.smart-chat-typing-dot:nth-child(2) {
  animation-delay: var(--anim-duration-fast);
}
.smart-chat-typing-dot:nth-child(3) {
  animation-delay: calc(var(--anim-duration-fast) * 2);
}
@keyframes bounce {
  0%, 80%, 100% {
    transform: scale(0);
  }
  40% {
    transform: scale(1);
  }
}`);
var thread_default = css_sheet8;

// node_modules/smart-chat-obsidian/src/components/thread.js
var import_obsidian42 = require("obsidian");

// node_modules/smart-chat-obsidian/src/utils/insert_text_in_chunks.js
function split_into_chunks(text, size = 1024) {
  const out = [];
  for (let i = 0; i < text.length; i += size) {
    out.push(text.slice(i, i + size));
  }
  return out;
}
function insert_text_in_chunks(el, text, opts = {}) {
  const { chunk_size = 1024 } = opts;
  const chunks = split_into_chunks(text, chunk_size);
  if (!chunks.length) return;
  const sel = window.getSelection();
  const base_range = sel && sel.rangeCount ? sel.getRangeAt(0).cloneRange() : null;
  let idx = 0;
  const step = () => {
    const chunk = chunks[idx++];
    if (!chunk) return;
    if (base_range) {
      const temp_container = document.createDocumentFragment();
      text_to_nodes(chunk).forEach((n) => temp_container.appendChild(n));
      base_range.insertNode(temp_container);
      base_range.collapse(false);
      sel.removeAllRanges();
      sel.addRange(base_range);
    } else {
      const temp_container = document.createDocumentFragment();
      text_to_nodes(chunk).forEach((n) => temp_container.appendChild(n));
      el.appendChild(temp_container);
    }
    window.requestAnimationFrame(step);
  };
  window.requestAnimationFrame(step);
}
function text_to_nodes(txt) {
  return txt.split("\n").flatMap((part, i, arr) => {
    const nodes = [document.createTextNode(part)];
    if (i < arr.length - 1) nodes.push(document.createElement("br"));
    return nodes;
  });
}

// node_modules/smart-chat-obsidian/src/utils/add_items_to_current_context.js
async function add_items_to_current_context(thread, paths = []) {
  const env = thread.env;
  if (!paths.length) return null;
  if (!thread.current_completion) {
    if (typeof thread.init_completion === "function") {
      thread.current_completion = thread.init_completion();
    } else if (typeof thread.new_completion === "function") {
      thread.new_completion();
    }
  }
  const completion = thread.current_completion;
  const ctx_key = completion.data.context_key;
  const ctx = ctx_key ? env.smart_contexts.get(ctx_key) : null;
  const items_obj = Object.fromEntries(
    [
      ...ctx ? Object.keys(ctx.data.context_items) : [],
      ...paths
    ].map((p) => [p, { d: 0 }])
  );
  const new_ctx = ctx ? (ctx.data.context_items = items_obj, ctx.queue_save(), ctx) : env.smart_contexts.new_context({ context_items: items_obj });
  completion.data.context_key = new_ctx.key;
  completion.queue_save();
  thread.queue_save();
  await env.smart_contexts.process_save_queue();
  return new_ctx;
}

// node_modules/smart-chat-obsidian/src/utils/parse_dropped_data.js
function parse_dropped_data(dt) {
  const out = /* @__PURE__ */ new Set();
  if (dt?.files?.length) {
    [...dt.files].forEach((f) => {
      const p = f.path || f.name;
      if (p) out.add(p);
    });
  }
  const split_lines = (str) => (str ?? "").split(/\r?\n/u).map((s) => s.trim()).filter(Boolean);
  let rows = [
    ...split_lines(dt?.getData("text/uri-list")),
    ...split_lines(dt?.getData("text/plain"))
  ];
  const flatten_obsidian_uris = (arr) => arr.flatMap((row) => {
    if (row.startsWith("obsidian://")) {
      return row.split(/(?=obsidian:\/\/)/g).map((s) => s.trim()).filter(Boolean);
    }
    return [row];
  });
  const mergedRows = [];
  for (let i = 0; i < rows.length; i++) {
    if (rows[i].startsWith("obsidian:") && !rows[i].startsWith("obsidian://") && i + 1 < rows.length && rows[i + 1].startsWith("/")) {
      mergedRows.push(rows[i] + rows[i + 1]);
      i++;
    } else {
      mergedRows.push(rows[i]);
    }
  }
  rows = flatten_obsidian_uris(mergedRows);
  rows.forEach((row) => {
    if (row.startsWith("obsidian://")) {
      try {
        const url = new URL(row);
        let file = url.searchParams.get("file");
        if (file) {
          if (!/\.[^./\\]+$/.test(file)) file += ".md";
          out.add(file);
          return;
        }
      } catch (_) {
      }
      const match = row.match(/file=([^&\s]+)/u);
      if (match) {
        let file = decodeURIComponent(match[1]);
        if (!/\.[^./\\]+$/.test(file)) file += ".md";
        out.add(file);
      }
      return;
    }
    let val = row;
    if (val && !/[./\\]/.test(val.slice(-4)) && // crude: no .ext or / at end
    !/\.[^./\\]+$/.test(val)) {
      val += ".md";
    }
    out.add(val);
  });
  return out;
}

// node_modules/smart-chat-obsidian/src/components/thread.js
function should_send_message(e, requiredModifier) {
  const pressed_shift = import_obsidian42.Keymap.isModifier(e, "Shift");
  const pressed_mod = import_obsidian42.Keymap.isModifier(e, "Mod");
  const pressed_alt = import_obsidian42.Keymap.isModifier(e, "Alt");
  const pressed_meta = import_obsidian42.Keymap.isModifier(e, "Meta");
  if (requiredModifier === "none") {
    return !pressed_shift && !pressed_mod && !pressed_alt && !pressed_meta;
  }
  if (requiredModifier === "shift") return pressed_shift;
  if (requiredModifier === "mod") return pressed_mod;
  if (requiredModifier === "alt") return pressed_alt;
  if (requiredModifier === "meta") return pressed_meta;
  return false;
}
function build_html34(chat_thread, opts = {}) {
  return `<div>
    <div class="smart-chat-thread" data-thread-key="${chat_thread.key}">
      <div class="smart-chat-message-container"></div>
      <div class="smart-chat-typing-indicator">
        <div class="smart-chat-typing-dots">
          <div class="smart-chat-typing-dot"></div>
          <div class="smart-chat-typing-dot"></div>
          <div class="smart-chat-typing-dot"></div>
        </div>
      </div>
      <div class="smart-chat-chat-form">
        <div class="smart-chat-build-chat-context"></div>
        <div class="smart-chat-system-message-container">
          <small class="smart-chat-system-message-label">Edit system message</small>
          <div
            class="smart-chat-system-message"
            contenteditable="true"
            placeholder="Edit system message"
          ></div>
        </div>
        <div class="smart-chat-chat-input-row">
          <div
            contenteditable="true"
            class="smart-chat-chat-input"
            data-has-content="false"
            placeholder="Use @ to add context. eg Based on my notes"
          ></div>
          <div class="smart-chat-btn-container">
            <button class="send-button" id="smart-chat-send-button">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                fill="none" viewBox="0 0 24 24" stroke="currentColor"
                stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M22 2 11 13 3 9l19-7z"></path>
                <path d="M22 2 15 22l-4-9-8-4z"></path>
              </svg>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>`;
}
async function render42(chat_thread, opts = {}) {
  if (!chat_thread.container) {
    const html = build_html34.call(this, chat_thread, opts);
    const frag = this.create_doc_fragment(html);
    this.apply_style_sheet(thread_default);
    chat_thread.container = frag.querySelector(".smart-chat-thread");
  }
  post_process36.call(this, chat_thread, chat_thread.container, opts);
  return chat_thread.container;
}
async function post_process36(chat_thread, thread_container, opts = {}) {
  const env = chat_thread.env;
  const plugin = env.smart_chat_plugin || env.smart_connections_plugin;
  const message_container = chat_thread.container.querySelector(".smart-chat-message-container");
  chat_thread.message_container = message_container;
  if (chat_thread.completions?.length > 0) {
    for (const completion_item of chat_thread.completions) {
      const completion_frag = await completion_item.env.render_component("completion", completion_item, {});
      message_container.appendChild(completion_frag);
    }
  } else {
    const initial_message = get_initial_message2(chat_thread.settings.language);
    this.safe_inner_html(message_container, `
      <div class="smart-chat-default-message">${initial_message}</div>
    `);
    if (!chat_thread.current_completion.container) {
      const completion_container = await env.render_component("completion", chat_thread.current_completion);
      message_container.appendChild(completion_container);
    }
  }
  const send_button = chat_thread.container.querySelector("#smart-chat-send-button");
  const input_el = chat_thread.container.querySelector(".smart-chat-chat-input");
  const system_editor = chat_thread.container.querySelector(".smart-chat-system-message");
  const system_label = chat_thread.container.querySelector(".smart-chat-system-message-label");
  if (system_label && system_editor) {
    system_label.addEventListener("click", () => {
      system_editor.style.display = "block";
      system_label.style.display = "none";
    });
  }
  const do_send = () => {
    const user_text = input_el.textContent.trim();
    if (!user_text) return;
    const sys_msg = system_editor.textContent.trim();
    const data = { user_message: user_text, new_user_message: true };
    if (sys_msg) data.system_message = chat_thread.get_system_prompt({ system_message: sys_msg });
    if (chat_thread.has_self_referential_pronoun(user_text)) {
      const ctx_key = chat_thread.current_completion.data.context_key;
      const existing_ctx = env.smart_contexts.get(ctx_key);
      const has_manual_context = existing_ctx && Object.keys(existing_ctx.data?.context_items ?? {}).length > 0;
      if (!has_manual_context) {
        const action_property = chat_thread.collection.settings.use_tool_calls ? "action_key" : "action_xml_key";
        data[action_property] = "lookup_context";
        data.action_opts = { context_key: ctx_key };
      }
      console.log({ data });
    }
    chat_thread.current_completion.data = { ...chat_thread.current_completion.data, ...data };
    env.render_component("completion", chat_thread.current_completion);
    this.safe_inner_html(input_el, "<br>");
    input_el.dataset.hasContent = false;
    system_editor.textContent = "";
    system_editor.style.display = "none";
    system_label.style.display = "inline";
  };
  send_button.addEventListener("click", (e) => {
    e.preventDefault();
    do_send();
  });
  input_el.addEventListener("keydown", (e) => {
    if (e.key === "@") {
      e.preventDefault();
      ContextSelectorModal.open(
        env,
        {
          ctx: chat_thread.current_completion ? env.smart_contexts.get(
            chat_thread.current_completion.data.context_key
          ) : null,
          opener_container: () => chat_thread.current_completion?.context_elm
        }
      );
      return;
    }
    if (e.key !== "Enter") return;
    const mod_key_setting = chat_thread.settings.modifier_key_to_send || "shift";
    if (should_send_message(e, mod_key_setting)) {
      e.preventDefault();
      do_send();
    } else {
      e.preventDefault();
      document.execCommand("insertHTML", false, "<br><br>");
    }
  });
  input_el.addEventListener("keyup", () => {
    input_el.dataset.hasContent = input_el.textContent.trim().length > 0;
  });
  input_el.addEventListener("paste", (e) => {
    e.preventDefault();
    const text = e.clipboardData.getData("text/plain");
    if (text) {
      insert_text_in_chunks(input_el, text, { chunk_size: 2048 });
      input_el.dataset.hasContent = true;
    }
  });
  const sc_thread_el = chat_thread.container;
  if (sc_thread_el) {
    sc_thread_el.addEventListener("dragover", (ev) => ev.preventDefault());
    sc_thread_el.addEventListener("drop", async (ev) => {
      ev.preventDefault();
      const paths = [...parse_dropped_data(ev.dataTransfer)];
      if (!paths.length) return;
      const updated_ctx = await add_items_to_current_context(chat_thread, paths);
      const target_elm = chat_thread.current_completion?.context_elm;
      if (target_elm) {
        send_context_changed_event(target_elm, updated_ctx);
      } else {
        console.warn("[smart-chat-obsidian] No current completion context element found for context update");
      }
    });
  }
  if (chat_thread.confirm_deletion) {
    const overlay_frag = await env.render_component("confirm_delete", chat_thread, opts);
    chat_thread.container.appendChild(overlay_frag);
  }
  const chat_model_config = env.smart_chat_threads?.settings?.chat_model;
  const platform_key = chat_model_config?.adapter;
  const model_config = chat_model_config?.[platform_key];
  const missing_api_key = (!model_config?.api_key || model_config.api_key.length === 0) && !["ollama", "lm_studio"].includes(platform_key);
  if (!platform_key || missing_api_key) {
    const missing_opts = {
      message: missing_api_key ? `No API key detected for ${platform_key}. Please update your Smart Chat settings.` : "No chat model selected. Please pick a model in the Smart Chat settings."
    };
    const overlay_frag = await env.render_component("overlay_requires_settings", chat_thread, missing_opts);
    chat_thread.container.appendChild(overlay_frag);
  }
  return thread_container;
}

// node_modules/smart-chat-obsidian/smart_env.config.js
var smart_env_config5 = {
  collections: {
    smart_actions: smart_actions_default2,
    smart_chat_threads: smart_chat_threads_default,
    smart_completions: smart_completions_default,
    smart_contexts: smart_contexts_default
  },
  item_types: {
    SmartAction,
    SmartChatThread
  },
  components: {
    chat: render30,
    chat_context_builder: render31,
    chat_model_settings: render32,
    chat_thread_settings: render33,
    completion: render34,
    confirm_delete: render35,
    message_action: render36,
    message_assistant: render37,
    message_model_info: render38,
    message_system: render39,
    message_user: render40,
    overlay_requires_settings: render41,
    thread: render42
  }
};

// node_modules/smart-context-obsidian/src/components/context_builder.css
var css_sheet9 = new CSSStyleSheet();
css_sheet9.replaceSync(`.sc-context-builder {
  padding: 6px 8px;
  display: flex;
  flex: 0 1 auto;
  flex-direction: column;
  width: 100%;
  overflow: auto;
  &.modal {
    max-height: 50%;
  }
  .sc-context-header {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    .sc-context-actions {
      display: flex;
      align-items: center;
      gap: 6px;
    }
  }
  .sc-context-body {
    flex: 1 1 auto;
    overflow: auto;
  }
  .sc-context-footer {
    flex: 0 1 auto;
    .sc-context-actions {
      display: flex;
      align-items: center;
      gap: 6px;
      justify-content: flex-end;
    }
  }
}


.sc-context-tree ul {
  list-style: none;
  margin: 0 0 0 .8em;
  padding: 0;
}
.sc-context-tree .sc-tree-item {
  gap: 4px;
  padding: 2px 0;
  overflow: auto;

  &.dir {
    &> span {
      opacity: 0.8;
    }
    &> span::after {
      content: '/';
    }
  }
  .sc-tree-label {
    cursor: pointer;
  }
}
.sc-context-tree .sc-tree-remove,
.sc-context-tree .sc-tree-connections,
.sc-context-tree .sc-tree-links {
  cursor: pointer;
  opacity: .8;
}
.sc-context-tree .sc-tree-remove:hover,
.sc-context-tree .sc-tree-connections:hover,
.sc-context-tree .sc-tree-links:hover {
  opacity: 1;
}`);
var context_builder_default2 = css_sheet9;

// node_modules/smart-context-obsidian/src/components/context_builder.js
function build_html35(ctx, opts = {}) {
  return `<div>
    <div class="sc-context-builder" data-context-key="${ctx.data.key}">
      <div class="sc-context-header">
        <div class="sc-context-actions"></div>
      </div>
      <div class="sc-context-body">
      </div>
      <div class="sc-context-footer">
        <div class="sc-context-stats"></div>
      </div>
    </div>
  </div>`;
}
async function render43(ctx, opts = {}) {
  const html = build_html35.call(this, ctx, opts);
  const frag = this.create_doc_fragment(html);
  const ctx_container = frag.querySelector(".sc-context-builder");
  this.apply_style_sheet(context_builder_default2);
  await post_process37.call(this, ctx, ctx_container, opts);
  return ctx_container;
}
async function post_process37(ctx, container, opts = {}) {
  const env = ctx.env;
  const body = container.querySelector(".sc-context-body");
  const footer = container.querySelector(".sc-context-footer");
  container.addEventListener("smart-env:context-updated", async (e) => {
    const new_tree = await env.render_component("context_tree", ctx, {
      ...opts
    });
    this.empty(body);
    body.appendChild(new_tree);
    const new_stats = await env.render_component("context_stats", ctx, opts);
    this.empty(footer);
    footer.appendChild(new_stats);
  });
  const tree_container = await env.render_component("context_tree", ctx, {
    ...opts
  });
  this.empty(body);
  body.appendChild(tree_container);
  const stats_container = await env.render_component("context_stats", ctx, opts);
  this.empty(footer);
  footer.appendChild(stats_container);
}

// node_modules/smart-context-obsidian/src/components/context_stats.js
function estimate_tokens(char_count) {
  return Math.ceil(char_count / 4);
}
var get_selected_items = (ctx) => Object.keys(ctx?.data?.context_items || {}).map((k) => ({ path: k }));
function build_html36(ctx) {
  return `<div>
    <div class="sc-stats" aria-live="polite"></div>
  </div>`;
}
async function render44(ctx, opts = {}) {
  const html = build_html36(ctx);
  const frag = this.create_doc_fragment(html);
  const container = frag.querySelector(".sc-stats");
  post_process38.call(this, ctx, container, opts);
  return container;
}
async function post_process38(ctx, container, opts = {}) {
  const items = get_selected_items(ctx);
  if (!items.length) {
    return;
  }
  const { stats } = await ctx.compile({ link_depth: 0, calculating: true });
  const total_chars = stats.char_count;
  const total_tokens = estimate_tokens(total_chars);
  container.textContent = `\u2248 ${total_chars.toLocaleString()} chars \xB7 ${total_tokens.toLocaleString()} tokens`;
  return container;
}

// node_modules/smart-context-obsidian/src/utils/build_context_items_tree_html.js
function build_context_items_tree_html(items) {
  const tree_root = build_path_tree(items);
  const selected_set = new Set(items.map((it) => it.path));
  const tree_list_html = tree_to_html(tree_root, selected_set);
  return tree_list_html;
}
function build_path_tree(selected_items = []) {
  const split_path_segments = (item_path) => {
    const BLOCK_ID_RE = /#\{\d+\}$/u;
    let remainder = item_path;
    let block_id_seg = null;
    let block_key_seg = null;
    let has_block = false;
    const id_match = remainder.match(BLOCK_ID_RE);
    if (id_match) {
      block_id_seg = id_match[0];
      remainder = remainder.slice(0, -block_id_seg.length);
      has_block = true;
    }
    const key_idx = remainder.indexOf("##");
    if (key_idx !== -1) {
      block_key_seg = remainder.slice(key_idx);
      remainder = remainder.slice(0, key_idx);
      has_block = true;
    }
    const segments = [];
    if (remainder) {
      let seg = "";
      let in_wikilink = false;
      for (let i = 0; i < remainder.length; i++) {
        if (!in_wikilink && remainder.slice(i, i + 2) === "[[") {
          in_wikilink = true;
          seg += "[[";
          i++;
        } else if (in_wikilink && remainder.slice(i, i + 2) === "]]") {
          in_wikilink = false;
          seg += "]]";
          i++;
        } else if (!in_wikilink && remainder[i] === "/") {
          segments.push(seg);
          seg = "";
        } else {
          seg += remainder[i];
        }
      }
      if (seg) segments.push(seg);
    }
    if (block_key_seg) segments.push(block_key_seg);
    if (block_id_seg) segments.push(block_id_seg);
    return { segments, has_block };
  };
  const root = { name: "", children: {}, selected: false };
  const is_redundant = (p, selected_folders2) => selected_folders2.some((folder) => p.startsWith(`${folder}/`));
  const selected_folders = selected_items.filter((it) => {
    const for_ext_check = it.path.includes("##") ? it.path.split("#")[0] : it.path;
    return !for_ext_check.match(/\.[a-zA-Z0-9]+$/u);
  }).map((it) => it.path);
  for (const { path } of selected_items) {
    if (is_redundant(path, selected_folders.filter((p) => p !== path))) continue;
    const { segments, has_block } = split_path_segments(path);
    let node = root;
    let running = "";
    segments.forEach((seg, idx) => {
      running = running ? `${running}/${seg}` : seg;
      if (seg.startsWith("external:..")) return;
      const is_last = idx === segments.length - 1;
      const is_block_leaf = is_last && has_block;
      if (!node.children[seg]) {
        node.children[seg] = {
          name: seg,
          path: is_block_leaf ? path : running,
          // For blocks we store an empty *array* so AVA can assert `children.length === 0`
          children: is_block_leaf ? [] : {},
          selected: false,
          is_file: is_block_leaf || is_last && seg.includes(".")
        };
      }
      node = node.children[seg];
      if (is_last) node.selected = true;
    });
  }
  return root;
}
function tree_to_html(node, selected_paths) {
  if (!node.children || !Object.keys(node.children).length) return "";
  const child_html = Object.values(node.children).sort((a, b) => {
    if (a.is_file !== b.is_file) return a.is_file ? 1 : -1;
    return a.name.localeCompare(b.name);
  }).map((child) => {
    let remove_btn = "";
    let connections_btn = "";
    let links_btn = "";
    if (selected_paths.has(child.path)) {
      remove_btn = `<span class="sc-tree-remove" data-path="${child.path}">\xD7</span>`;
      if (!child.path.startsWith("external:../")) {
        connections_btn = `<span class="sc-tree-connections" data-path="${child.path}" title="Connections for ${child.name}"></span>`;
        links_btn = `<span class="sc-tree-links" data-path="${child.path}" title="Links for ${child.name}"></span>`;
      }
    }
    const li_inner = `
        ${remove_btn}
        <span class="sc-tree-label">${child.name}</span>
        ${connections_btn}
        ${links_btn}
        ${tree_to_html(child, selected_paths)}
      `;
    return `<li data-path="${child.path}" class="sc-tree-item ${child.is_file ? "file" : "dir"}${child.path?.startsWith("external:") ? " sc-external" : ""}">${li_inner}</li>`;
  }).join("");
  return `<ul>${child_html}</ul>`;
}

// node_modules/smart-context-obsidian/src/components/context_tree.css
var css_sheet10 = new CSSStyleSheet();
css_sheet10.replaceSync(`.sc-context-tree ul {
  list-style: none;
  margin: 0 0 0 .8em;
  padding: 0;
}
.sc-context-tree .sc-tree-item {
  gap: 4px;
  padding: 2px 0;
  overflow: auto;
}

.sc-context-tree .sc-tree-item.expandable > .sc-tree-label::before {
  content: '\u25BE';
  display: inline-block;
  width: 1em;
  margin-right: 2px;
  cursor: pointer;
}

.sc-context-tree .sc-tree-item.collapsed > .sc-tree-label::before {
  content: '\u25B8';
}

.sc-context-tree .sc-tree-item.collapsed > ul {
  display: none;
}

.sc-context-tree .sc-tree-item.dir > span {
  opacity: 0.8;
}
.sc-context-tree .sc-tree-item.dir > span::after {
  content: '/';
}
.sc-context-tree .sc-tree-label {
  cursor: pointer;
}
.sc-context-tree .sc-tree-remove,
.sc-context-tree .sc-tree-connections,
.sc-context-tree .sc-tree-links {
  cursor: pointer;
  opacity: .8;
}
.sc-context-tree .sc-tree-remove:hover,
.sc-context-tree .sc-tree-connections:hover,
.sc-context-tree .sc-tree-links:hover {
  opacity: 1;
}

.sc-tree-remove, 
.sc-tree-connections, 
.sc-tree-links {
  display: inline-flex;
  width: 20px;
  justify-content: space-around;
  align-items: center;
  border-radius: 5px;
  border: 1px solid transparent;
  transition: all 0.2s ease; /* Smooth transition for hover effects */
}

.sc-tree-remove:hover,
.sc-tree-connections:hover,
.sc-tree-links:hover {
  border-color: var(--interactive-accent);
}


/* * Hover state for tree elements that should change text/icon color.
 * This includes the label and the connection/link icons.
 */
.sc-tree-label:hover,
.sc-tree-connections:hover,
.sc-tree-links:hover {
  color: var(--text-accent);
}

.smart-block-popover {
  z-index: 999999;
}`);
var context_tree_default = css_sheet10;

// node_modules/smart-context-obsidian/node_modules/smart-sources/actions/get_links_to_depth.js
var LINK_DIRECTIONS = (
  /** @type {const} */
  {
    OUT: "out",
    IN: "in",
    BOTH: "both"
  }
);
function get_links_to_depth(target_source, max_depth = 1, {
  direction = LINK_DIRECTIONS.OUT,
  include_self = false
} = {}) {
  if (!target_source || typeof target_source !== "object" || !target_source.collection) {
    return [];
  }
  const collection = target_source.collection;
  const links_map = collection.links || {};
  const visited = /* @__PURE__ */ new Set();
  const results = [];
  const enqueue = (src, d) => {
    if (!src) return;
    if (visited.has(src.key)) return;
    visited.add(src.key);
    queue.push({ src, depth: d });
    results.push({ depth: d, item: src });
  };
  const queue = [{ src: target_source, depth: 0 }];
  if (include_self) {
    visited.add(target_source.key);
    results.push({ depth: 0, item: target_source });
  }
  while (queue.length) {
    const current = queue.shift();
    if (current.depth >= max_depth) continue;
    const nextDepth = current.depth + 1;
    if (direction === LINK_DIRECTIONS.OUT || direction === LINK_DIRECTIONS.BOTH) {
      for (const path of current.src.outlinks) {
        enqueue(collection.get(path), nextDepth);
      }
    }
    if (direction === LINK_DIRECTIONS.IN || direction === LINK_DIRECTIONS.BOTH) {
      const inlink_paths = Object.keys(links_map[current.src.path] || {});
      for (const p of inlink_paths) {
        enqueue(collection.get(p), nextDepth);
      }
    }
  }
  return results;
}

// node_modules/smart-context-obsidian/node_modules/obsidian-smart-env/utils/open_note.js
var import_obsidian43 = require("obsidian");
async function open_note2(plugin, target_path, event = null, opts = {}) {
  const { new_tab = false } = opts;
  const env = plugin.env;
  if (target_path.includes(".pdf#page=")) {
    return plugin.app.workspace.openLinkText(target_path, "/");
  }
  if (target_path.endsWith("#")) target_path = target_path.slice(0, -1);
  let target_file;
  let block = null;
  if (target_path.includes("#")) {
    const [file_path] = target_path.split("#");
    target_file = plugin.app.metadataCache.getFirstLinkpathDest(file_path, "");
    block = env.smart_blocks.get(target_path);
  } else {
    target_file = plugin.app.metadataCache.getFirstLinkpathDest(target_path, "");
  }
  if (!target_file) {
    console.warn(`[open_note] Unable to resolve file for ${target_path}`);
    return;
  }
  let leaf;
  if (event) {
    const is_mod = import_obsidian43.Keymap.isModEvent(event);
    const is_alt = import_obsidian43.Keymap.isModifier(event, "Alt");
    if (is_mod && is_alt) {
      leaf = plugin.app.workspace.splitActiveLeaf("vertical");
    } else if (is_mod || new_tab) {
      leaf = plugin.app.workspace.getLeaf(true);
    } else {
      leaf = plugin.app.workspace.getMostRecentLeaf();
    }
  } else {
    leaf = plugin.app.workspace.getMostRecentLeaf();
  }
  await leaf.openFile(target_file);
  if (typeof block?.line_start === "number") {
    const { editor } = leaf.view;
    const pos = { line: block.line_start, ch: 0 };
    editor.setCursor(pos);
    editor.scrollIntoView({ to: pos, from: pos }, true);
  }
}

// node_modules/smart-context-obsidian/src/components/context_tree.js
var import_obsidian46 = require("obsidian");

// node_modules/smart-context-obsidian/src/views/context_selector_modal.js
var import_obsidian44 = require("obsidian");

// node_modules/smart-context-obsidian/node_modules/smart-file-system/utils/ignore.js
var TEXT_FILE_EXTENSIONS2 = [
  ".asm",
  ".bat",
  ".c",
  ".cfg",
  ".clj",
  ".conf",
  ".cpp",
  ".cs",
  ".css",
  ".csv",
  ".d",
  ".dart",
  ".ejs",
  ".elm",
  ".erl",
  ".f",
  ".go",
  ".gradle",
  ".groovy",
  ".h",
  ".hbs",
  ".hpp",
  ".hs",
  ".html",
  ".ini",
  ".jade",
  ".java",
  ".js",
  ".json",
  ".jsx",
  ".kt",
  ".less",
  ".lisp",
  ".log",
  ".lua",
  ".m",
  ".makefile",
  ".md",
  ".mdx",
  ".ml",
  ".mjs",
  ".mustache",
  ".pas",
  ".php",
  ".pl",
  ".properties",
  ".pug",
  ".py",
  ".r",
  ".rb",
  ".rs",
  ".sass",
  ".scala",
  ".scheme",
  ".scss",
  ".sh",
  ".sql",
  ".svelte",
  ".swift",
  ".tcl",
  ".tex",
  ".tpl",
  ".ts",
  ".tsx",
  ".twig",
  ".txt",
  ".vb",
  ".vue",
  ".xml",
  ".yaml",
  ".yml",
  ".canvas"
];
var NO_EXTENSION_TEXT_FILES2 = [
  "Dockerfile",
  "Appfile",
  "Matchfile",
  "Deliverfile",
  "Gymfile",
  "Fastfile",
  "Gemfile",
  "Guardfile",
  "Jenkinsfile",
  "Makefile",
  "Procfile",
  "Rakefile"
];
function is_text_file2(file_path) {
  const last_dot_index = file_path.lastIndexOf(".");
  if (last_dot_index === -1) {
    if (NO_EXTENSION_TEXT_FILES2.some((file) => file_path.endsWith(file))) {
      return true;
    }
    return false;
  }
  const ext = file_path.substring(last_dot_index).toLowerCase();
  return TEXT_FILE_EXTENSIONS2.includes(ext);
}

// node_modules/smart-context-obsidian/src/utils/get_all_leaves.js
function get_all_leaves2(app2) {
  const leaves = [];
  const recurse = (container) => {
    if (container.children) {
      for (const child of container.children) {
        recurse(child);
      }
    }
    if (container.type === "leaf") {
      leaves.push(container);
    }
  };
  recurse(app2.workspace.rootSplit);
  return leaves;
}

// node_modules/smart-context-obsidian/src/utils/get_all_open_file_paths.js
function get_all_open_file_paths2(app2) {
  const leaves = get_all_leaves2(app2);
  const files_set = [];
  for (const leaf of leaves) {
    const file_path = leaf.view?.state?.file ?? leaf.view?.file?.path;
    if (file_path && is_text_file2(file_path)) {
      files_set.push(file_path);
    }
  }
  return files_set;
}

// node_modules/smart-context-obsidian/src/utils/is_leaf_visible.js
function is_leaf_visible2(leaf) {
  const parent = leaf.parent;
  if (!parent) {
    return leaf.containerEl && leaf.containerEl.offsetParent !== null;
  }
  if ("activeTab" in parent) {
    return parent.activeTab === leaf && leaf.containerEl && leaf.containerEl.offsetParent !== null;
  }
  return leaf.containerEl && leaf.containerEl.offsetParent !== null;
}

// node_modules/smart-context-obsidian/src/utils/get_visible_open_files.js
function get_visible_open_files2(app2) {
  const leaves = get_all_leaves2(app2);
  const visible_files = /* @__PURE__ */ new Set();
  for (const leaf of leaves) {
    if (!is_leaf_visible2(leaf)) continue;
    const file = leaf.view?.file;
    if (file && is_text_file2(file.path)) {
      visible_files.add(file);
    }
  }
  return [...visible_files].map((file) => file.path);
}

// node_modules/smart-context-obsidian/src/utils/send_context_changed_event.js
function send_context_changed_event2(container, next_ctx) {
  container.dispatchEvent(new CustomEvent("smart-env:context-changed", {
    detail: { context: next_ctx },
    bubbles: true,
    composed: true
  }));
}

// node_modules/smart-context-obsidian/src/views/context_selector_modal.js
var ContextSelectorModal2 = class extends import_obsidian44.FuzzySuggestModal {
  static open(env, opts) {
    const plugin = env.smart_context_plugin || env.smart_chat_plugin || env.smart_connections_plugin || env.plugin;
    if (!env.context_selector_modal) {
      if (env.smart_context_plugin?.ContextSelectorModal) {
        env.context_selector_modal = new env.smart_context_plugin.ContextSelectorModal(plugin, opts);
      } else env.context_selector_modal = new this(plugin, opts);
    }
    env.context_selector_modal.open(opts);
    return env.context_selector_modal;
  }
  static close(env) {
    env.context_selector_modal.close(true);
    env.context_selector_modal = null;
  }
  /**
   * @param {import('../../main.js').default} plugin
   * @param {Object} [opts={}]
   * @param {SmartContext} [opts.ctx]
   */
  constructor(plugin, opts = {}) {
    super(plugin.app);
    this.app = plugin.app;
    this.plugin = plugin;
    this.opts = opts;
    this.ctx = opts.ctx ?? null;
    this.setInstructions([
      { command: "Enter", purpose: "Add to context" },
      { command: "\u2318/Ctrl + Enter", purpose: "Open named context in builder" },
      { command: "Esc", purpose: "Close" }
    ]);
    this.plugin.env.create_env_getter(this);
    this.mod_key_was_held = false;
    this.containerEl.addEventListener("keydown", (e) => {
      if (e.key === "Escape") this.close(true);
    });
    this.modalEl.addEventListener("keydown", (e) => {
      this.mod_key_was_held = import_obsidian44.Keymap.isModifier(e, "Mod");
      if (e.key === "Enter") this.selectActiveSuggestion(e);
    });
    this.resultContainerEl.addEventListener("click", (e) => {
      this.mod_key_was_held = import_obsidian44.Keymap.isModifier(e, "Mod");
    });
  }
  /* ───────────────────────────────────────────────────────────── */
  /**
   * Sort an array of context entries according to:
   *   – priority 0 → item has in/out‑links with the current active note
   *   – priority 1 → item modified within the last 24 h
   *   – priority 2 → all remaining items
   * Within each priority group items are ordered alphabetically.
   *
   * @param {Array<Object>} entries
   * @returns {Array<Object>} sorted copy
   */
  sort_context_entries(entries) {
    const active_file = this.app.workspace.getActiveFile();
    let active_src = null;
    if (active_file) {
      active_src = this.env.smart_sources.get(active_file.path);
    }
    const linked_keys = /* @__PURE__ */ new Set();
    if (active_src) {
      active_src.outlinks.forEach((k) => linked_keys.add(k));
      active_src.inlinks.forEach((k) => linked_keys.add(k));
    }
    const recent_cutoff = Date.now() - 24 * 60 * 60 * 1e3;
    const get_key = (entry) => entry?.item?.key || entry?.key || entry?.path || "";
    const get_src = (entry) => entry?.item || entry;
    const priority = (entry) => {
      const key = get_key(entry);
      const src = get_src(entry);
      if (linked_keys.has(key)) return 0;
      if (src?.mtime && src.mtime >= recent_cutoff) return 1;
      return 2;
    };
    return [...entries].sort((a, b) => {
      const pa = priority(a);
      const pb = priority(b);
      if (pa !== pb) return pa - pb;
      return get_key(a).localeCompare(get_key(b));
    });
  }
  /* ───────────────────────────────────────────────────────────── */
  ensure_ctx() {
    if (this.ctx) return this.ctx;
    this.ctx = this.env.smart_contexts.new_context({}, {
      add_items: this.opts.initial_context_items
    });
    return this.ctx;
  }
  async open(opts = this.opts) {
    if (opts.ctx) this.ctx = opts.ctx;
    if (opts.opener_container) this.add_opener_container(opts.opener_container);
    this.opts = opts;
    await this.render();
    super.open();
    this.focus_input();
  }
  async render() {
    this.modalEl.style.display = "flex";
    this.modalEl.style.flexDirection = "column";
    this.modalEl.style.height = "100%";
    const prompt_results = this.modalEl.querySelector(".prompt-results");
    if (prompt_results) {
      prompt_results.style.flex = "1 1 50%";
      prompt_results.style.minHeight = "0";
      prompt_results.style.overflowY = "auto";
    }
    const ctx = this.ensure_ctx();
    const builder_container = await this.env.render_component(
      "context_builder",
      ctx,
      {
        ...this.opts
      }
    );
    builder_container.addEventListener("smart-env:context-changed", (e) => {
      const updated_ctx = e.detail.context;
      this.ctx = updated_ctx;
      this.opts.ctx = updated_ctx;
      this.updateSuggestions();
      this.render();
    });
    builder_container.classList.add("modal");
    const actions_el = builder_container.querySelector(".sc-context-actions");
    if (ctx.has_context_items) {
      const clear_btn = document.createElement("button");
      clear_btn.textContent = "Clear";
      clear_btn.addEventListener("click", () => {
        ctx.data.context_items = {};
        ctx.queue_save();
        ctx.collection.process_save_queue();
        this.updateSuggestions();
        this.render();
      });
      actions_el.appendChild(clear_btn);
      const copy_btn = await this.env.render_component(
        "copy_to_clipboard_button",
        ctx
      );
      actions_el.appendChild(copy_btn);
    }
    if (!actions_el.querySelector('button[data-done="true"]')) {
      const done_btn = document.createElement("button");
      done_btn.dataset.done = "true";
      done_btn.textContent = "Done";
      done_btn.addEventListener("click", () => {
        this.close(true);
      });
      actions_el.appendChild(done_btn);
    }
    this.modalEl.querySelector(".sc-context-builder")?.remove();
    this.modalEl.prepend(builder_container);
  }
  get suggestions() {
    return this.opts.suggestions ?? [];
  }
  set suggestions(suggestions) {
    this.opts.suggestions = suggestions;
  }
  getItems() {
    const suggestions = this.suggestions?.filter(
      (s) => !this.ctx?.data?.context_items[s.item.key]
    );
    if (suggestions?.length) {
      const special_items2 = [];
      special_items2.push({
        name: "Back",
        items: {}
      });
      if (suggestions.some((s) => s.depth)) {
        const depth_1 = suggestions.filter((s) => s.depth <= 1);
        const depth_2 = suggestions.filter((s) => s.depth <= 2);
        const depth_3 = suggestions.filter((s) => s.depth <= 3);
        if (depth_1.length)
          special_items2.push({ name: `Add all to depth 1 (${depth_1.length})`, items: depth_1 });
        if (depth_2.length)
          special_items2.push({ name: `Add all to depth 2 (${depth_2.length})`, items: depth_2 });
        if (depth_3.length)
          special_items2.push({ name: `Add all to depth 3 (${depth_3.length})`, items: depth_3 });
      }
      if (suggestions.some((s) => s.score)) {
        const all_connections = suggestions.filter((s) => s.score);
        special_items2.push({
          name: `Add all connections (${all_connections.length})`,
          items: all_connections
        });
      }
      return [...special_items2, ...suggestions];
    }
    let special_items = this.opts.special_items ?? [];
    const visible_open_files = Array.from(get_visible_open_files2(this.app)).map((f) => {
      return { item: this.env.smart_sources.get(f) };
    });
    if (visible_open_files.length) {
      special_items.push({
        name: "Visible open files",
        items: visible_open_files
      });
      const all_open_files = Array.from(get_all_open_file_paths2(this.app)).map((f) => {
        return { item: this.env.smart_sources.get(f) };
      });
      if (all_open_files.length && visible_open_files.length !== all_open_files.length) special_items.push({
        name: "All open files",
        items: all_open_files
      });
    }
    special_items = special_items.map((i) => {
      if (i.items) {
        i.items = i.items.filter(
          (item) => item.item && !this.ctx?.data?.context_items[item.item.key]
        );
        i.name = `${i.name} (+${i.items.length})`;
      }
      return i;
    }).filter((i) => {
      if (i.items) return i.items.length > 0;
      return true;
    });
    const unselected = Object.values(this.env.smart_sources.items).filter(
      (src) => !this.ctx?.data?.context_items[src.key]
    );
    const sorted_unselected = this.sort_context_entries(unselected);
    return [...special_items, ...sorted_unselected];
  }
  getItemText(item) {
    if (item.score) {
      return `${item.score.toFixed(2)} | ${item.item.path}`;
    }
    if (item.depth) {
      return `${item.depth} | ${item.item.path}`;
    }
    if (item.items && item.name) {
      return item.name;
    }
    return item.path;
  }
  onChooseSuggestion(selection) {
    if (selection.item.name === "Back") {
      this.suggestions = null;
      this.updateSuggestions();
      return;
    }
    this.ensure_ctx();
    if (selection.item.items) {
      for (const special_item of selection.item.items) {
        if (!this.ctx.data.context_items[special_item.item.key]) {
          this.ctx.data.context_items[special_item.item.key] = { d: 0 };
        }
      }
      this.updateSuggestions();
      this.render();
      return;
    }
    const item = selection.item?.item ?? selection.item;
    if (!this.ctx.data.context_items[item.key]) {
      this.ctx.data.context_items[item.key] = { d: 0 };
      this.updateSuggestions();
      this.render();
    }
  }
  focus_input() {
    setTimeout(() => this.inputEl.focus(), 100);
  }
  close(should_close = false) {
    if (should_close) super.close();
  }
  onClose(should_close = false) {
    while (this.opener_containers?.length) {
      const container = this.opener_containers.pop();
      if (container.isConnected) {
        send_context_changed_event2(container, this.ctx);
      }
    }
  }
  /**
   * Add a container to the list of opener containers.
   * This is used to send context changed events when the modal is closed.
   * @param {HTMLElement|NodeList|Array<HTMLElement>|function} container - The container to add.
   * If a function is passed, it will be called to get the container(s).
   */
  add_opener_container(container) {
    if (!this.opener_containers) this.opener_containers = [];
    if (typeof container === "function") container = container();
    if (Array.isArray(container) || container instanceof NodeList) {
      container.forEach((c) => this.add_opener_container(c));
      return;
    }
    if (!(container instanceof HTMLElement)) {
      console.warn("ContextSelectorModal: opener_container must be an HTMLElement, received:", container);
      return;
    }
    if (!this.opener_containers.includes(container)) {
      this.opener_containers.push(container);
    }
  }
  load_suggestions(suggestions) {
    this.suggestions = suggestions;
    this.updateSuggestions();
    this.render();
  }
};

// node_modules/smart-context-obsidian/node_modules/obsidian-smart-env/utils/register_block_hover_popover.js
var import_obsidian45 = require("obsidian");
function register_block_hover_popover2(parent, target, env, block_key, plugin) {
  target.addEventListener("mouseover", async (ev) => {
    if (import_obsidian45.Keymap.isModEvent(ev)) {
      const block = env.smart_blocks.get(block_key);
      const markdown = await block?.read();
      if (markdown) {
        const popover = new import_obsidian45.HoverPopover(parent, target);
        const frag = env.smart_view.create_doc_fragment(`<div class="markdown-embed is-loaded">
                <div class="markdown-embed-content node-insert-event">
                  <div class="markdown-preview-view markdown-rendered node-insert-event show-indentation-guide allow-fold-headings allow-fold-lists">
                    <div class="markdown-preview-sizer markdown-preview-section">
                    </div>
                  </div>
                </div>
              </div>`);
        popover.hoverEl.classList.add("smart-block-popover");
        popover.hoverEl.appendChild(frag);
        const sizer = popover.hoverEl.querySelector(".markdown-preview-sizer");
        import_obsidian45.MarkdownRenderer.render(plugin.app, markdown, sizer, "/", popover);
      }
    }
  });
}

// node_modules/smart-context-obsidian/src/utils/send_context_updated_event.js
function send_context_updated_event(container) {
  container.dispatchEvent(new CustomEvent("smart-env:context-updated", {
    detail: { updated: true },
    bubbles: true,
    composed: true
  }));
}

// node_modules/smart-context-obsidian/src/components/context_tree.js
var test_has_children = (li) => !!li.querySelector(":scope > ul");
var toggle_collapsed = (li) => li.classList.toggle("collapsed");
var setup_collapse_handlers = (container) => {
  container.querySelectorAll(".sc-tree-item.dir").forEach((li) => {
    if (!test_has_children(li)) return;
    li.classList.add("expandable");
    const label = li.querySelector(":scope > .sc-tree-label");
    if (!label) return;
    label.addEventListener("click", (ev) => {
      if (ev.metaKey || ev.ctrlKey) return;
      ev.preventDefault();
      ev.stopPropagation();
      toggle_collapsed(li);
    });
  });
};
var get_selected_items2 = (ctx) => Object.keys(ctx?.data?.context_items || {}).map((k) => ({ path: k }));
function build_html37(ctx) {
  const items = get_selected_items2(ctx);
  const tree_list_html = build_context_items_tree_html(items);
  return `<div>
    <div class="sc-context-tree">${tree_list_html || "<em>No items selected\u2026</em>"}</div>
  </div>`;
}
async function render45(ctx, opts = {}) {
  const html = build_html37(ctx);
  const frag = this.create_doc_fragment(html);
  this.apply_style_sheet(context_tree_default);
  const container = frag.querySelector(".sc-context-tree");
  await post_process39.call(this, ctx, container, opts);
  return container;
}
async function post_process39(ctx, container, opts = {}) {
  const env = ctx?.env;
  const plugin = env?.smart_context_plugin || // uses early-release version if available
  env?.smart_chat_plugin || env?.smart_connections_plugin || env?.plugin;
  const render_tree = () => {
    const items = get_selected_items2(ctx);
    const tree_list_html = build_context_items_tree_html(items);
    this.safe_inner_html(container, tree_list_html || "<em>No items selected\u2026</em>");
    attach_item_handlers();
    setup_collapse_handlers(container);
  };
  container.addEventListener("smart-env:context-updated", (e) => {
    render_tree();
  });
  const attach_item_handlers = () => {
    if (!opts.disable_context_changes) {
      container.querySelectorAll(".sc-tree-remove").forEach((btn) => {
        btn.title = `Remove ${btn.dataset.path}`;
        btn.addEventListener("click", (e) => {
          const p = e.currentTarget.dataset.path;
          delete ctx.data.context_items[p];
          send_context_updated_event(container);
        });
      });
      container.querySelectorAll(".sc-tree-connections").forEach((btn) => {
        if (!btn.dataset.path) return;
        const target = ctx.get_ref(btn.dataset.path);
        if (!target) return;
        const icon = (0, import_obsidian46.getIcon)("smart-connections");
        btn.appendChild(icon);
        btn.addEventListener("click", async (e) => {
          const p = e.currentTarget.dataset.path;
          const target2 = ctx.get_ref(p);
          const connections = await target2.find_connections();
          const modal = ContextSelectorModal2.open(env, {
            ctx,
            opener_container: container
          });
          modal.load_suggestions(connections);
        });
      });
      container.querySelectorAll(".sc-tree-links").forEach((btn) => {
        if (!btn.dataset.path) return;
        const target = ctx.get_ref(btn.dataset.path);
        if (!target) return;
        const links = get_links_to_depth(target, 3);
        if (!links.length) return btn.style.display = "none";
        const icon = (0, import_obsidian46.getIcon)("link");
        btn.appendChild(icon);
        btn.addEventListener("click", () => {
          const p = btn.dataset.path;
          const target2 = ctx.get_ref(p);
          if (!target2) return;
          const links2 = get_links_to_depth(target2, 3);
          const modal = ContextSelectorModal2.open(env, {
            ctx,
            opener_container: container
          });
          modal.load_suggestions(links2);
        });
      });
    }
    container.querySelectorAll(".sc-tree-label").forEach((label) => {
      const li = label.closest(".sc-tree-item");
      if (!li) return;
      const item_path = li.dataset.path;
      if (!item_path) return;
      label.dataset.href = item_path;
      label.dataset.path = item_path;
      label.setAttribute("draggable", "true");
      label.title = item_path;
      if (item_path.includes("{")) {
        register_block_hover_popover2(li, label, env, item_path, plugin);
      } else {
        label.addEventListener("mouseover", async (ev) => {
          plugin?.app?.workspace.trigger("hover-link", {
            event: ev,
            source: "smart-context-tree",
            hoverParent: label.parentElement,
            targetEl: label,
            linktext: item_path
          });
        });
      }
      label.addEventListener("dragstart", (ev) => {
        const file_path = item_path.split("#")[0];
        const file = plugin?.app?.metadataCache?.getFirstLinkpathDest(file_path, "");
        const drag_data = plugin?.app?.dragManager?.dragFile(ev, file);
        plugin?.app?.dragManager?.onDragStart(ev, drag_data);
      });
      if (!li.classList.contains("sc-external")) {
        label.addEventListener("click", (ev) => {
          if (!li.classList.contains("dir") || ev.metaKey || ev.ctrlKey) {
            ev.preventDefault();
            open_note2(plugin, item_path, ev, { new_tab: true });
          }
        });
      }
    });
  };
  render_tree();
  return container;
}

// node_modules/smart-context-obsidian/src/utils/show_stats_notice.js
var import_obsidian47 = require("obsidian");
function show_stats_notice(stats, contextMsg) {
  let noticeMsg = `Copied to clipboard! (${contextMsg})`;
  if (stats) {
    const char_count = stats.char_count < 1e5 ? stats.char_count : `~${Math.round(stats.char_count / 1e3)}k`;
    noticeMsg += `, ${char_count} chars`;
    if (stats.exclusions) {
      const total_excluded = Object.values(stats.exclusions).reduce(
        (p, c) => p + c,
        0
      );
      if (total_excluded > 0) {
        noticeMsg += `, ${total_excluded} section(s) excluded`;
      }
    }
  }
  new import_obsidian47.Notice(noticeMsg);
}

// node_modules/smart-context-obsidian/src/utils/copy_to_clipboard.js
var import_obsidian48 = require("obsidian");
async function copy_to_clipboard(text) {
  try {
    if (navigator?.clipboard?.writeText) {
      await navigator.clipboard.writeText(text);
    } else if (!import_obsidian48.Platform.isMobile) {
      const { clipboard } = require("electron");
      clipboard.writeText(text);
    } else {
      new import_obsidian48.Notice("Unable to copy text: no valid method found.");
    }
  } catch (err) {
    console.error("Failed to copy text:", err);
    new import_obsidian48.Notice("Failed to copy.");
  }
}

// node_modules/smart-context-obsidian/src/components/copy_to_clipboard_button.js
function build_html38() {
  return '<button class="sc-copy-clipboard" type="button">Copy to clipboard</button>';
}
async function render46(ctx) {
  const html = build_html38();
  const frag = this.create_doc_fragment(html);
  const btn = frag.querySelector("button");
  btn.addEventListener("click", async () => {
    const { context, stats, images } = await ctx.compile({ link_depth: 0 });
    await copy_to_clipboard(context, images);
    show_stats_notice(stats, `${Object.keys(ctx.data.context_items).length} file(s)`);
  });
  return frag;
}

// node_modules/smart-context-obsidian/smart_env.config.js
var smart_env_config6 = {
  collections: {},
  item_types: {},
  components: {
    context_builder: render43,
    context_stats: render44,
    context_tree: render45,
    copy_to_clipboard_button: render46
  }
};

// src/sc_settings_tab.js
var import_obsidian49 = require("obsidian");
var ScSettingsTab = class extends import_obsidian49.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
    this.main_settings_container = null;
  }
  get env() {
    return this.plugin.env;
  }
  /**
   * Called by Obsidian to display the settings tab
   */
  display() {
    console.log("displaying settings tab");
    this.render();
  }
  get smart_view() {
    if (!this._smart_view) {
      this._smart_view = new this.plugin.smart_env_config.modules.smart_view.class({
        adapter: this.plugin.smart_env_config.modules.smart_view.adapter
      });
    }
    return this._smart_view;
  }
  async render() {
    await wait_for_env_to_load(this, { wait_for_states: ["loading", "loaded"] });
    this.smart_view.safe_inner_html(this.containerEl, '<div class="sc-loading">Loading main settings...</div>');
    this.plugin.env.render_component("main_settings", this.plugin).then((frag) => {
      this.containerEl.empty();
      this.containerEl.appendChild(frag);
    });
  }
};

// node_modules/obsidian-smart-env/utils/open_note.js
var import_obsidian50 = require("obsidian");
async function open_note3(plugin, target_path, event = null, opts = {}) {
  const { new_tab = false } = opts;
  const env = plugin.env;
  if (target_path.includes(".pdf#page=")) {
    return plugin.app.workspace.openLinkText(target_path, "/");
  }
  if (target_path.endsWith("#")) target_path = target_path.slice(0, -1);
  let target_file;
  let block = null;
  if (target_path.includes("#")) {
    const [file_path] = target_path.split("#");
    target_file = plugin.app.metadataCache.getFirstLinkpathDest(file_path, "");
    block = env.smart_blocks.get(target_path);
  } else {
    target_file = plugin.app.metadataCache.getFirstLinkpathDest(target_path, "");
  }
  if (!target_file) {
    console.warn(`[open_note] Unable to resolve file for ${target_path}`);
    return;
  }
  let leaf;
  if (event) {
    const is_mod = import_obsidian50.Keymap.isModEvent(event);
    const is_alt = import_obsidian50.Keymap.isModifier(event, "Alt");
    if (is_mod && is_alt) {
      leaf = plugin.app.workspace.splitActiveLeaf("vertical");
    } else if (is_mod || new_tab) {
      leaf = plugin.app.workspace.getLeaf(true);
    } else {
      leaf = plugin.app.workspace.getMostRecentLeaf();
    }
  } else {
    leaf = plugin.app.workspace.getMostRecentLeaf();
  }
  await leaf.openFile(target_file);
  if (typeof block?.line_start === "number") {
    const { editor } = leaf.view;
    const pos = { line: block.line_start, ch: 0 };
    editor.setCursor(pos);
    editor.scrollIntoView({ to: pos, from: pos }, true);
  }
}

// node_modules/smart-notices/smart_notices.js
var import_obsidian51 = require("obsidian");

// node_modules/smart-notices/notices.js
var NOTICES2 = {
  item_excluded: {
    en: "Cannot show Smart Connections for excluded entity: {{entity_key}}"
  },
  load_env: {
    en: "Mobile detected: to prevent performance issues, click to load Smart Environment when ready.",
    button: {
      en: `Load Smart Env`,
      callback: (env) => {
        env.load(true);
      }
    },
    timeout: 1e4
  },
  /** @deprecated in favor of in-component insctructions (2025-06-22) */
  missing_entity: {
    en: "No entity found for key: {{key}}"
  },
  notice_muted: {
    en: "Notice muted"
  },
  new_version_available: {
    en: "A new version is available! (v{{version}})",
    timeout: 15e3,
    button: {
      en: "Release notes",
      callback: (scope) => {
        window.open("https://github.com/brianpetro/obsidian-smart-connections/releases", "_blank");
      }
    }
  },
  new_early_access_version_available: {
    en: "A new early access version is available! (v{{version}})"
  },
  supporter_key_required: {
    en: "Supporter license key required for early access update"
  },
  revert_to_stable_release: {
    en: 'Click "Check for Updates" in the community plugins tab and complete the update for Smart Connections to finish reverting to the stable release.',
    timeout: 0
  },
  action_installed: {
    en: 'Installed action "{{name}}"'
  },
  action_install_error: {
    en: 'Error installing action "{{name}}": {{error}}',
    timeout: 0
  },
  embed_model_not_loaded: {
    en: "Embed model not loaded. Please wait for the model to load and try again."
  },
  embed_search_text_failed: {
    en: "Failed to embed search text."
  },
  error_in_embedding_search: {
    en: "Error in embedding search. See console for details."
  },
  copied_to_clipboard: {
    en: "Message: {{content}} copied successfully."
  },
  copy_failed: {
    en: "Unable to copy message to clipboard."
  },
  copied_chatgpt_url_to_clipboard: {
    en: "ChatGPT URL copied to clipboard."
  },
  loading_collection: {
    en: "Loading {{collection_key}}..."
  },
  done_loading_collection: {
    en: "{{collection_key}} loaded."
  },
  saving_collection: {
    en: "Saving {{collection_key}}..."
  },
  initial_scan: {
    en: "[{{collection_key}}] Starting initial scan...",
    timeout: 0
  },
  done_initial_scan: {
    en: "[{{collection_key}}] Initial scan complete.",
    timeout: 3e3
  },
  pruning_collection: {
    en: "Pruning {{collection_key}}..."
  },
  done_pruning_collection: {
    en: "Pruned {{count}} items from {{collection_key}}."
  },
  embedding_progress: {
    en: "Embedding progress: {{progress}} / {{total}}\n{{tokens_per_second}} tokens/sec using {{model_name}}",
    button: {
      en: "Pause",
      callback: (env) => {
        console.log("pausing");
        env.smart_sources.entities_vector_adapter.halt_embed_queue_processing();
      }
    },
    timeout: 0
  },
  embedding_complete: {
    en: "Embedding complete. {{total_embeddings}} embeddings created. {{tokens_per_second}} tokens/sec using {{model_name}}",
    timeout: 0
  },
  embedding_paused: {
    en: "Embedding paused. Progress: {{progress}} / {{total}}\n{{tokens_per_second}} tokens/sec using {{model_name}}",
    button: {
      en: "Resume",
      callback: (env) => {
        env.smart_sources.entities_vector_adapter.resume_embed_queue_processing(100);
      }
    },
    timeout: 0
  },
  embedding_error: {
    en: "Error embedding: {{error}}",
    timeout: 0
  },
  import_progress: {
    en: "Importing... {{progress}} / {{total}} sources",
    timeout: 0
  },
  done_import: {
    en: "Import complete. {{count}} sources imported in {{time_in_seconds}}s",
    timeout: 0
  },
  no_import_queue: {
    en: "No items in import queue"
  },
  clearing_all: {
    en: "Clearing all data...",
    timeout: 0
  },
  done_clearing_all: {
    en: "All data cleared and reimported",
    timeout: 3e3
  },
  image_extracting: {
    en: "Extracting text from Image(s)",
    timeout: 0
  },
  pdf_extracting: {
    en: "Extracting text from PDF(s)",
    timeout: 0
  },
  insufficient_settings: {
    en: "Insufficient settings for {{key}}, missing: {{missing}}",
    timeout: 0
  },
  unable_to_init_source: {
    en: "Unable to initialize source: {{key}}",
    timeout: 0
  },
  reload_sources: {
    en: "Reloaded sources in {{time_ms}}ms"
  }
};

// node_modules/smart-notices/smart_notices.js
function define_default_create_methods2(notices) {
  for (const key of Object.keys(notices)) {
    const notice_obj = notices[key];
    if (typeof notice_obj.create !== "function") {
      notice_obj.create = function(opts = {}) {
        let text = this.en ?? key;
        for (const [k, v] of Object.entries(opts)) {
          text = text.replace(new RegExp(`{{${k}}}`, "g"), String(v));
        }
        let button;
        if (!opts.button && this.button) {
          const btn_label = typeof this.button.en === "string" ? this.button.en : "OK";
          button = {
            text: btn_label,
            callback: typeof this.button.callback === "function" ? this.button.callback : () => {
            }
            // no-op
          };
        } else {
          button = opts.button;
        }
        let final_timeout = opts.timeout ?? this.timeout ?? 5e3;
        return {
          text,
          button,
          timeout: final_timeout,
          confirm: opts.confirm,
          // pass any user-provided confirm
          immutable: opts.immutable
          // pass any user-provided immutable
        };
      };
    }
  }
  return notices;
}
var SmartNotices2 = class {
  /**
   * @param {Object} scope - The main plugin instance
   */
  constructor(env, opts = {}) {
    env?.create_env_getter(this);
    this.active = {};
    this.adapter = opts.adapter || this.env.config.modules.smart_notices.adapter;
    define_default_create_methods2(NOTICES2);
  }
  /** plugin settings for notices (muted, etc.) */
  get settings() {
    if (!this.env?.settings?.smart_notices) {
      this.env.settings.smart_notices = {};
    }
    if (!this.env?.settings?.smart_notices?.muted) {
      this.env.settings.smart_notices.muted = {};
    }
    return this.env?.settings?.smart_notices;
  }
  /**
   * Displays a notice by key or custom message.
   * Usage:
   *   notices.show('load_env', { scope: this });
   *
   * @param {string} id - The notice key or custom ID
   * @param {object} opts - Additional user opts
   */
  show(id, opts = {}) {
    let message = null;
    if (typeof opts === "string") {
      message = opts;
    } else {
      opts = opts || {};
    }
    const normalized_id = this._normalize_notice_key(id);
    if (this.settings?.muted?.[normalized_id]) {
      if (opts.confirm?.callback) {
        opts.confirm.callback();
      }
      return;
    }
    const notice_entry = NOTICES2[id];
    let derived = {
      text: message || id,
      timeout: opts.timeout ?? 5e3,
      button: opts.button,
      immutable: opts.immutable,
      confirm: opts.confirm
    };
    if (notice_entry?.create) {
      const result = notice_entry.create({ ...opts });
      derived.text = message || result.text;
      derived.timeout = result.timeout;
      derived.button = result.button;
      derived.immutable = result.immutable;
      derived.confirm = result.confirm;
    }
    const content_fragment = this._build_fragment(normalized_id, derived.text, derived);
    if (this.active[normalized_id]?.noticeEl?.isConnected) {
      return this.active[normalized_id].setMessage(content_fragment, derived.timeout);
    }
    return this._render_notice(normalized_id, content_fragment, derived);
  }
  /**
   * Normalizes the notice key to a safe string.
   */
  _normalize_notice_key(key) {
    return key.replace(/[^a-zA-Z0-9_-]/g, "_");
  }
  /**
   * Creates and tracks the notice instance
   */
  _render_notice(normalized_id, content_fragment, { timeout }) {
    this.active[normalized_id] = new this.adapter(content_fragment, timeout);
    return this.active[normalized_id];
  }
  /**
   * Builds a DocumentFragment with notice text & possible buttons
   */
  _build_fragment(id, text, { button, confirm: confirm2, immutable }) {
    const frag = document.createDocumentFragment();
    frag.createEl("p", {
      cls: "sc-notice-head",
      text: `[Smart Env v${this.env.constructor.version}]`
    });
    const content = frag.createEl("p", { cls: "sc-notice-content", text });
    const actions = frag.createEl("div", { cls: "sc-notice-actions" });
    if (confirm2?.text && typeof confirm2.callback === "function") {
      this._add_button(confirm2, actions);
    }
    if (button?.text && typeof button.callback === "function") {
      this._add_button(button, actions);
    }
    if (!immutable) {
      this._add_mute_button(id, actions);
    }
    return frag;
  }
  /**
   * Creates a <button> appended to the container
   */
  _add_button(btnConfig, container) {
    const btn = document.createElement("button");
    this.env.smart_view.safe_inner_html(btn, btnConfig.text);
    btn.addEventListener("click", (e) => {
      if (btnConfig.stay_open) {
        e.preventDefault();
        e.stopPropagation();
      }
      btnConfig.callback?.(this.env);
    });
    container.appendChild(btn);
  }
  /**
   * Mute button
   */
  _add_mute_button(id, container) {
    const btn = document.createElement("button");
    (0, import_obsidian51.setIcon)(btn, "bell-off");
    btn.addEventListener("click", () => {
      if (!this.settings.muted) this.settings.muted = {};
      this.settings.muted[id] = true;
      if (NOTICES2["notice muted"]) {
        this.show("notice muted", null, { timeout: 2e3 });
      }
    });
    container.appendChild(btn);
  }
  /**
   * Hides & clears all active notices
   */
  unload() {
    for (const id in this.active) {
      this.remove(id);
    }
  }
  /**
   * Removes an active notice by key
   */
  remove(id) {
    const normalized_id = this._normalize_notice_key(id);
    this.active[normalized_id]?.hide();
    delete this.active[normalized_id];
  }
};

// src/views/connections_modal.js
var import_obsidian52 = require("obsidian");
var ConnectionsModal = class extends import_obsidian52.FuzzySuggestModal {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
    this.results = [];
    this.modalEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        e.stopPropagation();
        this.selectActiveSuggestion(e);
      }
    });
  }
  getItems() {
    return this.results;
  }
  async onOpen() {
    const active = this.app.workspace.getActiveFile();
    if (!active) return;
    const env = this.plugin.env;
    let entity = env.smart_sources.get(active.path);
    if (!entity) {
      entity = env.smart_sources.init_file_path(active.path);
      if (!entity) return;
      await entity.import();
      await env.smart_sources.process_embed_queue();
    }
    if (!entity.vec && entity.should_embed) {
      entity.queue_embed();
      await entity.collection.process_embed_queue();
    }
    this.results = await entity.find_connections();
    this.setInstructions([
      { command: "Enter", purpose: "Open and close modal" },
      { command: "\u2318/Ctrl + Enter", purpose: "Open in new tab and keep open" },
      { command: "\u2318/Ctrl + Alt + Enter", purpose: "Open in split (right) and keep open" },
      { command: "Esc", purpose: "Close" }
    ]);
    this.updateSuggestions();
  }
  getItemText(connection) {
    const name = connection.item.name ?? connection.item.key;
    const score = connection.score?.toFixed(2) ?? "?";
    return `${score} | ${name}`;
  }
  onChooseItem(connection, evt) {
    const target_path = connection.item.path;
    this.plugin.open_note(target_path, evt);
    if (import_obsidian52.Keymap.isModifier(evt, "Mod")) {
      this.open();
    }
  }
};

// node_modules/smart-chat-obsidian/src/settings_tab.js
var import_obsidian53 = require("obsidian");

// node_modules/smart-chat-obsidian/src/settings_tab.css
var css_sheet11 = new CSSStyleSheet();
css_sheet11.replaceSync(`@media (max-width: 768px) {
  .smart-chat-model-settings-container {
    .setting-item{
      flex-direction: column;
      align-items: baseline;
    }
  }
}

`);
var settings_tab_default = css_sheet11;

// node_modules/smart-chat-obsidian/src/settings_tab.js
var SmartChatSettingTab = class extends import_obsidian53.PluginSettingTab {
  /**
   * @param {import('obsidian').App} app - The current Obsidian app instance
   * @param {import('./main.js').default} plugin - The main plugin object
   */
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
    this.plugin.env.create_env_getter(this);
    this.name = "Smart Chat";
    this.id = "smart-chat";
  }
  /**
   * Called by Obsidian to render the settings page.
   */
  display() {
    this.containerEl.empty();
    if (!this.env) {
      this.containerEl.createEl("p", {
        text: "Smart Templates environment not yet initialized."
      });
      return;
    }
    this.containerEl.createEl("div", {
      cls: "smart-chat-settings-container"
    });
    this.containerEl.createEl("div", {
      cls: "smart-chat-model-settings-container"
    });
    this.containerEl.createEl("div", {
      cls: "smart-chat-env-settings-container"
    });
    this.containerEl.createEl("div", {
      cls: "smart-chat-supporter-callout-container"
    });
    this.env.render_component("chat_thread_settings", this.env).then((frag) => {
      const settings_container = this.containerEl.querySelector(".smart-chat-settings-container");
      settings_container.empty();
      settings_container.createEl("h3", {
        text: "Chat"
      });
      settings_container.appendChild(frag);
    });
    this.env.render_component("chat_model_settings", this.env).then((frag) => {
      const model_settings_container = this.containerEl.querySelector(".smart-chat-model-settings-container");
      model_settings_container.empty();
      model_settings_container.createEl("h3", {
        text: "Model"
      });
      model_settings_container.appendChild(frag);
      const chat_model_dropdown = model_settings_container.querySelector('[data-name="Chat Model"] select');
      chat_model_dropdown.addEventListener("change", (e) => {
        SmartChatView.open(this.plugin);
      });
    });
    this.env.smart_view.apply_style_sheet(settings_tab_default);
    this.env.render_component("env_settings", this.env).then((frag) => {
      const settings_container = this.containerEl.querySelector(".smart-chat-env-settings-container");
      settings_container.empty();
      settings_container.appendChild(frag);
    });
    this.env.render_component("supporter_callout", this.plugin, { plugin_name: "Smart Chat" }).then((frag) => {
      const supporter_callout_container = this.containerEl.querySelector(".smart-chat-supporter-callout-container");
      supporter_callout_container.appendChild(frag);
    });
  }
};

// src/bases/connections_score_column_modal.js
var import_obsidian54 = require("obsidian");

// src/views/release_notes_view.js
var import_obsidian55 = require("obsidian");

// releases/3.0.0.md
var __default = '# Smart Connections `v3`\n## New Features\n\n### Smart Chat v1\n- Effectively utilizes the Smart Environment architecture to facilitate deeper integration and new features.\n#### Improved Smart Chat UI\n- New context builder\n	- makes managing conversation context easier\n- Drag images and notes into the chat window to add as context\n- Separate settings tab specifically for chat features\n#### *Improved Smart Chat compatibility with Local Models*\n- Note lookup (RAG) now compatible with models that don\'t support tool calling\n	- Disable tool calling in the settings\n### Ollama embedding adapter\n- use Ollama to create embeddings\n\n## Fixed\n- renders content in connections results when all result items are expanded by default\n## Housekeeping\n- Updated README\n	- Improved Getting Started section\n	- Removed extraneous details\n- Improved version release process\n- Smart Chat `v0` (legacy)\n	- Smart Chat `v0` will continue to be available for a short time and will be removed in `v3.1` unless unforeseen issues arise in which case it will be removed sooner.\n	- Smart Chat `v0` code was moved from `brianpetro/jsbrains` to the Smart Connections repo\n\n## patch `v3.0.1`\n\nImproved Mobile UX and cleaned up extraneous code.\n\n## patch `v3.0.3`\n\nFixed issue where connections results would not render if expand-all results was toggled on.\n\n## patch `v3.0.4`\n\nPrevented frontmatter blocks from being included in connections results. Fixed toggle-fold-all logic.\n\n## patch `v3.0.5`\n\nFixes Ollama Embedding model loading issue in the settings.\n\n## patch `v3.0.6`\n\nFixed release notes should only show once after update.\n\n## patch `v3.0.7`\n\nAdded "current/dynamic" option in bases connection score modal to add score based on current file. Fixed issue causing Ollama to seemingly embed at 0 tokens/sec. Fixed bases integration modal failing on new bases.\n\n## patch `v3.0.8`\n\n- Improved bases integration UX\n	- prevent throwing error on erroroneous input in `cos_sim` base function\n	- gracefully handle when smart_env is not loaded yet\n- Reduced max size of markdown file that will be imported from 1MB to 300KB (prevent long initial import)\n	- advanced configuration available via `smart_sources.obsidian_markdown_source_content_adapter.max_import_size` in `smart_env.json`\n- Removed deprecated Smart Search API registered to window since `smart_env` object is now globally accessible\n- Fixed bug causing expanded connections results to render twice\n\n## patch `v3.0.9`\n\n- Reworked the context builder UX in Smart Chat to prevent confusion\n	- Context is now added to the chat regardless of how the context selector modal is closed\n	- Removed "Back" button in favor of "Back" suggestion item\n- Fixed using `@` to open context selector in Smart Chat\n	- "Done" button now appears in the context selector modal when it is opened from the keyboard\n\n## patch `v3.0.10`\n\nFixed Google Gemini integration in the new Smart Chat\n\n## patch `v3.0.11`\n\nFixes unexpected scroll issue when dragging file from connections view (issue #1073)\n\n## patch `v3.0.12`\n\nFixes pasted text: should paste lines in correct order (no longer reversed)\n\n## patch `v3.0.13`\n\n- Prevents trying to process embed queue if embed model is not loaded\n	- Particularly for Ollama which may not be turned on when Obsidian starts\n	- Re-checks for Ollama server in intervals of a minute\n	- Embed queue can be restarted by clicking "Reload sources" in the Smart Environment settings\n\n## patch `v3.0.14`\n\n- Improved hover popover for blocks in connections results and context builder\n- Refactored `context_builder` component to extract `context_tree` component and prevent passing UI components\n  - these components are frequently re-used, the updated architecture should make it easier to maintain and extend\n- Fixed: should not embed blocks with size less than `min_chars`\n- Fixed: Smart Chat completion requests should have a properly ordered `messages` array\n\n## patch `v3.0.15`\n\n- Fixed: some Ollama embedding models triggering re-embedding every restart\n\n## patch `v3.0.16`\n\n- Fixed: no models available in Ollama should no longer cause issues in the settings\n\n## patch `v3.0.17`\n\n- Improved embedding processing UX\n	- show notification immediately to allow pausing sooner\n	- show notification every 30 seconds in addition to every 100 embeddings\n- Fixed: Smart Environment settings tab should be visible during "loading" state\n	- prevents "Loading Obsidian Smart Environment..." message from appearing indefinitely in instances where the environment fails to load from errors related to specific embedding models\n\n## patch `v3.0.18`\n\n- Fixed: Smart Connections view rendering on mobile\n	- should render when opening the view from the sidebar\n	- should update the results to the currently active file\n\n## patch `v3.0.19`\n\n- Added: model info to Smart Chat view\n	- shows before the first message and anytime the model changes since the last message\n- Fixed: ChatGPT sign-in with Google account\n	- should now work as expected\n	- will require re-signing in to ChatGPT after update\n- Fixed: Smart Chat thread adapter should better handle past completions to prevent unexpected behavior\n	- prevented `build_request` from outputting certain request content unless the completion is the current completion\n		- logic is specific to completion adapters (actions, actions_xml, thread)\n\n## patch `v3.0.20`\n\n- Fixed: Smart Environment settings tab should be visible during "loading" and "loaded" states\n- Fixed: Open URL externally should use window.open with "_external" if webviewer plugin is installed\n\n## patch `v3.0.21`\n\n- Implemented Smart Completions fallback to Smart Chat configuration\n	- WHY: enables use via global `smart_env` instance without requiring `chat_model` parameters in every request\n\n## patch `v3.0.22`\n\n- Improved connections view event handling\n	- prevent throwing error when no view container is present on iOS\n\n## patch `v3.0.23`\n\n- Added Getting Started guide\n	- opens automatically for new users\n	- can be opened manually via command `Show getting started`\n	- can be opened from the connections view "Help" icon\n	- can be opened from the main settings "Open getting started guide" button\n\n## patch `v3.0.24`\n\nFix Lookup tab not displaying.\n\n## patch `v3.0.25`\n\nFixed connections view help button failing to open\n\n## patch `v3.0.26`\n\nTemp disable bases integration since Obsidian changed how the integration works and there is currently no clear path to updating.\n\n## patch `v3.0.27`\n\n- Added: Smart Chat lookup now supports folder-based filtering\n	- mention a folder when requesting a lookup using self-referential pronoun (no special folder syntax required)\n		- ex. "Summarize my thoughts on this topic based on notes in my Content folder"\n- Added: Smart Chat system prompt now allows `{{folder_tree}}` variable\n	- this variable will be replaced with the folder tree of the current vault\n	- useful for providing context about the vault structure to the model\n- Improved: Smart Chat system message UI\n	- now collapses when longer than 10 lines\n\n## patch `v3.0.28`\n\nFixed: Getting Started slideshow UX on mobile.\n\n## patch `v3.0.29`\n\n- Fixed: prevented regex special characters from throwing error when excluded file/folder contains them\n- Fixed: Smart Chat should return lookup context results when Smart Blocks are disabled\n\n## patch `v3.0.30`\n\n- Added: Drag multiple files into the Smart Chat window to add as context\n- Fixed: Smart Connections results remain stable when dragging connection from bottom of the list\n\n## patch `v3.0.31`\n\n- Added: Smart Chat: "Retrieve more" button in lookup results\n	- allows retrieving more results from the lookup\n	- includes retrieved context in subsequent lookup to provide more context to the model\n- Improved: Smart Chat: prior message handling in subsequent completions\n\n## patch `v3.0.32`\n\n- Added: Anthropic Claude Sonnet 4 & Opus 4 to Smart Chat\n- Improved: Smart Chat new note button no longer automatically addes open notes as context \n	- Added: "Add visible" and "Add open" notes options to Smart Context selector \n	- Added: "Add context" button above chat input on new chat for quick access to context selector\n- Fixed: Removing an item in the context selector updates the stats\n- Fixed: Smart Chat system message should render no more than once per turn\n\n## patch `v3.0.33`\n\n- Improved: Context Tree styles improved by samhiatt (PR #1091)\n- Improved: Smart Chat message should be full width if container is less than 600px\n- Fixed: Smart Chat model selection should handle when Ollama is available but no models are installed\n\n## patch `v3.0.34`\n\n- Added: Multi-modal support (images as context) using Ollama models\n	- requires Ollama models that support multi-modal input like `gemma3:4b`\n\n\n## patch `v3.0.37`\n\n- Fixed: Ollama `max_tokens` parameter should accurately reflect the model\'s max tokens\n- Fixed: Getting Started slideshow should only show automatically for new users\n\n## patch `v3.0.38`\n\n- Fixed: Smart Chat LM Studio models handling of `tool_choice` parameter\n\n## patch `v3.0.39`\n\n- Improved: Release notes user experience to use the same as the native Obsidian release notes\n	- Now uses new tab instead of modal to display the release notes\n- Fixed: Reduced vector length OpenAI embedding models should be selectable in the settings\n\n## patch `v3.0.40`\n\n- Added: Smart Chat: Support for PDFs as context in compatible models\n	- Currently works with Anthropic, Google Gemini, and OpenAI models\n	- PDFs must be manually added to the chat context. The context lookup action will not surface the PDFs because they are not embedded.\n- Improved: Smart Chat: LM Studio settings\n	- Added: Instructions for setting up LM Studio (CORS)\n	- Removed: Unecessary API key setting\n\n## patch `v3.0.41`\n\n- Fix: Bug in outlinks parsing was preventing embedding processing in some cases\n\n## patch `v3.0.42`\n\n- Added: `re_import_wait_time` setting to Smart Environment settings\n	- allows setting the time to wait before re-importing and embedding a note after it has been modified\n	- WHY: improves real-time nature of the connections\n- Improved: Connections view: Handling when current note hasn\'t been imported\n	- removed notification\n	- added refresh instructions to the connections view\n- Improved: Connections view when no results are found\n - added "No connections found" message\n - added instructions for reloading sources from the settings\n- Reduced size of bundled plugin from ~6.5MB to ~1MB (>80% reduction)\n - removed tokenizer that\'s only used by OpenAI embedding models\n - removed sourcemap since it\'s removed by Obsidian anyway\n - WHY: make the code easier to read (trust through transparency)\n- Fixed: Embeddings should update when file is changed\n\n## patch `v3.0.43`\n\n- Fixed: Smart Chat: Context tree connections icon should show connections in the suggestions when clicked\n\n## patch `v3.0.44`\n\n- Improved: Settings descriptions for the Connections view\n- Changed: Moved "muted notices" settings to the obsidian-smart-env module\n\n## patch `v3.0.45`\n\n- Added: Status element for indicating embedding queue for changed notes\n	- click to begin embedding otherwise waits until `re_import_wait_time` has passed\n- Fixed: Smart Environment: only changed blocks should re-embed when the note is modified\n	- Adds block has check to parse_blocks to prevent `queue_embed` from being called on blocks that haven\'t changed\n- Fixed: Release notes should open in a new tab instead of relpacing the current tab\n- Moved: Smart Plugins access to the obsidian-smart-env module\n\n## patch `v3.0.46`\n\n- Added: Smart Chat: Include relevance score for item in context tree if retrieved from a lookup\n	- allows users to see how relevant the item is to the current chat context\n- Added: Snowflake Arctic Embed models to the built-in embedding adapter (transformers)\n	- Snowflake/snowflake-arctic-embed-xs\n	- Snowflake/snowflake-arctic-embed-s\n	- Snowflake/snowflake-arctic-embed-m\n- Added: Report a bug and Request a feature buttons to the settings\n- Fixed: Smart Context: Tree should not split paths with slashes or hashtags within wikilinks\n	- ex. `[[some/path.md#subpath]]` should not be split into `some/path.md` and `subpath`\n- Improved: Smart Chat: Prevent trying to use folder scope in lookup when the folder provided by the AI does not exist\n\n## patch `v3.0.47`\n\n- Added: Hide connections in connections view\n	- Right-click on a connection result to open the new context menu\n	- Select "Hide" to hide the connection result\n	- Select "Unhide All" to unhide all hidden connections for the current item\n- Updated: Smart Contexts to use new ContextItem architecture\n	- The new architecture allows for more flexibility and better performance\n\n## patch `v3.0.50`\n\n- Added: Smart Chat: Latest OpenAI chat models (removed incompatible models)\n	- o3 and o4 class models now available in the settingsa\n\n## patch `v3.0.51`\n\n- Fixed: Connections view: Include/Exclude filters should allow multiple comma-separated values\n\n## patch `v3.0.52`\n\n- Fixed: Initial import should not embed blocks where `should_embed` is false\n  - see #1077 for details\n	- improves performance and decreases embedding time by reducing total number of blocks\n	- may require "Clear sources data" and "Reload sources" to be run in the settings to take effect\n\n## patch `v3.0.53`\n\n- Improved: Smart Chat: opening logic (prevent splitting sidebar)\n	- now opens in new tab in main workspace by default\n	- tab may still be dragged to the sidebar\n- Fixed: Smart Chat: Context selector should open when Smart Context plugin is not installed\n	- should now open the context selector modal instead of throwing an error\n\n## patch `v3.0.54`\n\n- Fixed: Smart Chat: Context selector: "Done" button should not cause crash\n- Added discussion template for Smart Connections workflows and button to open it\n	- encourages users to share their workflows with the community\n	- button opens the discussion template in a new tab\n	- discussion template includes instructions for sharing workflows\n\n## patch `v3.0.55`\n\n- Fixed: Smart Chat `@` should open context selector modal on subsequent messages\n\n## patch `v3.0.56`\n\n- Added: Smart Chat: Improved message link interactions\n  - hover-preview: hold cmd/ctrl while hovering to preview the link\n	- drag: click and hold the link, dragging it to create a link in the active note, or dragging to the chat window to add as context\n	- click: hold cmd/ctrl while clicking to open the link in a new tab, cmd/ctrl+alt click to open in split view\n- Fixed: Smart Chat: new threads should save after the first message\n\n## patch `v3.0.57`\n\n- Improved: Smart Chat: date format in default thread name\n- Fixed: Smart Chat: message copy button should copy message to the clipboard\n\n## patch `v3.0.58`\n\n- Improved: Smart Connections dynamic codeblock:  filter options passed to connections and lookup components; adjust styles for better layout\n- Fixed: Smart Chat: should always have a `current_completion` instance (prevent failing to send subsequent messages)\n\n## patch `v3.0.59`\n\n- Added: Smart Chat: xAI Grok adapter\n	- allows using xAI Grok models in Smart Chat\n	- requires xAI Grok API key to be set in the settings\n- Added: Excalidraw source adapter\n	- allows Excalidraw files to be used as sources in Smart Connections\n	- supports Excalidraw files with `.excalidraw.md` extension\n- Added: Source inspector: source-level information\n	- shows whether the source should be embedded based on the settings and current content\n	- shows whether the source has been embedded (vectorized)\n	- added button to show the full surce data object\n- Improved: Connections view: improved messaging when connections results cannot be returned\n	- added more detailed error messages for different failure scenarios\n\n## patch `v3.0.60`\n\n- Smart Chat: bug fixes\n	- improve chat thread name handling\n	- prevent errors when chat is open onload\n\n## patch `v3.0.61`\n\n- Added: Status bar: context menu\n	- inspect source and blocks for current note\n	- view Smart Environment stats\n- Added: Connections view setting: to only show sources (notes) in connections results';

// src/views/release_notes_view.js
var ReleaseNotesView = class _ReleaseNotesView extends import_obsidian55.ItemView {
  static get view_type() {
    return "smart-release-notes-view";
  }
  static get display_text() {
    return "Release Notes";
  }
  static get icon_name() {
    return "file-text";
  }
  static open(workspace, version, active = true) {
    const leaf = workspace.getLeaf("tab");
    leaf.setViewState({ type: this.view_type, active, state: { version } });
  }
  /* ───────────────────────────── item-view API ───────────────────────────── */
  getViewType() {
    return _ReleaseNotesView.view_type;
  }
  getDisplayText() {
    return _ReleaseNotesView.display_text;
  }
  getIcon() {
    return _ReleaseNotesView.icon_name;
  }
  /**
   * Build the preview container & render markdown using core renderer so the
   * output styles match native note preview exactly.
   */
  onOpen() {
    this.titleEl.setText(`What\u2019s new in v${this.version}`);
    this.render();
  }
  get container() {
    return this.containerEl?.querySelector(".view-content");
  }
  async render() {
    while (!this.container) {
      await new Promise((resolve) => setTimeout(resolve, 100));
      console.warn("Waiting for containerEl to be ready...", this.container);
    }
    import_obsidian55.MarkdownRenderer.render(
      this.app,
      __default,
      this.container,
      "",
      this
    );
    requestAnimationFrame(() => this.#scroll_to_version(this.container, this.version));
  }
  get version() {
    const version = this.leaf.viewState?.state?.version ?? this.app.plugins.getPlugin("smart-connections")?.manifest.version ?? "";
    return version;
  }
  #scroll_to_version(container, version) {
    if (!version) return;
    const safe = version.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const matcher = new RegExp(`\\bv?${safe}\\b`, "i");
    container.querySelectorAll("h1,h2,h3,h4,h5,h6").forEach((h) => {
      if (matcher.test(h.textContent ?? "")) {
        h.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    });
  }
};

// src/index.js
var {
  Notice: Notice8,
  Plugin,
  requestUrl: requestUrl5,
  Platform: Platform9
} = import_obsidian56.default;
var SmartConnectionsPlugin = class extends Plugin {
  get item_views() {
    return {
      ConnectionsView,
      ScLookupView,
      SmartChatsView,
      SmartChatGPTView,
      SmartPrivateChatView,
      ReleaseNotesView
    };
  }
  // GETTERS
  get obsidian() {
    return import_obsidian56.default;
  }
  get smart_env_config() {
    if (!this._smart_env_config) {
      const merged_env_config = merge_env_config(smart_env_config4, smart_env_config3);
      merge_env_config(merged_env_config, smart_env_config5);
      merge_env_config(merged_env_config, smart_env_config6);
      this._smart_env_config = {
        ...merged_env_config,
        env_path: "",
        // scope handled by Obsidian FS methods
        // DEPRECATED schema
        smart_env_settings: {
          // careful: overrides saved settings
          is_obsidian_vault: true
          // redundant with default_settings.is_obsidian_vault
        },
        request_adapter: this.obsidian.requestUrl
        // NEEDS BETTER HANDLING
      };
      if (Platform9.isMobile) {
        merge_env_config(this._smart_env_config, {
          collections: {
            smart_sources: { prevent_load_on_init: true }
          }
        });
      }
    }
    return this._smart_env_config;
  }
  get api() {
    return this._api;
  }
  onload() {
    this.app.workspace.onLayoutReady(this.initialize.bind(this));
    SmartEnv2.create(this);
    this.register_views();
    SmartChatView.register_view(this);
    this.addRibbonIcon("smart-connections", "Open: View Smart Connections", () => {
      this.open_connections_view();
    });
    this.addSettingTab(new ScSettingsTab(this.app, this));
    this.add_commands();
    this.register_code_blocks();
  }
  // async onload() { this.app.workspace.onLayoutReady(this.initialize.bind(this)); } // initialize when layout is ready
  onunload() {
    console.log("unloading plugin");
    this.env?.unload_main?.(this);
    this.notices?.unload();
  }
  async initialize() {
    await this.load_new_user_state();
    this.smart_connections_view = null;
    console.log("Smart Connections v2 loaded");
    if (this.is_new_user()) {
      setTimeout(() => {
        StoryModal.open(this, {
          title: "Getting Started With Smart Connections",
          url: "https://smartconnections.app/story/smart-connections-getting-started/?utm_source=sc-op-new-user"
        });
      }, 1e3);
    }
    await SmartEnv2.wait_for({ loaded: true });
    await this.migrate_last_version_from_localStorage();
    await this.check_for_updates();
    this.new_user();
    this.addSettingTab(new SmartChatSettingTab(this.app, this));
    this.register(() => {
      console.log("removing smart-chat setting tab");
      this.app.setting.removeSettingTab("smart-chat");
    });
    console.log("Smart Chat is registered");
  }
  register_code_blocks() {
    this.register_code_block("smart-connections", "render_code_block");
  }
  register_code_block(name, callback_name) {
    try {
      this.registerMarkdownCodeBlockProcessor(name, this[callback_name].bind(this));
    } catch (error) {
      console.warn(`Error registering code block: ${name}`, error);
    }
  }
  get settings() {
    return this.env?.settings || {};
  }
  async new_user() {
    if (!this.is_new_user()) return;
    await this.save_installed_at(Date.now());
    await this.set_last_known_version(this.manifest.version);
    setTimeout(() => {
      this.open_connections_view();
    }, 1e3);
    if (this.app.workspace.rightSplit.collapsed) this.app.workspace.rightSplit.toggle();
    this.add_to_gitignore("\n\n# Ignore Smart Environment folder\n.smart-env");
  }
  register_views() {
    Object.values(this.item_views).forEach((View) => {
      this.registerView(View.view_type, (leaf) => new View(leaf, this));
      this.addCommand({
        id: View.view_type,
        name: "Open: " + View.display_text + " view",
        callback: () => {
          View.open(this.app.workspace);
        }
      });
      const method_name = View.view_type.replace("smart-", "").replace(/-/g, "_");
      Object.defineProperty(this, method_name, { get: () => View.get_view(this.app.workspace) });
      this["open_" + method_name] = () => View.open(this.app.workspace);
    });
  }
  async check_for_updates() {
    if (await this.should_show_release_notes(this.manifest.version)) {
      console.log("opening release notes modal");
      try {
        ReleaseNotesView.open(this.app.workspace, this.manifest.version);
      } catch (e) {
        console.error("Failed to open ReleaseNotesView", e);
      }
      await this.set_last_known_version(this.manifest.version);
    }
    setTimeout(this.check_for_update.bind(this), 3e3);
    setInterval(this.check_for_update.bind(this), 108e5);
  }
  async check_for_update() {
    try {
      const { json: response } = await requestUrl5({
        url: "https://api.github.com/repos/brianpetro/obsidian-smart-connections/releases/latest",
        method: "GET",
        headers: {
          "Content-Type": "application/json"
        },
        contentType: "application/json"
      });
      const latest_release = response.tag_name;
      if (latest_release !== this.manifest.version) {
        this.notices?.show("new_version_available", { version: latest_release });
        this.update_available = true;
      }
    } catch (error) {
      console.error(error);
    }
  }
  async restart_plugin() {
    this.env?.unload_main?.(this);
    await new Promise((r) => setTimeout(r, 3e3));
    window.restart_plugin = async (id) => {
      await window.app.plugins.disablePlugin(id);
      await window.app.plugins.enablePlugin(id);
    };
    await window.restart_plugin(this.manifest.id);
  }
  add_commands() {
    this.addCommand({
      id: "sc-find-notes",
      name: "Find: Make Smart Connections",
      editorCallback: (editor) => {
        if (editor.somethingSelected()) {
          if (!this.lookup_view) this.open_lookup_view();
          this.lookup_view.render_view(editor.getSelection());
          return;
        }
        if (!this.connections_view) this.open_connections_view();
        if (editor.getCursor()?.line) {
          const line = editor.getCursor().line;
          const source2 = this.env.smart_sources.current_note;
          let item = source2.get_block_by_line(line);
          if (item?.vec) return this.connections_view.render_view(item);
          else this.connections_view.render_view(source2);
        } else this.connections_view.render_view();
      }
    });
    this.addCommand({
      id: "sc-refresh-connections",
      name: "Refresh & make connections",
      editorCallback: async (editor) => {
        const curr_file = this.app.workspace.getActiveFile();
        if (!curr_file?.path) return console.warn("No active file", curr_file);
        let source2 = this.env.smart_sources.get(curr_file.path);
        if (source2) {
          source2.data = { path: curr_file.path };
          const source_data_path = source2.collection.data_adapter.get_item_data_path(source2.key);
          await this.env.data_fs.remove(source_data_path);
        } else {
          source2 = this.env.smart_sources.init_file_path(curr_file.path);
        }
        if (!source2) return this.notices.show("unable_to_init_source", { key: curr_file.path });
        await source2.import();
        await this.env.smart_sources.process_embed_queue();
        setTimeout(() => {
          this.connections_view?.render_view?.();
        }, 1e3);
      }
    });
    this.addCommand({
      id: "smart-connections-random",
      name: "Random note",
      callback: async () => {
        const curr_file = this.app.workspace.getActiveFile();
        const entity = this.env.smart_sources.get(curr_file.path);
        const connections = await entity.find_connections({
          filter: { limit: 20 }
        });
        const rand = Math.floor(Math.random() * connections.length / 2);
        const rand_entity = connections[rand];
        this.open_note(rand_entity.item.path);
      }
    });
    this.addCommand({
      id: "open-connections-modal",
      name: "Connections modal",
      checkCallback: (checking) => {
        if (checking) return !!this.app.workspace.getActiveFile()?.path;
        const modal = new ConnectionsModal(this);
        modal.open();
      }
    });
    this.addCommand({
      id: "show-release-notes",
      name: "Show release notes",
      callback: () => ReleaseNotesView.open(this.app.workspace, this.manifest.version)
    });
    this.addCommand({
      id: "show-getting-started",
      name: "Show getting started",
      callback: () => {
        StoryModal.open(this, {
          title: "Getting Started With Smart Connections",
          url: "https://smartconnections.app/story/smart-connections-getting-started/?utm_source=sc-op-command"
        });
      }
    });
  }
  // We keep the old code
  async add_to_gitignore(ignore, message = null) {
    if (!await this.app.vault.adapter.exists(".gitignore")) return;
    let gitignore_file = await this.app.vault.adapter.read(".gitignore");
    if (gitignore_file.indexOf(ignore) < 0) {
      await this.app.vault.adapter.append(".gitignore", `

${message ? "# " + message + "\n" : ""}${ignore}`);
      console.log("Added to .gitignore: " + ignore);
    }
  }
  async open_note(target_path, event = null) {
    await open_note3(this, target_path, event);
  }
  async render_code_block(contents, container, ctx) {
    container.empty();
    container.createEl("span", { text: "Loading\u2026" });
    await SmartEnv2.wait_for({ loaded: true });
    const content_lines = [];
    const filter = {};
    if (contents.trim().length) {
      const lines = contents.split("\n").map((line) => line.trim()).filter((line) => line.length);
      for (const line of lines) {
        if (line.startsWith("include:")) {
          const value = line.replace("include:", "").trim();
          if (value) filter.key_includes_any = value.split(",").map((v) => v.trim());
          continue;
        }
        if (line.startsWith("does not end with:")) {
          const value = line.replace("does not end with:", "").trim();
          if (value) filter.exclude_key_ends_with_any = value.split(",").map((v) => v.trim());
          continue;
        }
        if (line.startsWith("limit:")) {
          const value = line.replace("limit:", "").trim();
          if (value) filter.limit = parseInt(value);
          continue;
        }
        content_lines.push(line);
      }
    }
    if (content_lines.length) {
      contents = content_lines.join("\n");
      const frag2 = await this.env.render_component(
        "lookup",
        this.env.smart_sources,
        { attribution: this.attribution, query: contents, filter }
      );
      container.empty();
      container.appendChild(frag2);
      return;
    }
    const entity = this.env.smart_sources.get(ctx.sourcePath) ?? this.env.smart_sources.init_file_path(ctx.sourcePath);
    if (!entity) {
      container.empty();
      container.createEl("p", { text: "Entity not found: " + ctx.sourcePath });
      return;
    }
    const frag = await this.env.render_component(
      "connections",
      entity,
      { attribution: this.attribution, filter }
    );
    container.empty();
    container.appendChild(frag);
  }
  get plugin_is_enabled() {
    return this.app?.plugins?.enabledPlugins?.has("smart-connections");
  }
  // DEPRECATED
  /**
   * @deprecated use SmartEnv.notices instead
   */
  get notices() {
    if (this.env?.notices) return this.env.notices;
    if (!this._notices) this._notices = new SmartNotices2(this.env, Notice8);
    return this._notices;
  }
  async load_new_user_state() {
    this._installed_at = null;
    const data = await this.loadData();
    if (this.migrate_installed_at_from_localStorage()) {
      return;
    }
    if (data && typeof data.installed_at !== "undefined") {
      this._installed_at = data.installed_at;
    }
  }
  migrate_installed_at_from_localStorage() {
    const localStorageKey = "smart_connections_new_user";
    if (typeof localStorage !== "undefined" && localStorage.getItem(localStorageKey) !== null) {
      const oldValue = localStorage.getItem(localStorageKey) !== "false";
      if (!oldValue) {
        this._installed_at = Date.now();
        this.save_installed_at(this._installed_at);
      }
      localStorage.removeItem(localStorageKey);
      return true;
    }
    return false;
  }
  async save_installed_at(value) {
    this._installed_at = value;
    const data = await this.loadData() || {};
    data.installed_at = value;
    if ("new_user" in data) delete data.new_user;
    await this.saveData(data);
  }
  is_new_user() {
    return !this._installed_at;
  }
  /**
   * MIGRATION: Move last_version from localStorage to plugin data.
   */
  async migrate_last_version_from_localStorage() {
    const localStorageKey = "smart_connections_last_version";
    if (typeof localStorage !== "undefined" && localStorage.getItem(localStorageKey)) {
      const version = localStorage.getItem(localStorageKey);
      await this.set_last_known_version(version);
      localStorage.removeItem(localStorageKey);
    }
  }
  /**
   * Returns the last saved plugin version or an empty string.
   * @returns {Promise<string>}
   */
  async get_last_known_version() {
    const data = await this.loadData() || {};
    return data.last_version || "";
  }
  /**
   * Persists the provided plugin version as last shown.
   * @param {string} version
   * @returns {Promise<void>}
   */
  async set_last_known_version(version) {
    const data = await this.loadData() || {};
    data.last_version = version;
    await this.saveData(data);
  }
  /**
   * Determines if release notes should be shown for `current_version`.
   * @param {string} current_version
   * @returns {Promise<boolean>}
   */
  async should_show_release_notes(current_version) {
    return await this.get_last_known_version() !== current_version;
  }
};

/* nosourcemap */